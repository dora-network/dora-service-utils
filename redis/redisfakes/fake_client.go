// Code generated by counterfeiter. DO NOT EDIT.
package redisfakes

import (
	"context"
	"sync"
	"time"

	"github.com/dora-network/dora-service-utils/redis"
	redisa "github.com/redis/go-redis/v9"
)

type FakeClient struct {
	ACLDryRunStub        func(context.Context, string, ...interface{}) *redisa.StringCmd
	aCLDryRunMutex       sync.RWMutex
	aCLDryRunArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	aCLDryRunReturns struct {
		result1 *redisa.StringCmd
	}
	aCLDryRunReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	ACLLogStub        func(context.Context, int64) *redisa.ACLLogCmd
	aCLLogMutex       sync.RWMutex
	aCLLogArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	aCLLogReturns struct {
		result1 *redisa.ACLLogCmd
	}
	aCLLogReturnsOnCall map[int]struct {
		result1 *redisa.ACLLogCmd
	}
	ACLLogResetStub        func(context.Context) *redisa.StatusCmd
	aCLLogResetMutex       sync.RWMutex
	aCLLogResetArgsForCall []struct {
		arg1 context.Context
	}
	aCLLogResetReturns struct {
		result1 *redisa.StatusCmd
	}
	aCLLogResetReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	AppendStub        func(context.Context, string, string) *redisa.IntCmd
	appendMutex       sync.RWMutex
	appendArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	appendReturns struct {
		result1 *redisa.IntCmd
	}
	appendReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	BFAddStub        func(context.Context, string, interface{}) *redisa.BoolCmd
	bFAddMutex       sync.RWMutex
	bFAddArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}
	bFAddReturns struct {
		result1 *redisa.BoolCmd
	}
	bFAddReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	BFCardStub        func(context.Context, string) *redisa.IntCmd
	bFCardMutex       sync.RWMutex
	bFCardArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	bFCardReturns struct {
		result1 *redisa.IntCmd
	}
	bFCardReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	BFExistsStub        func(context.Context, string, interface{}) *redisa.BoolCmd
	bFExistsMutex       sync.RWMutex
	bFExistsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}
	bFExistsReturns struct {
		result1 *redisa.BoolCmd
	}
	bFExistsReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	BFInfoStub        func(context.Context, string) *redisa.BFInfoCmd
	bFInfoMutex       sync.RWMutex
	bFInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	bFInfoReturns struct {
		result1 *redisa.BFInfoCmd
	}
	bFInfoReturnsOnCall map[int]struct {
		result1 *redisa.BFInfoCmd
	}
	BFInfoArgStub        func(context.Context, string, string) *redisa.BFInfoCmd
	bFInfoArgMutex       sync.RWMutex
	bFInfoArgArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	bFInfoArgReturns struct {
		result1 *redisa.BFInfoCmd
	}
	bFInfoArgReturnsOnCall map[int]struct {
		result1 *redisa.BFInfoCmd
	}
	BFInfoCapacityStub        func(context.Context, string) *redisa.BFInfoCmd
	bFInfoCapacityMutex       sync.RWMutex
	bFInfoCapacityArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	bFInfoCapacityReturns struct {
		result1 *redisa.BFInfoCmd
	}
	bFInfoCapacityReturnsOnCall map[int]struct {
		result1 *redisa.BFInfoCmd
	}
	BFInfoExpansionStub        func(context.Context, string) *redisa.BFInfoCmd
	bFInfoExpansionMutex       sync.RWMutex
	bFInfoExpansionArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	bFInfoExpansionReturns struct {
		result1 *redisa.BFInfoCmd
	}
	bFInfoExpansionReturnsOnCall map[int]struct {
		result1 *redisa.BFInfoCmd
	}
	BFInfoFiltersStub        func(context.Context, string) *redisa.BFInfoCmd
	bFInfoFiltersMutex       sync.RWMutex
	bFInfoFiltersArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	bFInfoFiltersReturns struct {
		result1 *redisa.BFInfoCmd
	}
	bFInfoFiltersReturnsOnCall map[int]struct {
		result1 *redisa.BFInfoCmd
	}
	BFInfoItemsStub        func(context.Context, string) *redisa.BFInfoCmd
	bFInfoItemsMutex       sync.RWMutex
	bFInfoItemsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	bFInfoItemsReturns struct {
		result1 *redisa.BFInfoCmd
	}
	bFInfoItemsReturnsOnCall map[int]struct {
		result1 *redisa.BFInfoCmd
	}
	BFInfoSizeStub        func(context.Context, string) *redisa.BFInfoCmd
	bFInfoSizeMutex       sync.RWMutex
	bFInfoSizeArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	bFInfoSizeReturns struct {
		result1 *redisa.BFInfoCmd
	}
	bFInfoSizeReturnsOnCall map[int]struct {
		result1 *redisa.BFInfoCmd
	}
	BFInsertStub        func(context.Context, string, *redisa.BFInsertOptions, ...interface{}) *redisa.BoolSliceCmd
	bFInsertMutex       sync.RWMutex
	bFInsertArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.BFInsertOptions
		arg4 []interface{}
	}
	bFInsertReturns struct {
		result1 *redisa.BoolSliceCmd
	}
	bFInsertReturnsOnCall map[int]struct {
		result1 *redisa.BoolSliceCmd
	}
	BFLoadChunkStub        func(context.Context, string, int64, interface{}) *redisa.StatusCmd
	bFLoadChunkMutex       sync.RWMutex
	bFLoadChunkArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 interface{}
	}
	bFLoadChunkReturns struct {
		result1 *redisa.StatusCmd
	}
	bFLoadChunkReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	BFMAddStub        func(context.Context, string, ...interface{}) *redisa.BoolSliceCmd
	bFMAddMutex       sync.RWMutex
	bFMAddArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	bFMAddReturns struct {
		result1 *redisa.BoolSliceCmd
	}
	bFMAddReturnsOnCall map[int]struct {
		result1 *redisa.BoolSliceCmd
	}
	BFMExistsStub        func(context.Context, string, ...interface{}) *redisa.BoolSliceCmd
	bFMExistsMutex       sync.RWMutex
	bFMExistsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	bFMExistsReturns struct {
		result1 *redisa.BoolSliceCmd
	}
	bFMExistsReturnsOnCall map[int]struct {
		result1 *redisa.BoolSliceCmd
	}
	BFReserveStub        func(context.Context, string, float64, int64) *redisa.StatusCmd
	bFReserveMutex       sync.RWMutex
	bFReserveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 int64
	}
	bFReserveReturns struct {
		result1 *redisa.StatusCmd
	}
	bFReserveReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	BFReserveExpansionStub        func(context.Context, string, float64, int64, int64) *redisa.StatusCmd
	bFReserveExpansionMutex       sync.RWMutex
	bFReserveExpansionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 int64
		arg5 int64
	}
	bFReserveExpansionReturns struct {
		result1 *redisa.StatusCmd
	}
	bFReserveExpansionReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	BFReserveNonScalingStub        func(context.Context, string, float64, int64) *redisa.StatusCmd
	bFReserveNonScalingMutex       sync.RWMutex
	bFReserveNonScalingArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 int64
	}
	bFReserveNonScalingReturns struct {
		result1 *redisa.StatusCmd
	}
	bFReserveNonScalingReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	BFReserveWithArgsStub        func(context.Context, string, *redisa.BFReserveOptions) *redisa.StatusCmd
	bFReserveWithArgsMutex       sync.RWMutex
	bFReserveWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.BFReserveOptions
	}
	bFReserveWithArgsReturns struct {
		result1 *redisa.StatusCmd
	}
	bFReserveWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	BFScanDumpStub        func(context.Context, string, int64) *redisa.ScanDumpCmd
	bFScanDumpMutex       sync.RWMutex
	bFScanDumpArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}
	bFScanDumpReturns struct {
		result1 *redisa.ScanDumpCmd
	}
	bFScanDumpReturnsOnCall map[int]struct {
		result1 *redisa.ScanDumpCmd
	}
	BLMPopStub        func(context.Context, time.Duration, string, int64, ...string) *redisa.KeyValuesCmd
	bLMPopMutex       sync.RWMutex
	bLMPopArgsForCall []struct {
		arg1 context.Context
		arg2 time.Duration
		arg3 string
		arg4 int64
		arg5 []string
	}
	bLMPopReturns struct {
		result1 *redisa.KeyValuesCmd
	}
	bLMPopReturnsOnCall map[int]struct {
		result1 *redisa.KeyValuesCmd
	}
	BLMoveStub        func(context.Context, string, string, string, string, time.Duration) *redisa.StringCmd
	bLMoveMutex       sync.RWMutex
	bLMoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 time.Duration
	}
	bLMoveReturns struct {
		result1 *redisa.StringCmd
	}
	bLMoveReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	BLPopStub        func(context.Context, time.Duration, ...string) *redisa.StringSliceCmd
	bLPopMutex       sync.RWMutex
	bLPopArgsForCall []struct {
		arg1 context.Context
		arg2 time.Duration
		arg3 []string
	}
	bLPopReturns struct {
		result1 *redisa.StringSliceCmd
	}
	bLPopReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	BRPopStub        func(context.Context, time.Duration, ...string) *redisa.StringSliceCmd
	bRPopMutex       sync.RWMutex
	bRPopArgsForCall []struct {
		arg1 context.Context
		arg2 time.Duration
		arg3 []string
	}
	bRPopReturns struct {
		result1 *redisa.StringSliceCmd
	}
	bRPopReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	BRPopLPushStub        func(context.Context, string, string, time.Duration) *redisa.StringCmd
	bRPopLPushMutex       sync.RWMutex
	bRPopLPushArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 time.Duration
	}
	bRPopLPushReturns struct {
		result1 *redisa.StringCmd
	}
	bRPopLPushReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	BZMPopStub        func(context.Context, time.Duration, string, int64, ...string) *redisa.ZSliceWithKeyCmd
	bZMPopMutex       sync.RWMutex
	bZMPopArgsForCall []struct {
		arg1 context.Context
		arg2 time.Duration
		arg3 string
		arg4 int64
		arg5 []string
	}
	bZMPopReturns struct {
		result1 *redisa.ZSliceWithKeyCmd
	}
	bZMPopReturnsOnCall map[int]struct {
		result1 *redisa.ZSliceWithKeyCmd
	}
	BZPopMaxStub        func(context.Context, time.Duration, ...string) *redisa.ZWithKeyCmd
	bZPopMaxMutex       sync.RWMutex
	bZPopMaxArgsForCall []struct {
		arg1 context.Context
		arg2 time.Duration
		arg3 []string
	}
	bZPopMaxReturns struct {
		result1 *redisa.ZWithKeyCmd
	}
	bZPopMaxReturnsOnCall map[int]struct {
		result1 *redisa.ZWithKeyCmd
	}
	BZPopMinStub        func(context.Context, time.Duration, ...string) *redisa.ZWithKeyCmd
	bZPopMinMutex       sync.RWMutex
	bZPopMinArgsForCall []struct {
		arg1 context.Context
		arg2 time.Duration
		arg3 []string
	}
	bZPopMinReturns struct {
		result1 *redisa.ZWithKeyCmd
	}
	bZPopMinReturnsOnCall map[int]struct {
		result1 *redisa.ZWithKeyCmd
	}
	BgRewriteAOFStub        func(context.Context) *redisa.StatusCmd
	bgRewriteAOFMutex       sync.RWMutex
	bgRewriteAOFArgsForCall []struct {
		arg1 context.Context
	}
	bgRewriteAOFReturns struct {
		result1 *redisa.StatusCmd
	}
	bgRewriteAOFReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	BgSaveStub        func(context.Context) *redisa.StatusCmd
	bgSaveMutex       sync.RWMutex
	bgSaveArgsForCall []struct {
		arg1 context.Context
	}
	bgSaveReturns struct {
		result1 *redisa.StatusCmd
	}
	bgSaveReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	BitCountStub        func(context.Context, string, *redisa.BitCount) *redisa.IntCmd
	bitCountMutex       sync.RWMutex
	bitCountArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.BitCount
	}
	bitCountReturns struct {
		result1 *redisa.IntCmd
	}
	bitCountReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	BitFieldStub        func(context.Context, string, ...interface{}) *redisa.IntSliceCmd
	bitFieldMutex       sync.RWMutex
	bitFieldArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	bitFieldReturns struct {
		result1 *redisa.IntSliceCmd
	}
	bitFieldReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	BitFieldROStub        func(context.Context, string, ...interface{}) *redisa.IntSliceCmd
	bitFieldROMutex       sync.RWMutex
	bitFieldROArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	bitFieldROReturns struct {
		result1 *redisa.IntSliceCmd
	}
	bitFieldROReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	BitOpAndStub        func(context.Context, string, ...string) *redisa.IntCmd
	bitOpAndMutex       sync.RWMutex
	bitOpAndArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	bitOpAndReturns struct {
		result1 *redisa.IntCmd
	}
	bitOpAndReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	BitOpNotStub        func(context.Context, string, string) *redisa.IntCmd
	bitOpNotMutex       sync.RWMutex
	bitOpNotArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	bitOpNotReturns struct {
		result1 *redisa.IntCmd
	}
	bitOpNotReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	BitOpOrStub        func(context.Context, string, ...string) *redisa.IntCmd
	bitOpOrMutex       sync.RWMutex
	bitOpOrArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	bitOpOrReturns struct {
		result1 *redisa.IntCmd
	}
	bitOpOrReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	BitOpXorStub        func(context.Context, string, ...string) *redisa.IntCmd
	bitOpXorMutex       sync.RWMutex
	bitOpXorArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	bitOpXorReturns struct {
		result1 *redisa.IntCmd
	}
	bitOpXorReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	BitPosStub        func(context.Context, string, int64, ...int64) *redisa.IntCmd
	bitPosMutex       sync.RWMutex
	bitPosArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 []int64
	}
	bitPosReturns struct {
		result1 *redisa.IntCmd
	}
	bitPosReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	BitPosSpanStub        func(context.Context, string, int8, int64, int64, string) *redisa.IntCmd
	bitPosSpanMutex       sync.RWMutex
	bitPosSpanArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int8
		arg4 int64
		arg5 int64
		arg6 string
	}
	bitPosSpanReturns struct {
		result1 *redisa.IntCmd
	}
	bitPosSpanReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	CFAddStub        func(context.Context, string, interface{}) *redisa.BoolCmd
	cFAddMutex       sync.RWMutex
	cFAddArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}
	cFAddReturns struct {
		result1 *redisa.BoolCmd
	}
	cFAddReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	CFAddNXStub        func(context.Context, string, interface{}) *redisa.BoolCmd
	cFAddNXMutex       sync.RWMutex
	cFAddNXArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}
	cFAddNXReturns struct {
		result1 *redisa.BoolCmd
	}
	cFAddNXReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	CFCountStub        func(context.Context, string, interface{}) *redisa.IntCmd
	cFCountMutex       sync.RWMutex
	cFCountArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}
	cFCountReturns struct {
		result1 *redisa.IntCmd
	}
	cFCountReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	CFDelStub        func(context.Context, string, interface{}) *redisa.BoolCmd
	cFDelMutex       sync.RWMutex
	cFDelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}
	cFDelReturns struct {
		result1 *redisa.BoolCmd
	}
	cFDelReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	CFExistsStub        func(context.Context, string, interface{}) *redisa.BoolCmd
	cFExistsMutex       sync.RWMutex
	cFExistsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}
	cFExistsReturns struct {
		result1 *redisa.BoolCmd
	}
	cFExistsReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	CFInfoStub        func(context.Context, string) *redisa.CFInfoCmd
	cFInfoMutex       sync.RWMutex
	cFInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	cFInfoReturns struct {
		result1 *redisa.CFInfoCmd
	}
	cFInfoReturnsOnCall map[int]struct {
		result1 *redisa.CFInfoCmd
	}
	CFInsertStub        func(context.Context, string, *redisa.CFInsertOptions, ...interface{}) *redisa.BoolSliceCmd
	cFInsertMutex       sync.RWMutex
	cFInsertArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.CFInsertOptions
		arg4 []interface{}
	}
	cFInsertReturns struct {
		result1 *redisa.BoolSliceCmd
	}
	cFInsertReturnsOnCall map[int]struct {
		result1 *redisa.BoolSliceCmd
	}
	CFInsertNXStub        func(context.Context, string, *redisa.CFInsertOptions, ...interface{}) *redisa.IntSliceCmd
	cFInsertNXMutex       sync.RWMutex
	cFInsertNXArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.CFInsertOptions
		arg4 []interface{}
	}
	cFInsertNXReturns struct {
		result1 *redisa.IntSliceCmd
	}
	cFInsertNXReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	CFLoadChunkStub        func(context.Context, string, int64, interface{}) *redisa.StatusCmd
	cFLoadChunkMutex       sync.RWMutex
	cFLoadChunkArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 interface{}
	}
	cFLoadChunkReturns struct {
		result1 *redisa.StatusCmd
	}
	cFLoadChunkReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	CFMExistsStub        func(context.Context, string, ...interface{}) *redisa.BoolSliceCmd
	cFMExistsMutex       sync.RWMutex
	cFMExistsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	cFMExistsReturns struct {
		result1 *redisa.BoolSliceCmd
	}
	cFMExistsReturnsOnCall map[int]struct {
		result1 *redisa.BoolSliceCmd
	}
	CFReserveStub        func(context.Context, string, int64) *redisa.StatusCmd
	cFReserveMutex       sync.RWMutex
	cFReserveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}
	cFReserveReturns struct {
		result1 *redisa.StatusCmd
	}
	cFReserveReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	CFReserveBucketSizeStub        func(context.Context, string, int64, int64) *redisa.StatusCmd
	cFReserveBucketSizeMutex       sync.RWMutex
	cFReserveBucketSizeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	cFReserveBucketSizeReturns struct {
		result1 *redisa.StatusCmd
	}
	cFReserveBucketSizeReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	CFReserveExpansionStub        func(context.Context, string, int64, int64) *redisa.StatusCmd
	cFReserveExpansionMutex       sync.RWMutex
	cFReserveExpansionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	cFReserveExpansionReturns struct {
		result1 *redisa.StatusCmd
	}
	cFReserveExpansionReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	CFReserveMaxIterationsStub        func(context.Context, string, int64, int64) *redisa.StatusCmd
	cFReserveMaxIterationsMutex       sync.RWMutex
	cFReserveMaxIterationsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	cFReserveMaxIterationsReturns struct {
		result1 *redisa.StatusCmd
	}
	cFReserveMaxIterationsReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	CFReserveWithArgsStub        func(context.Context, string, *redisa.CFReserveOptions) *redisa.StatusCmd
	cFReserveWithArgsMutex       sync.RWMutex
	cFReserveWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.CFReserveOptions
	}
	cFReserveWithArgsReturns struct {
		result1 *redisa.StatusCmd
	}
	cFReserveWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	CFScanDumpStub        func(context.Context, string, int64) *redisa.ScanDumpCmd
	cFScanDumpMutex       sync.RWMutex
	cFScanDumpArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}
	cFScanDumpReturns struct {
		result1 *redisa.ScanDumpCmd
	}
	cFScanDumpReturnsOnCall map[int]struct {
		result1 *redisa.ScanDumpCmd
	}
	CMSIncrByStub        func(context.Context, string, ...interface{}) *redisa.IntSliceCmd
	cMSIncrByMutex       sync.RWMutex
	cMSIncrByArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	cMSIncrByReturns struct {
		result1 *redisa.IntSliceCmd
	}
	cMSIncrByReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	CMSInfoStub        func(context.Context, string) *redisa.CMSInfoCmd
	cMSInfoMutex       sync.RWMutex
	cMSInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	cMSInfoReturns struct {
		result1 *redisa.CMSInfoCmd
	}
	cMSInfoReturnsOnCall map[int]struct {
		result1 *redisa.CMSInfoCmd
	}
	CMSInitByDimStub        func(context.Context, string, int64, int64) *redisa.StatusCmd
	cMSInitByDimMutex       sync.RWMutex
	cMSInitByDimArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	cMSInitByDimReturns struct {
		result1 *redisa.StatusCmd
	}
	cMSInitByDimReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	CMSInitByProbStub        func(context.Context, string, float64, float64) *redisa.StatusCmd
	cMSInitByProbMutex       sync.RWMutex
	cMSInitByProbArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 float64
	}
	cMSInitByProbReturns struct {
		result1 *redisa.StatusCmd
	}
	cMSInitByProbReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	CMSMergeStub        func(context.Context, string, ...string) *redisa.StatusCmd
	cMSMergeMutex       sync.RWMutex
	cMSMergeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	cMSMergeReturns struct {
		result1 *redisa.StatusCmd
	}
	cMSMergeReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	CMSMergeWithWeightStub        func(context.Context, string, map[string]int64) *redisa.StatusCmd
	cMSMergeWithWeightMutex       sync.RWMutex
	cMSMergeWithWeightArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 map[string]int64
	}
	cMSMergeWithWeightReturns struct {
		result1 *redisa.StatusCmd
	}
	cMSMergeWithWeightReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	CMSQueryStub        func(context.Context, string, ...interface{}) *redisa.IntSliceCmd
	cMSQueryMutex       sync.RWMutex
	cMSQueryArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	cMSQueryReturns struct {
		result1 *redisa.IntSliceCmd
	}
	cMSQueryReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	ClientGetNameStub        func(context.Context) *redisa.StringCmd
	clientGetNameMutex       sync.RWMutex
	clientGetNameArgsForCall []struct {
		arg1 context.Context
	}
	clientGetNameReturns struct {
		result1 *redisa.StringCmd
	}
	clientGetNameReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	ClientIDStub        func(context.Context) *redisa.IntCmd
	clientIDMutex       sync.RWMutex
	clientIDArgsForCall []struct {
		arg1 context.Context
	}
	clientIDReturns struct {
		result1 *redisa.IntCmd
	}
	clientIDReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ClientInfoStub        func(context.Context) *redisa.ClientInfoCmd
	clientInfoMutex       sync.RWMutex
	clientInfoArgsForCall []struct {
		arg1 context.Context
	}
	clientInfoReturns struct {
		result1 *redisa.ClientInfoCmd
	}
	clientInfoReturnsOnCall map[int]struct {
		result1 *redisa.ClientInfoCmd
	}
	ClientKillStub        func(context.Context, string) *redisa.StatusCmd
	clientKillMutex       sync.RWMutex
	clientKillArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	clientKillReturns struct {
		result1 *redisa.StatusCmd
	}
	clientKillReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ClientKillByFilterStub        func(context.Context, ...string) *redisa.IntCmd
	clientKillByFilterMutex       sync.RWMutex
	clientKillByFilterArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	clientKillByFilterReturns struct {
		result1 *redisa.IntCmd
	}
	clientKillByFilterReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ClientListStub        func(context.Context) *redisa.StringCmd
	clientListMutex       sync.RWMutex
	clientListArgsForCall []struct {
		arg1 context.Context
	}
	clientListReturns struct {
		result1 *redisa.StringCmd
	}
	clientListReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	ClientPauseStub        func(context.Context, time.Duration) *redisa.BoolCmd
	clientPauseMutex       sync.RWMutex
	clientPauseArgsForCall []struct {
		arg1 context.Context
		arg2 time.Duration
	}
	clientPauseReturns struct {
		result1 *redisa.BoolCmd
	}
	clientPauseReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	ClientUnblockStub        func(context.Context, int64) *redisa.IntCmd
	clientUnblockMutex       sync.RWMutex
	clientUnblockArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	clientUnblockReturns struct {
		result1 *redisa.IntCmd
	}
	clientUnblockReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ClientUnblockWithErrorStub        func(context.Context, int64) *redisa.IntCmd
	clientUnblockWithErrorMutex       sync.RWMutex
	clientUnblockWithErrorArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	clientUnblockWithErrorReturns struct {
		result1 *redisa.IntCmd
	}
	clientUnblockWithErrorReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ClientUnpauseStub        func(context.Context) *redisa.BoolCmd
	clientUnpauseMutex       sync.RWMutex
	clientUnpauseArgsForCall []struct {
		arg1 context.Context
	}
	clientUnpauseReturns struct {
		result1 *redisa.BoolCmd
	}
	clientUnpauseReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	ClusterAddSlotsStub        func(context.Context, ...int) *redisa.StatusCmd
	clusterAddSlotsMutex       sync.RWMutex
	clusterAddSlotsArgsForCall []struct {
		arg1 context.Context
		arg2 []int
	}
	clusterAddSlotsReturns struct {
		result1 *redisa.StatusCmd
	}
	clusterAddSlotsReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ClusterAddSlotsRangeStub        func(context.Context, int, int) *redisa.StatusCmd
	clusterAddSlotsRangeMutex       sync.RWMutex
	clusterAddSlotsRangeArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}
	clusterAddSlotsRangeReturns struct {
		result1 *redisa.StatusCmd
	}
	clusterAddSlotsRangeReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ClusterCountFailureReportsStub        func(context.Context, string) *redisa.IntCmd
	clusterCountFailureReportsMutex       sync.RWMutex
	clusterCountFailureReportsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	clusterCountFailureReportsReturns struct {
		result1 *redisa.IntCmd
	}
	clusterCountFailureReportsReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ClusterCountKeysInSlotStub        func(context.Context, int) *redisa.IntCmd
	clusterCountKeysInSlotMutex       sync.RWMutex
	clusterCountKeysInSlotArgsForCall []struct {
		arg1 context.Context
		arg2 int
	}
	clusterCountKeysInSlotReturns struct {
		result1 *redisa.IntCmd
	}
	clusterCountKeysInSlotReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ClusterDelSlotsStub        func(context.Context, ...int) *redisa.StatusCmd
	clusterDelSlotsMutex       sync.RWMutex
	clusterDelSlotsArgsForCall []struct {
		arg1 context.Context
		arg2 []int
	}
	clusterDelSlotsReturns struct {
		result1 *redisa.StatusCmd
	}
	clusterDelSlotsReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ClusterDelSlotsRangeStub        func(context.Context, int, int) *redisa.StatusCmd
	clusterDelSlotsRangeMutex       sync.RWMutex
	clusterDelSlotsRangeArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}
	clusterDelSlotsRangeReturns struct {
		result1 *redisa.StatusCmd
	}
	clusterDelSlotsRangeReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ClusterFailoverStub        func(context.Context) *redisa.StatusCmd
	clusterFailoverMutex       sync.RWMutex
	clusterFailoverArgsForCall []struct {
		arg1 context.Context
	}
	clusterFailoverReturns struct {
		result1 *redisa.StatusCmd
	}
	clusterFailoverReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ClusterForgetStub        func(context.Context, string) *redisa.StatusCmd
	clusterForgetMutex       sync.RWMutex
	clusterForgetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	clusterForgetReturns struct {
		result1 *redisa.StatusCmd
	}
	clusterForgetReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ClusterGetKeysInSlotStub        func(context.Context, int, int) *redisa.StringSliceCmd
	clusterGetKeysInSlotMutex       sync.RWMutex
	clusterGetKeysInSlotArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}
	clusterGetKeysInSlotReturns struct {
		result1 *redisa.StringSliceCmd
	}
	clusterGetKeysInSlotReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ClusterInfoStub        func(context.Context) *redisa.StringCmd
	clusterInfoMutex       sync.RWMutex
	clusterInfoArgsForCall []struct {
		arg1 context.Context
	}
	clusterInfoReturns struct {
		result1 *redisa.StringCmd
	}
	clusterInfoReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	ClusterKeySlotStub        func(context.Context, string) *redisa.IntCmd
	clusterKeySlotMutex       sync.RWMutex
	clusterKeySlotArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	clusterKeySlotReturns struct {
		result1 *redisa.IntCmd
	}
	clusterKeySlotReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ClusterLinksStub        func(context.Context) *redisa.ClusterLinksCmd
	clusterLinksMutex       sync.RWMutex
	clusterLinksArgsForCall []struct {
		arg1 context.Context
	}
	clusterLinksReturns struct {
		result1 *redisa.ClusterLinksCmd
	}
	clusterLinksReturnsOnCall map[int]struct {
		result1 *redisa.ClusterLinksCmd
	}
	ClusterMeetStub        func(context.Context, string, string) *redisa.StatusCmd
	clusterMeetMutex       sync.RWMutex
	clusterMeetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	clusterMeetReturns struct {
		result1 *redisa.StatusCmd
	}
	clusterMeetReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ClusterMyShardIDStub        func(context.Context) *redisa.StringCmd
	clusterMyShardIDMutex       sync.RWMutex
	clusterMyShardIDArgsForCall []struct {
		arg1 context.Context
	}
	clusterMyShardIDReturns struct {
		result1 *redisa.StringCmd
	}
	clusterMyShardIDReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	ClusterNodesStub        func(context.Context) *redisa.StringCmd
	clusterNodesMutex       sync.RWMutex
	clusterNodesArgsForCall []struct {
		arg1 context.Context
	}
	clusterNodesReturns struct {
		result1 *redisa.StringCmd
	}
	clusterNodesReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	ClusterReplicateStub        func(context.Context, string) *redisa.StatusCmd
	clusterReplicateMutex       sync.RWMutex
	clusterReplicateArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	clusterReplicateReturns struct {
		result1 *redisa.StatusCmd
	}
	clusterReplicateReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ClusterResetHardStub        func(context.Context) *redisa.StatusCmd
	clusterResetHardMutex       sync.RWMutex
	clusterResetHardArgsForCall []struct {
		arg1 context.Context
	}
	clusterResetHardReturns struct {
		result1 *redisa.StatusCmd
	}
	clusterResetHardReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ClusterResetSoftStub        func(context.Context) *redisa.StatusCmd
	clusterResetSoftMutex       sync.RWMutex
	clusterResetSoftArgsForCall []struct {
		arg1 context.Context
	}
	clusterResetSoftReturns struct {
		result1 *redisa.StatusCmd
	}
	clusterResetSoftReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ClusterSaveConfigStub        func(context.Context) *redisa.StatusCmd
	clusterSaveConfigMutex       sync.RWMutex
	clusterSaveConfigArgsForCall []struct {
		arg1 context.Context
	}
	clusterSaveConfigReturns struct {
		result1 *redisa.StatusCmd
	}
	clusterSaveConfigReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ClusterShardsStub        func(context.Context) *redisa.ClusterShardsCmd
	clusterShardsMutex       sync.RWMutex
	clusterShardsArgsForCall []struct {
		arg1 context.Context
	}
	clusterShardsReturns struct {
		result1 *redisa.ClusterShardsCmd
	}
	clusterShardsReturnsOnCall map[int]struct {
		result1 *redisa.ClusterShardsCmd
	}
	ClusterSlavesStub        func(context.Context, string) *redisa.StringSliceCmd
	clusterSlavesMutex       sync.RWMutex
	clusterSlavesArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	clusterSlavesReturns struct {
		result1 *redisa.StringSliceCmd
	}
	clusterSlavesReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ClusterSlotsStub        func(context.Context) *redisa.ClusterSlotsCmd
	clusterSlotsMutex       sync.RWMutex
	clusterSlotsArgsForCall []struct {
		arg1 context.Context
	}
	clusterSlotsReturns struct {
		result1 *redisa.ClusterSlotsCmd
	}
	clusterSlotsReturnsOnCall map[int]struct {
		result1 *redisa.ClusterSlotsCmd
	}
	CommandStub        func(context.Context) *redisa.CommandsInfoCmd
	commandMutex       sync.RWMutex
	commandArgsForCall []struct {
		arg1 context.Context
	}
	commandReturns struct {
		result1 *redisa.CommandsInfoCmd
	}
	commandReturnsOnCall map[int]struct {
		result1 *redisa.CommandsInfoCmd
	}
	CommandGetKeysStub        func(context.Context, ...interface{}) *redisa.StringSliceCmd
	commandGetKeysMutex       sync.RWMutex
	commandGetKeysArgsForCall []struct {
		arg1 context.Context
		arg2 []interface{}
	}
	commandGetKeysReturns struct {
		result1 *redisa.StringSliceCmd
	}
	commandGetKeysReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	CommandGetKeysAndFlagsStub        func(context.Context, ...interface{}) *redisa.KeyFlagsCmd
	commandGetKeysAndFlagsMutex       sync.RWMutex
	commandGetKeysAndFlagsArgsForCall []struct {
		arg1 context.Context
		arg2 []interface{}
	}
	commandGetKeysAndFlagsReturns struct {
		result1 *redisa.KeyFlagsCmd
	}
	commandGetKeysAndFlagsReturnsOnCall map[int]struct {
		result1 *redisa.KeyFlagsCmd
	}
	CommandListStub        func(context.Context, *redisa.FilterBy) *redisa.StringSliceCmd
	commandListMutex       sync.RWMutex
	commandListArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.FilterBy
	}
	commandListReturns struct {
		result1 *redisa.StringSliceCmd
	}
	commandListReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ConfigGetStub        func(context.Context, string) *redisa.MapStringStringCmd
	configGetMutex       sync.RWMutex
	configGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	configGetReturns struct {
		result1 *redisa.MapStringStringCmd
	}
	configGetReturnsOnCall map[int]struct {
		result1 *redisa.MapStringStringCmd
	}
	ConfigResetStatStub        func(context.Context) *redisa.StatusCmd
	configResetStatMutex       sync.RWMutex
	configResetStatArgsForCall []struct {
		arg1 context.Context
	}
	configResetStatReturns struct {
		result1 *redisa.StatusCmd
	}
	configResetStatReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ConfigRewriteStub        func(context.Context) *redisa.StatusCmd
	configRewriteMutex       sync.RWMutex
	configRewriteArgsForCall []struct {
		arg1 context.Context
	}
	configRewriteReturns struct {
		result1 *redisa.StatusCmd
	}
	configRewriteReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ConfigSetStub        func(context.Context, string, string) *redisa.StatusCmd
	configSetMutex       sync.RWMutex
	configSetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	configSetReturns struct {
		result1 *redisa.StatusCmd
	}
	configSetReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	CopyStub        func(context.Context, string, string, int, bool) *redisa.IntCmd
	copyMutex       sync.RWMutex
	copyArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 bool
	}
	copyReturns struct {
		result1 *redisa.IntCmd
	}
	copyReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	DBSizeStub        func(context.Context) *redisa.IntCmd
	dBSizeMutex       sync.RWMutex
	dBSizeArgsForCall []struct {
		arg1 context.Context
	}
	dBSizeReturns struct {
		result1 *redisa.IntCmd
	}
	dBSizeReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	DebugObjectStub        func(context.Context, string) *redisa.StringCmd
	debugObjectMutex       sync.RWMutex
	debugObjectArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	debugObjectReturns struct {
		result1 *redisa.StringCmd
	}
	debugObjectReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	DecrStub        func(context.Context, string) *redisa.IntCmd
	decrMutex       sync.RWMutex
	decrArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	decrReturns struct {
		result1 *redisa.IntCmd
	}
	decrReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	DecrByStub        func(context.Context, string, int64) *redisa.IntCmd
	decrByMutex       sync.RWMutex
	decrByArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}
	decrByReturns struct {
		result1 *redisa.IntCmd
	}
	decrByReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	DelStub        func(context.Context, ...string) *redisa.IntCmd
	delMutex       sync.RWMutex
	delArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	delReturns struct {
		result1 *redisa.IntCmd
	}
	delReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	DumpStub        func(context.Context, string) *redisa.StringCmd
	dumpMutex       sync.RWMutex
	dumpArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	dumpReturns struct {
		result1 *redisa.StringCmd
	}
	dumpReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	EchoStub        func(context.Context, interface{}) *redisa.StringCmd
	echoMutex       sync.RWMutex
	echoArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
	}
	echoReturns struct {
		result1 *redisa.StringCmd
	}
	echoReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	EvalStub        func(context.Context, string, []string, ...interface{}) *redisa.Cmd
	evalMutex       sync.RWMutex
	evalArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}
	evalReturns struct {
		result1 *redisa.Cmd
	}
	evalReturnsOnCall map[int]struct {
		result1 *redisa.Cmd
	}
	EvalROStub        func(context.Context, string, []string, ...interface{}) *redisa.Cmd
	evalROMutex       sync.RWMutex
	evalROArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}
	evalROReturns struct {
		result1 *redisa.Cmd
	}
	evalROReturnsOnCall map[int]struct {
		result1 *redisa.Cmd
	}
	EvalShaStub        func(context.Context, string, []string, ...interface{}) *redisa.Cmd
	evalShaMutex       sync.RWMutex
	evalShaArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}
	evalShaReturns struct {
		result1 *redisa.Cmd
	}
	evalShaReturnsOnCall map[int]struct {
		result1 *redisa.Cmd
	}
	EvalShaROStub        func(context.Context, string, []string, ...interface{}) *redisa.Cmd
	evalShaROMutex       sync.RWMutex
	evalShaROArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}
	evalShaROReturns struct {
		result1 *redisa.Cmd
	}
	evalShaROReturnsOnCall map[int]struct {
		result1 *redisa.Cmd
	}
	ExistsStub        func(context.Context, ...string) *redisa.IntCmd
	existsMutex       sync.RWMutex
	existsArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	existsReturns struct {
		result1 *redisa.IntCmd
	}
	existsReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ExpireStub        func(context.Context, string, time.Duration) *redisa.BoolCmd
	expireMutex       sync.RWMutex
	expireArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}
	expireReturns struct {
		result1 *redisa.BoolCmd
	}
	expireReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	ExpireAtStub        func(context.Context, string, time.Time) *redisa.BoolCmd
	expireAtMutex       sync.RWMutex
	expireAtArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Time
	}
	expireAtReturns struct {
		result1 *redisa.BoolCmd
	}
	expireAtReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	ExpireGTStub        func(context.Context, string, time.Duration) *redisa.BoolCmd
	expireGTMutex       sync.RWMutex
	expireGTArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}
	expireGTReturns struct {
		result1 *redisa.BoolCmd
	}
	expireGTReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	ExpireLTStub        func(context.Context, string, time.Duration) *redisa.BoolCmd
	expireLTMutex       sync.RWMutex
	expireLTArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}
	expireLTReturns struct {
		result1 *redisa.BoolCmd
	}
	expireLTReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	ExpireNXStub        func(context.Context, string, time.Duration) *redisa.BoolCmd
	expireNXMutex       sync.RWMutex
	expireNXArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}
	expireNXReturns struct {
		result1 *redisa.BoolCmd
	}
	expireNXReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	ExpireTimeStub        func(context.Context, string) *redisa.DurationCmd
	expireTimeMutex       sync.RWMutex
	expireTimeArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	expireTimeReturns struct {
		result1 *redisa.DurationCmd
	}
	expireTimeReturnsOnCall map[int]struct {
		result1 *redisa.DurationCmd
	}
	ExpireXXStub        func(context.Context, string, time.Duration) *redisa.BoolCmd
	expireXXMutex       sync.RWMutex
	expireXXArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}
	expireXXReturns struct {
		result1 *redisa.BoolCmd
	}
	expireXXReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	FCallStub        func(context.Context, string, []string, ...interface{}) *redisa.Cmd
	fCallMutex       sync.RWMutex
	fCallArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}
	fCallReturns struct {
		result1 *redisa.Cmd
	}
	fCallReturnsOnCall map[int]struct {
		result1 *redisa.Cmd
	}
	FCallROStub        func(context.Context, string, []string, ...interface{}) *redisa.Cmd
	fCallROMutex       sync.RWMutex
	fCallROArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}
	fCallROReturns struct {
		result1 *redisa.Cmd
	}
	fCallROReturnsOnCall map[int]struct {
		result1 *redisa.Cmd
	}
	FCallRoStub        func(context.Context, string, []string, ...interface{}) *redisa.Cmd
	fCallRoMutex       sync.RWMutex
	fCallRoArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}
	fCallRoReturns struct {
		result1 *redisa.Cmd
	}
	fCallRoReturnsOnCall map[int]struct {
		result1 *redisa.Cmd
	}
	FTAggregateStub        func(context.Context, string, string) *redisa.MapStringInterfaceCmd
	fTAggregateMutex       sync.RWMutex
	fTAggregateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	fTAggregateReturns struct {
		result1 *redisa.MapStringInterfaceCmd
	}
	fTAggregateReturnsOnCall map[int]struct {
		result1 *redisa.MapStringInterfaceCmd
	}
	FTAggregateWithArgsStub        func(context.Context, string, string, *redisa.FTAggregateOptions) *redisa.AggregateCmd
	fTAggregateWithArgsMutex       sync.RWMutex
	fTAggregateWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.FTAggregateOptions
	}
	fTAggregateWithArgsReturns struct {
		result1 *redisa.AggregateCmd
	}
	fTAggregateWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.AggregateCmd
	}
	FTAliasAddStub        func(context.Context, string, string) *redisa.StatusCmd
	fTAliasAddMutex       sync.RWMutex
	fTAliasAddArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	fTAliasAddReturns struct {
		result1 *redisa.StatusCmd
	}
	fTAliasAddReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FTAliasDelStub        func(context.Context, string) *redisa.StatusCmd
	fTAliasDelMutex       sync.RWMutex
	fTAliasDelArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	fTAliasDelReturns struct {
		result1 *redisa.StatusCmd
	}
	fTAliasDelReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FTAliasUpdateStub        func(context.Context, string, string) *redisa.StatusCmd
	fTAliasUpdateMutex       sync.RWMutex
	fTAliasUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	fTAliasUpdateReturns struct {
		result1 *redisa.StatusCmd
	}
	fTAliasUpdateReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FTAlterStub        func(context.Context, string, bool, []interface{}) *redisa.StatusCmd
	fTAlterMutex       sync.RWMutex
	fTAlterArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 bool
		arg4 []interface{}
	}
	fTAlterReturns struct {
		result1 *redisa.StatusCmd
	}
	fTAlterReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FTConfigGetStub        func(context.Context, string) *redisa.MapMapStringInterfaceCmd
	fTConfigGetMutex       sync.RWMutex
	fTConfigGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	fTConfigGetReturns struct {
		result1 *redisa.MapMapStringInterfaceCmd
	}
	fTConfigGetReturnsOnCall map[int]struct {
		result1 *redisa.MapMapStringInterfaceCmd
	}
	FTConfigSetStub        func(context.Context, string, interface{}) *redisa.StatusCmd
	fTConfigSetMutex       sync.RWMutex
	fTConfigSetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}
	fTConfigSetReturns struct {
		result1 *redisa.StatusCmd
	}
	fTConfigSetReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FTCreateStub        func(context.Context, string, *redisa.FTCreateOptions, ...*redisa.FieldSchema) *redisa.StatusCmd
	fTCreateMutex       sync.RWMutex
	fTCreateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.FTCreateOptions
		arg4 []*redisa.FieldSchema
	}
	fTCreateReturns struct {
		result1 *redisa.StatusCmd
	}
	fTCreateReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FTCursorDelStub        func(context.Context, string, int) *redisa.StatusCmd
	fTCursorDelMutex       sync.RWMutex
	fTCursorDelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}
	fTCursorDelReturns struct {
		result1 *redisa.StatusCmd
	}
	fTCursorDelReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FTCursorReadStub        func(context.Context, string, int, int) *redisa.MapStringInterfaceCmd
	fTCursorReadMutex       sync.RWMutex
	fTCursorReadArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 int
	}
	fTCursorReadReturns struct {
		result1 *redisa.MapStringInterfaceCmd
	}
	fTCursorReadReturnsOnCall map[int]struct {
		result1 *redisa.MapStringInterfaceCmd
	}
	FTDictAddStub        func(context.Context, string, ...interface{}) *redisa.IntCmd
	fTDictAddMutex       sync.RWMutex
	fTDictAddArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	fTDictAddReturns struct {
		result1 *redisa.IntCmd
	}
	fTDictAddReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	FTDictDelStub        func(context.Context, string, ...interface{}) *redisa.IntCmd
	fTDictDelMutex       sync.RWMutex
	fTDictDelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	fTDictDelReturns struct {
		result1 *redisa.IntCmd
	}
	fTDictDelReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	FTDictDumpStub        func(context.Context, string) *redisa.StringSliceCmd
	fTDictDumpMutex       sync.RWMutex
	fTDictDumpArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	fTDictDumpReturns struct {
		result1 *redisa.StringSliceCmd
	}
	fTDictDumpReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	FTDropIndexStub        func(context.Context, string) *redisa.StatusCmd
	fTDropIndexMutex       sync.RWMutex
	fTDropIndexArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	fTDropIndexReturns struct {
		result1 *redisa.StatusCmd
	}
	fTDropIndexReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FTDropIndexWithArgsStub        func(context.Context, string, *redisa.FTDropIndexOptions) *redisa.StatusCmd
	fTDropIndexWithArgsMutex       sync.RWMutex
	fTDropIndexWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.FTDropIndexOptions
	}
	fTDropIndexWithArgsReturns struct {
		result1 *redisa.StatusCmd
	}
	fTDropIndexWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FTExplainStub        func(context.Context, string, string) *redisa.StringCmd
	fTExplainMutex       sync.RWMutex
	fTExplainArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	fTExplainReturns struct {
		result1 *redisa.StringCmd
	}
	fTExplainReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	FTExplainWithArgsStub        func(context.Context, string, string, *redisa.FTExplainOptions) *redisa.StringCmd
	fTExplainWithArgsMutex       sync.RWMutex
	fTExplainWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.FTExplainOptions
	}
	fTExplainWithArgsReturns struct {
		result1 *redisa.StringCmd
	}
	fTExplainWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	FTInfoStub        func(context.Context, string) *redisa.FTInfoCmd
	fTInfoMutex       sync.RWMutex
	fTInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	fTInfoReturns struct {
		result1 *redisa.FTInfoCmd
	}
	fTInfoReturnsOnCall map[int]struct {
		result1 *redisa.FTInfoCmd
	}
	FTSearchStub        func(context.Context, string, string) *redisa.FTSearchCmd
	fTSearchMutex       sync.RWMutex
	fTSearchArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	fTSearchReturns struct {
		result1 *redisa.FTSearchCmd
	}
	fTSearchReturnsOnCall map[int]struct {
		result1 *redisa.FTSearchCmd
	}
	FTSearchWithArgsStub        func(context.Context, string, string, *redisa.FTSearchOptions) *redisa.FTSearchCmd
	fTSearchWithArgsMutex       sync.RWMutex
	fTSearchWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.FTSearchOptions
	}
	fTSearchWithArgsReturns struct {
		result1 *redisa.FTSearchCmd
	}
	fTSearchWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.FTSearchCmd
	}
	FTSpellCheckStub        func(context.Context, string, string) *redisa.FTSpellCheckCmd
	fTSpellCheckMutex       sync.RWMutex
	fTSpellCheckArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	fTSpellCheckReturns struct {
		result1 *redisa.FTSpellCheckCmd
	}
	fTSpellCheckReturnsOnCall map[int]struct {
		result1 *redisa.FTSpellCheckCmd
	}
	FTSpellCheckWithArgsStub        func(context.Context, string, string, *redisa.FTSpellCheckOptions) *redisa.FTSpellCheckCmd
	fTSpellCheckWithArgsMutex       sync.RWMutex
	fTSpellCheckWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.FTSpellCheckOptions
	}
	fTSpellCheckWithArgsReturns struct {
		result1 *redisa.FTSpellCheckCmd
	}
	fTSpellCheckWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.FTSpellCheckCmd
	}
	FTSynDumpStub        func(context.Context, string) *redisa.FTSynDumpCmd
	fTSynDumpMutex       sync.RWMutex
	fTSynDumpArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	fTSynDumpReturns struct {
		result1 *redisa.FTSynDumpCmd
	}
	fTSynDumpReturnsOnCall map[int]struct {
		result1 *redisa.FTSynDumpCmd
	}
	FTSynUpdateStub        func(context.Context, string, interface{}, []interface{}) *redisa.StatusCmd
	fTSynUpdateMutex       sync.RWMutex
	fTSynUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 []interface{}
	}
	fTSynUpdateReturns struct {
		result1 *redisa.StatusCmd
	}
	fTSynUpdateReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FTSynUpdateWithArgsStub        func(context.Context, string, interface{}, *redisa.FTSynUpdateOptions, []interface{}) *redisa.StatusCmd
	fTSynUpdateWithArgsMutex       sync.RWMutex
	fTSynUpdateWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 *redisa.FTSynUpdateOptions
		arg5 []interface{}
	}
	fTSynUpdateWithArgsReturns struct {
		result1 *redisa.StatusCmd
	}
	fTSynUpdateWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FTTagValsStub        func(context.Context, string, string) *redisa.StringSliceCmd
	fTTagValsMutex       sync.RWMutex
	fTTagValsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	fTTagValsReturns struct {
		result1 *redisa.StringSliceCmd
	}
	fTTagValsReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	FT_ListStub        func(context.Context) *redisa.StringSliceCmd
	fT_ListMutex       sync.RWMutex
	fT_ListArgsForCall []struct {
		arg1 context.Context
	}
	fT_ListReturns struct {
		result1 *redisa.StringSliceCmd
	}
	fT_ListReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	FlushAllStub        func(context.Context) *redisa.StatusCmd
	flushAllMutex       sync.RWMutex
	flushAllArgsForCall []struct {
		arg1 context.Context
	}
	flushAllReturns struct {
		result1 *redisa.StatusCmd
	}
	flushAllReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FlushAllAsyncStub        func(context.Context) *redisa.StatusCmd
	flushAllAsyncMutex       sync.RWMutex
	flushAllAsyncArgsForCall []struct {
		arg1 context.Context
	}
	flushAllAsyncReturns struct {
		result1 *redisa.StatusCmd
	}
	flushAllAsyncReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FlushDBStub        func(context.Context) *redisa.StatusCmd
	flushDBMutex       sync.RWMutex
	flushDBArgsForCall []struct {
		arg1 context.Context
	}
	flushDBReturns struct {
		result1 *redisa.StatusCmd
	}
	flushDBReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FlushDBAsyncStub        func(context.Context) *redisa.StatusCmd
	flushDBAsyncMutex       sync.RWMutex
	flushDBAsyncArgsForCall []struct {
		arg1 context.Context
	}
	flushDBAsyncReturns struct {
		result1 *redisa.StatusCmd
	}
	flushDBAsyncReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	FunctionDeleteStub        func(context.Context, string) *redisa.StringCmd
	functionDeleteMutex       sync.RWMutex
	functionDeleteArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	functionDeleteReturns struct {
		result1 *redisa.StringCmd
	}
	functionDeleteReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	FunctionDumpStub        func(context.Context) *redisa.StringCmd
	functionDumpMutex       sync.RWMutex
	functionDumpArgsForCall []struct {
		arg1 context.Context
	}
	functionDumpReturns struct {
		result1 *redisa.StringCmd
	}
	functionDumpReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	FunctionFlushStub        func(context.Context) *redisa.StringCmd
	functionFlushMutex       sync.RWMutex
	functionFlushArgsForCall []struct {
		arg1 context.Context
	}
	functionFlushReturns struct {
		result1 *redisa.StringCmd
	}
	functionFlushReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	FunctionFlushAsyncStub        func(context.Context) *redisa.StringCmd
	functionFlushAsyncMutex       sync.RWMutex
	functionFlushAsyncArgsForCall []struct {
		arg1 context.Context
	}
	functionFlushAsyncReturns struct {
		result1 *redisa.StringCmd
	}
	functionFlushAsyncReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	FunctionKillStub        func(context.Context) *redisa.StringCmd
	functionKillMutex       sync.RWMutex
	functionKillArgsForCall []struct {
		arg1 context.Context
	}
	functionKillReturns struct {
		result1 *redisa.StringCmd
	}
	functionKillReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	FunctionListStub        func(context.Context, redisa.FunctionListQuery) *redisa.FunctionListCmd
	functionListMutex       sync.RWMutex
	functionListArgsForCall []struct {
		arg1 context.Context
		arg2 redisa.FunctionListQuery
	}
	functionListReturns struct {
		result1 *redisa.FunctionListCmd
	}
	functionListReturnsOnCall map[int]struct {
		result1 *redisa.FunctionListCmd
	}
	FunctionLoadStub        func(context.Context, string) *redisa.StringCmd
	functionLoadMutex       sync.RWMutex
	functionLoadArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	functionLoadReturns struct {
		result1 *redisa.StringCmd
	}
	functionLoadReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	FunctionLoadReplaceStub        func(context.Context, string) *redisa.StringCmd
	functionLoadReplaceMutex       sync.RWMutex
	functionLoadReplaceArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	functionLoadReplaceReturns struct {
		result1 *redisa.StringCmd
	}
	functionLoadReplaceReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	FunctionRestoreStub        func(context.Context, string) *redisa.StringCmd
	functionRestoreMutex       sync.RWMutex
	functionRestoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	functionRestoreReturns struct {
		result1 *redisa.StringCmd
	}
	functionRestoreReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	FunctionStatsStub        func(context.Context) *redisa.FunctionStatsCmd
	functionStatsMutex       sync.RWMutex
	functionStatsArgsForCall []struct {
		arg1 context.Context
	}
	functionStatsReturns struct {
		result1 *redisa.FunctionStatsCmd
	}
	functionStatsReturnsOnCall map[int]struct {
		result1 *redisa.FunctionStatsCmd
	}
	GeoAddStub        func(context.Context, string, ...*redisa.GeoLocation) *redisa.IntCmd
	geoAddMutex       sync.RWMutex
	geoAddArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []*redisa.GeoLocation
	}
	geoAddReturns struct {
		result1 *redisa.IntCmd
	}
	geoAddReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	GeoDistStub        func(context.Context, string, string, string, string) *redisa.FloatCmd
	geoDistMutex       sync.RWMutex
	geoDistArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	geoDistReturns struct {
		result1 *redisa.FloatCmd
	}
	geoDistReturnsOnCall map[int]struct {
		result1 *redisa.FloatCmd
	}
	GeoHashStub        func(context.Context, string, ...string) *redisa.StringSliceCmd
	geoHashMutex       sync.RWMutex
	geoHashArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	geoHashReturns struct {
		result1 *redisa.StringSliceCmd
	}
	geoHashReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	GeoPosStub        func(context.Context, string, ...string) *redisa.GeoPosCmd
	geoPosMutex       sync.RWMutex
	geoPosArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	geoPosReturns struct {
		result1 *redisa.GeoPosCmd
	}
	geoPosReturnsOnCall map[int]struct {
		result1 *redisa.GeoPosCmd
	}
	GeoRadiusStub        func(context.Context, string, float64, float64, *redisa.GeoRadiusQuery) *redisa.GeoLocationCmd
	geoRadiusMutex       sync.RWMutex
	geoRadiusArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 float64
		arg5 *redisa.GeoRadiusQuery
	}
	geoRadiusReturns struct {
		result1 *redisa.GeoLocationCmd
	}
	geoRadiusReturnsOnCall map[int]struct {
		result1 *redisa.GeoLocationCmd
	}
	GeoRadiusByMemberStub        func(context.Context, string, string, *redisa.GeoRadiusQuery) *redisa.GeoLocationCmd
	geoRadiusByMemberMutex       sync.RWMutex
	geoRadiusByMemberArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.GeoRadiusQuery
	}
	geoRadiusByMemberReturns struct {
		result1 *redisa.GeoLocationCmd
	}
	geoRadiusByMemberReturnsOnCall map[int]struct {
		result1 *redisa.GeoLocationCmd
	}
	GeoRadiusByMemberStoreStub        func(context.Context, string, string, *redisa.GeoRadiusQuery) *redisa.IntCmd
	geoRadiusByMemberStoreMutex       sync.RWMutex
	geoRadiusByMemberStoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.GeoRadiusQuery
	}
	geoRadiusByMemberStoreReturns struct {
		result1 *redisa.IntCmd
	}
	geoRadiusByMemberStoreReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	GeoRadiusStoreStub        func(context.Context, string, float64, float64, *redisa.GeoRadiusQuery) *redisa.IntCmd
	geoRadiusStoreMutex       sync.RWMutex
	geoRadiusStoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 float64
		arg5 *redisa.GeoRadiusQuery
	}
	geoRadiusStoreReturns struct {
		result1 *redisa.IntCmd
	}
	geoRadiusStoreReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	GeoSearchStub        func(context.Context, string, *redisa.GeoSearchQuery) *redisa.StringSliceCmd
	geoSearchMutex       sync.RWMutex
	geoSearchArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.GeoSearchQuery
	}
	geoSearchReturns struct {
		result1 *redisa.StringSliceCmd
	}
	geoSearchReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	GeoSearchLocationStub        func(context.Context, string, *redisa.GeoSearchLocationQuery) *redisa.GeoSearchLocationCmd
	geoSearchLocationMutex       sync.RWMutex
	geoSearchLocationArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.GeoSearchLocationQuery
	}
	geoSearchLocationReturns struct {
		result1 *redisa.GeoSearchLocationCmd
	}
	geoSearchLocationReturnsOnCall map[int]struct {
		result1 *redisa.GeoSearchLocationCmd
	}
	GeoSearchStoreStub        func(context.Context, string, string, *redisa.GeoSearchStoreQuery) *redisa.IntCmd
	geoSearchStoreMutex       sync.RWMutex
	geoSearchStoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.GeoSearchStoreQuery
	}
	geoSearchStoreReturns struct {
		result1 *redisa.IntCmd
	}
	geoSearchStoreReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	GetStub        func(context.Context, string) *redisa.StringCmd
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getReturns struct {
		result1 *redisa.StringCmd
	}
	getReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	GetBitStub        func(context.Context, string, int64) *redisa.IntCmd
	getBitMutex       sync.RWMutex
	getBitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}
	getBitReturns struct {
		result1 *redisa.IntCmd
	}
	getBitReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	GetDelStub        func(context.Context, string) *redisa.StringCmd
	getDelMutex       sync.RWMutex
	getDelArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getDelReturns struct {
		result1 *redisa.StringCmd
	}
	getDelReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	GetExStub        func(context.Context, string, time.Duration) *redisa.StringCmd
	getExMutex       sync.RWMutex
	getExArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}
	getExReturns struct {
		result1 *redisa.StringCmd
	}
	getExReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	GetRangeStub        func(context.Context, string, int64, int64) *redisa.StringCmd
	getRangeMutex       sync.RWMutex
	getRangeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	getRangeReturns struct {
		result1 *redisa.StringCmd
	}
	getRangeReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	GetSetStub        func(context.Context, string, interface{}) *redisa.StringCmd
	getSetMutex       sync.RWMutex
	getSetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}
	getSetReturns struct {
		result1 *redisa.StringCmd
	}
	getSetReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	HDelStub        func(context.Context, string, ...string) *redisa.IntCmd
	hDelMutex       sync.RWMutex
	hDelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	hDelReturns struct {
		result1 *redisa.IntCmd
	}
	hDelReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	HExistsStub        func(context.Context, string, string) *redisa.BoolCmd
	hExistsMutex       sync.RWMutex
	hExistsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	hExistsReturns struct {
		result1 *redisa.BoolCmd
	}
	hExistsReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	HExpireStub        func(context.Context, string, time.Duration, ...string) *redisa.IntSliceCmd
	hExpireMutex       sync.RWMutex
	hExpireArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
		arg4 []string
	}
	hExpireReturns struct {
		result1 *redisa.IntSliceCmd
	}
	hExpireReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	HExpireAtStub        func(context.Context, string, time.Time, ...string) *redisa.IntSliceCmd
	hExpireAtMutex       sync.RWMutex
	hExpireAtArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Time
		arg4 []string
	}
	hExpireAtReturns struct {
		result1 *redisa.IntSliceCmd
	}
	hExpireAtReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	HExpireAtWithArgsStub        func(context.Context, string, time.Time, redisa.HExpireArgs, ...string) *redisa.IntSliceCmd
	hExpireAtWithArgsMutex       sync.RWMutex
	hExpireAtWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Time
		arg4 redisa.HExpireArgs
		arg5 []string
	}
	hExpireAtWithArgsReturns struct {
		result1 *redisa.IntSliceCmd
	}
	hExpireAtWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	HExpireTimeStub        func(context.Context, string, ...string) *redisa.IntSliceCmd
	hExpireTimeMutex       sync.RWMutex
	hExpireTimeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	hExpireTimeReturns struct {
		result1 *redisa.IntSliceCmd
	}
	hExpireTimeReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	HExpireWithArgsStub        func(context.Context, string, time.Duration, redisa.HExpireArgs, ...string) *redisa.IntSliceCmd
	hExpireWithArgsMutex       sync.RWMutex
	hExpireWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
		arg4 redisa.HExpireArgs
		arg5 []string
	}
	hExpireWithArgsReturns struct {
		result1 *redisa.IntSliceCmd
	}
	hExpireWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	HGetStub        func(context.Context, string, string) *redisa.StringCmd
	hGetMutex       sync.RWMutex
	hGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	hGetReturns struct {
		result1 *redisa.StringCmd
	}
	hGetReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	HGetAllStub        func(context.Context, string) *redisa.MapStringStringCmd
	hGetAllMutex       sync.RWMutex
	hGetAllArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	hGetAllReturns struct {
		result1 *redisa.MapStringStringCmd
	}
	hGetAllReturnsOnCall map[int]struct {
		result1 *redisa.MapStringStringCmd
	}
	HIncrByStub        func(context.Context, string, string, int64) *redisa.IntCmd
	hIncrByMutex       sync.RWMutex
	hIncrByArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}
	hIncrByReturns struct {
		result1 *redisa.IntCmd
	}
	hIncrByReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	HIncrByFloatStub        func(context.Context, string, string, float64) *redisa.FloatCmd
	hIncrByFloatMutex       sync.RWMutex
	hIncrByFloatArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 float64
	}
	hIncrByFloatReturns struct {
		result1 *redisa.FloatCmd
	}
	hIncrByFloatReturnsOnCall map[int]struct {
		result1 *redisa.FloatCmd
	}
	HKeysStub        func(context.Context, string) *redisa.StringSliceCmd
	hKeysMutex       sync.RWMutex
	hKeysArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	hKeysReturns struct {
		result1 *redisa.StringSliceCmd
	}
	hKeysReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	HLenStub        func(context.Context, string) *redisa.IntCmd
	hLenMutex       sync.RWMutex
	hLenArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	hLenReturns struct {
		result1 *redisa.IntCmd
	}
	hLenReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	HMGetStub        func(context.Context, string, ...string) *redisa.SliceCmd
	hMGetMutex       sync.RWMutex
	hMGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	hMGetReturns struct {
		result1 *redisa.SliceCmd
	}
	hMGetReturnsOnCall map[int]struct {
		result1 *redisa.SliceCmd
	}
	HMSetStub        func(context.Context, string, ...interface{}) *redisa.BoolCmd
	hMSetMutex       sync.RWMutex
	hMSetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	hMSetReturns struct {
		result1 *redisa.BoolCmd
	}
	hMSetReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	HPExpireStub        func(context.Context, string, time.Duration, ...string) *redisa.IntSliceCmd
	hPExpireMutex       sync.RWMutex
	hPExpireArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
		arg4 []string
	}
	hPExpireReturns struct {
		result1 *redisa.IntSliceCmd
	}
	hPExpireReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	HPExpireAtStub        func(context.Context, string, time.Time, ...string) *redisa.IntSliceCmd
	hPExpireAtMutex       sync.RWMutex
	hPExpireAtArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Time
		arg4 []string
	}
	hPExpireAtReturns struct {
		result1 *redisa.IntSliceCmd
	}
	hPExpireAtReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	HPExpireAtWithArgsStub        func(context.Context, string, time.Time, redisa.HExpireArgs, ...string) *redisa.IntSliceCmd
	hPExpireAtWithArgsMutex       sync.RWMutex
	hPExpireAtWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Time
		arg4 redisa.HExpireArgs
		arg5 []string
	}
	hPExpireAtWithArgsReturns struct {
		result1 *redisa.IntSliceCmd
	}
	hPExpireAtWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	HPExpireTimeStub        func(context.Context, string, ...string) *redisa.IntSliceCmd
	hPExpireTimeMutex       sync.RWMutex
	hPExpireTimeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	hPExpireTimeReturns struct {
		result1 *redisa.IntSliceCmd
	}
	hPExpireTimeReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	HPExpireWithArgsStub        func(context.Context, string, time.Duration, redisa.HExpireArgs, ...string) *redisa.IntSliceCmd
	hPExpireWithArgsMutex       sync.RWMutex
	hPExpireWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
		arg4 redisa.HExpireArgs
		arg5 []string
	}
	hPExpireWithArgsReturns struct {
		result1 *redisa.IntSliceCmd
	}
	hPExpireWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	HPTTLStub        func(context.Context, string, ...string) *redisa.IntSliceCmd
	hPTTLMutex       sync.RWMutex
	hPTTLArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	hPTTLReturns struct {
		result1 *redisa.IntSliceCmd
	}
	hPTTLReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	HPersistStub        func(context.Context, string, ...string) *redisa.IntSliceCmd
	hPersistMutex       sync.RWMutex
	hPersistArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	hPersistReturns struct {
		result1 *redisa.IntSliceCmd
	}
	hPersistReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	HRandFieldStub        func(context.Context, string, int) *redisa.StringSliceCmd
	hRandFieldMutex       sync.RWMutex
	hRandFieldArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}
	hRandFieldReturns struct {
		result1 *redisa.StringSliceCmd
	}
	hRandFieldReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	HRandFieldWithValuesStub        func(context.Context, string, int) *redisa.KeyValueSliceCmd
	hRandFieldWithValuesMutex       sync.RWMutex
	hRandFieldWithValuesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}
	hRandFieldWithValuesReturns struct {
		result1 *redisa.KeyValueSliceCmd
	}
	hRandFieldWithValuesReturnsOnCall map[int]struct {
		result1 *redisa.KeyValueSliceCmd
	}
	HScanStub        func(context.Context, string, uint64, string, int64) *redisa.ScanCmd
	hScanMutex       sync.RWMutex
	hScanArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 uint64
		arg4 string
		arg5 int64
	}
	hScanReturns struct {
		result1 *redisa.ScanCmd
	}
	hScanReturnsOnCall map[int]struct {
		result1 *redisa.ScanCmd
	}
	HScanNoValuesStub        func(context.Context, string, uint64, string, int64) *redisa.ScanCmd
	hScanNoValuesMutex       sync.RWMutex
	hScanNoValuesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 uint64
		arg4 string
		arg5 int64
	}
	hScanNoValuesReturns struct {
		result1 *redisa.ScanCmd
	}
	hScanNoValuesReturnsOnCall map[int]struct {
		result1 *redisa.ScanCmd
	}
	HSetStub        func(context.Context, string, ...interface{}) *redisa.IntCmd
	hSetMutex       sync.RWMutex
	hSetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	hSetReturns struct {
		result1 *redisa.IntCmd
	}
	hSetReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	HSetNXStub        func(context.Context, string, string, interface{}) *redisa.BoolCmd
	hSetNXMutex       sync.RWMutex
	hSetNXArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 interface{}
	}
	hSetNXReturns struct {
		result1 *redisa.BoolCmd
	}
	hSetNXReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	HTTLStub        func(context.Context, string, ...string) *redisa.IntSliceCmd
	hTTLMutex       sync.RWMutex
	hTTLArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	hTTLReturns struct {
		result1 *redisa.IntSliceCmd
	}
	hTTLReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	HValsStub        func(context.Context, string) *redisa.StringSliceCmd
	hValsMutex       sync.RWMutex
	hValsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	hValsReturns struct {
		result1 *redisa.StringSliceCmd
	}
	hValsReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	IncrStub        func(context.Context, string) *redisa.IntCmd
	incrMutex       sync.RWMutex
	incrArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	incrReturns struct {
		result1 *redisa.IntCmd
	}
	incrReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	IncrByStub        func(context.Context, string, int64) *redisa.IntCmd
	incrByMutex       sync.RWMutex
	incrByArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}
	incrByReturns struct {
		result1 *redisa.IntCmd
	}
	incrByReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	IncrByFloatStub        func(context.Context, string, float64) *redisa.FloatCmd
	incrByFloatMutex       sync.RWMutex
	incrByFloatArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 float64
	}
	incrByFloatReturns struct {
		result1 *redisa.FloatCmd
	}
	incrByFloatReturnsOnCall map[int]struct {
		result1 *redisa.FloatCmd
	}
	InfoStub        func(context.Context, ...string) *redisa.StringCmd
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	infoReturns struct {
		result1 *redisa.StringCmd
	}
	infoReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	JSONArrAppendStub        func(context.Context, string, string, ...interface{}) *redisa.IntSliceCmd
	jSONArrAppendMutex       sync.RWMutex
	jSONArrAppendArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []interface{}
	}
	jSONArrAppendReturns struct {
		result1 *redisa.IntSliceCmd
	}
	jSONArrAppendReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	JSONArrIndexStub        func(context.Context, string, string, ...interface{}) *redisa.IntSliceCmd
	jSONArrIndexMutex       sync.RWMutex
	jSONArrIndexArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []interface{}
	}
	jSONArrIndexReturns struct {
		result1 *redisa.IntSliceCmd
	}
	jSONArrIndexReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	JSONArrIndexWithArgsStub        func(context.Context, string, string, *redisa.JSONArrIndexArgs, ...interface{}) *redisa.IntSliceCmd
	jSONArrIndexWithArgsMutex       sync.RWMutex
	jSONArrIndexWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.JSONArrIndexArgs
		arg5 []interface{}
	}
	jSONArrIndexWithArgsReturns struct {
		result1 *redisa.IntSliceCmd
	}
	jSONArrIndexWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	JSONArrInsertStub        func(context.Context, string, string, int64, ...interface{}) *redisa.IntSliceCmd
	jSONArrInsertMutex       sync.RWMutex
	jSONArrInsertArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 []interface{}
	}
	jSONArrInsertReturns struct {
		result1 *redisa.IntSliceCmd
	}
	jSONArrInsertReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	JSONArrLenStub        func(context.Context, string, string) *redisa.IntSliceCmd
	jSONArrLenMutex       sync.RWMutex
	jSONArrLenArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	jSONArrLenReturns struct {
		result1 *redisa.IntSliceCmd
	}
	jSONArrLenReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	JSONArrPopStub        func(context.Context, string, string, int) *redisa.StringSliceCmd
	jSONArrPopMutex       sync.RWMutex
	jSONArrPopArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	jSONArrPopReturns struct {
		result1 *redisa.StringSliceCmd
	}
	jSONArrPopReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	JSONArrTrimStub        func(context.Context, string, string) *redisa.IntSliceCmd
	jSONArrTrimMutex       sync.RWMutex
	jSONArrTrimArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	jSONArrTrimReturns struct {
		result1 *redisa.IntSliceCmd
	}
	jSONArrTrimReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	JSONArrTrimWithArgsStub        func(context.Context, string, string, *redisa.JSONArrTrimArgs) *redisa.IntSliceCmd
	jSONArrTrimWithArgsMutex       sync.RWMutex
	jSONArrTrimWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.JSONArrTrimArgs
	}
	jSONArrTrimWithArgsReturns struct {
		result1 *redisa.IntSliceCmd
	}
	jSONArrTrimWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	JSONClearStub        func(context.Context, string, string) *redisa.IntCmd
	jSONClearMutex       sync.RWMutex
	jSONClearArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	jSONClearReturns struct {
		result1 *redisa.IntCmd
	}
	jSONClearReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	JSONDebugMemoryStub        func(context.Context, string, string) *redisa.IntCmd
	jSONDebugMemoryMutex       sync.RWMutex
	jSONDebugMemoryArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	jSONDebugMemoryReturns struct {
		result1 *redisa.IntCmd
	}
	jSONDebugMemoryReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	JSONDelStub        func(context.Context, string, string) *redisa.IntCmd
	jSONDelMutex       sync.RWMutex
	jSONDelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	jSONDelReturns struct {
		result1 *redisa.IntCmd
	}
	jSONDelReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	JSONForgetStub        func(context.Context, string, string) *redisa.IntCmd
	jSONForgetMutex       sync.RWMutex
	jSONForgetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	jSONForgetReturns struct {
		result1 *redisa.IntCmd
	}
	jSONForgetReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	JSONGetStub        func(context.Context, string, ...string) *redisa.JSONCmd
	jSONGetMutex       sync.RWMutex
	jSONGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	jSONGetReturns struct {
		result1 *redisa.JSONCmd
	}
	jSONGetReturnsOnCall map[int]struct {
		result1 *redisa.JSONCmd
	}
	JSONGetWithArgsStub        func(context.Context, string, *redisa.JSONGetArgs, ...string) *redisa.JSONCmd
	jSONGetWithArgsMutex       sync.RWMutex
	jSONGetWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.JSONGetArgs
		arg4 []string
	}
	jSONGetWithArgsReturns struct {
		result1 *redisa.JSONCmd
	}
	jSONGetWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.JSONCmd
	}
	JSONMGetStub        func(context.Context, string, ...string) *redisa.JSONSliceCmd
	jSONMGetMutex       sync.RWMutex
	jSONMGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	jSONMGetReturns struct {
		result1 *redisa.JSONSliceCmd
	}
	jSONMGetReturnsOnCall map[int]struct {
		result1 *redisa.JSONSliceCmd
	}
	JSONMSetStub        func(context.Context, ...interface{}) *redisa.StatusCmd
	jSONMSetMutex       sync.RWMutex
	jSONMSetArgsForCall []struct {
		arg1 context.Context
		arg2 []interface{}
	}
	jSONMSetReturns struct {
		result1 *redisa.StatusCmd
	}
	jSONMSetReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	JSONMSetArgsStub        func(context.Context, []redisa.JSONSetArgs) *redisa.StatusCmd
	jSONMSetArgsMutex       sync.RWMutex
	jSONMSetArgsArgsForCall []struct {
		arg1 context.Context
		arg2 []redisa.JSONSetArgs
	}
	jSONMSetArgsReturns struct {
		result1 *redisa.StatusCmd
	}
	jSONMSetArgsReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	JSONMergeStub        func(context.Context, string, string, string) *redisa.StatusCmd
	jSONMergeMutex       sync.RWMutex
	jSONMergeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	jSONMergeReturns struct {
		result1 *redisa.StatusCmd
	}
	jSONMergeReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	JSONNumIncrByStub        func(context.Context, string, string, float64) *redisa.JSONCmd
	jSONNumIncrByMutex       sync.RWMutex
	jSONNumIncrByArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 float64
	}
	jSONNumIncrByReturns struct {
		result1 *redisa.JSONCmd
	}
	jSONNumIncrByReturnsOnCall map[int]struct {
		result1 *redisa.JSONCmd
	}
	JSONObjKeysStub        func(context.Context, string, string) *redisa.SliceCmd
	jSONObjKeysMutex       sync.RWMutex
	jSONObjKeysArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	jSONObjKeysReturns struct {
		result1 *redisa.SliceCmd
	}
	jSONObjKeysReturnsOnCall map[int]struct {
		result1 *redisa.SliceCmd
	}
	JSONObjLenStub        func(context.Context, string, string) *redisa.IntPointerSliceCmd
	jSONObjLenMutex       sync.RWMutex
	jSONObjLenArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	jSONObjLenReturns struct {
		result1 *redisa.IntPointerSliceCmd
	}
	jSONObjLenReturnsOnCall map[int]struct {
		result1 *redisa.IntPointerSliceCmd
	}
	JSONSetStub        func(context.Context, string, string, interface{}) *redisa.StatusCmd
	jSONSetMutex       sync.RWMutex
	jSONSetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 interface{}
	}
	jSONSetReturns struct {
		result1 *redisa.StatusCmd
	}
	jSONSetReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	JSONSetModeStub        func(context.Context, string, string, interface{}, string) *redisa.StatusCmd
	jSONSetModeMutex       sync.RWMutex
	jSONSetModeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 interface{}
		arg5 string
	}
	jSONSetModeReturns struct {
		result1 *redisa.StatusCmd
	}
	jSONSetModeReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	JSONStrAppendStub        func(context.Context, string, string, string) *redisa.IntPointerSliceCmd
	jSONStrAppendMutex       sync.RWMutex
	jSONStrAppendArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	jSONStrAppendReturns struct {
		result1 *redisa.IntPointerSliceCmd
	}
	jSONStrAppendReturnsOnCall map[int]struct {
		result1 *redisa.IntPointerSliceCmd
	}
	JSONStrLenStub        func(context.Context, string, string) *redisa.IntPointerSliceCmd
	jSONStrLenMutex       sync.RWMutex
	jSONStrLenArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	jSONStrLenReturns struct {
		result1 *redisa.IntPointerSliceCmd
	}
	jSONStrLenReturnsOnCall map[int]struct {
		result1 *redisa.IntPointerSliceCmd
	}
	JSONToggleStub        func(context.Context, string, string) *redisa.IntPointerSliceCmd
	jSONToggleMutex       sync.RWMutex
	jSONToggleArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	jSONToggleReturns struct {
		result1 *redisa.IntPointerSliceCmd
	}
	jSONToggleReturnsOnCall map[int]struct {
		result1 *redisa.IntPointerSliceCmd
	}
	JSONTypeStub        func(context.Context, string, string) *redisa.JSONSliceCmd
	jSONTypeMutex       sync.RWMutex
	jSONTypeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	jSONTypeReturns struct {
		result1 *redisa.JSONSliceCmd
	}
	jSONTypeReturnsOnCall map[int]struct {
		result1 *redisa.JSONSliceCmd
	}
	KeysStub        func(context.Context, string) *redisa.StringSliceCmd
	keysMutex       sync.RWMutex
	keysArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	keysReturns struct {
		result1 *redisa.StringSliceCmd
	}
	keysReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	LCSStub        func(context.Context, *redisa.LCSQuery) *redisa.LCSCmd
	lCSMutex       sync.RWMutex
	lCSArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.LCSQuery
	}
	lCSReturns struct {
		result1 *redisa.LCSCmd
	}
	lCSReturnsOnCall map[int]struct {
		result1 *redisa.LCSCmd
	}
	LIndexStub        func(context.Context, string, int64) *redisa.StringCmd
	lIndexMutex       sync.RWMutex
	lIndexArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}
	lIndexReturns struct {
		result1 *redisa.StringCmd
	}
	lIndexReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	LInsertStub        func(context.Context, string, string, interface{}, interface{}) *redisa.IntCmd
	lInsertMutex       sync.RWMutex
	lInsertArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 interface{}
		arg5 interface{}
	}
	lInsertReturns struct {
		result1 *redisa.IntCmd
	}
	lInsertReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	LInsertAfterStub        func(context.Context, string, interface{}, interface{}) *redisa.IntCmd
	lInsertAfterMutex       sync.RWMutex
	lInsertAfterArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 interface{}
	}
	lInsertAfterReturns struct {
		result1 *redisa.IntCmd
	}
	lInsertAfterReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	LInsertBeforeStub        func(context.Context, string, interface{}, interface{}) *redisa.IntCmd
	lInsertBeforeMutex       sync.RWMutex
	lInsertBeforeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 interface{}
	}
	lInsertBeforeReturns struct {
		result1 *redisa.IntCmd
	}
	lInsertBeforeReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	LLenStub        func(context.Context, string) *redisa.IntCmd
	lLenMutex       sync.RWMutex
	lLenArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	lLenReturns struct {
		result1 *redisa.IntCmd
	}
	lLenReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	LMPopStub        func(context.Context, string, int64, ...string) *redisa.KeyValuesCmd
	lMPopMutex       sync.RWMutex
	lMPopArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 []string
	}
	lMPopReturns struct {
		result1 *redisa.KeyValuesCmd
	}
	lMPopReturnsOnCall map[int]struct {
		result1 *redisa.KeyValuesCmd
	}
	LMoveStub        func(context.Context, string, string, string, string) *redisa.StringCmd
	lMoveMutex       sync.RWMutex
	lMoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	lMoveReturns struct {
		result1 *redisa.StringCmd
	}
	lMoveReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	LPopStub        func(context.Context, string) *redisa.StringCmd
	lPopMutex       sync.RWMutex
	lPopArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	lPopReturns struct {
		result1 *redisa.StringCmd
	}
	lPopReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	LPopCountStub        func(context.Context, string, int) *redisa.StringSliceCmd
	lPopCountMutex       sync.RWMutex
	lPopCountArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}
	lPopCountReturns struct {
		result1 *redisa.StringSliceCmd
	}
	lPopCountReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	LPosStub        func(context.Context, string, string, redisa.LPosArgs) *redisa.IntCmd
	lPosMutex       sync.RWMutex
	lPosArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 redisa.LPosArgs
	}
	lPosReturns struct {
		result1 *redisa.IntCmd
	}
	lPosReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	LPosCountStub        func(context.Context, string, string, int64, redisa.LPosArgs) *redisa.IntSliceCmd
	lPosCountMutex       sync.RWMutex
	lPosCountArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 redisa.LPosArgs
	}
	lPosCountReturns struct {
		result1 *redisa.IntSliceCmd
	}
	lPosCountReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	LPushStub        func(context.Context, string, ...interface{}) *redisa.IntCmd
	lPushMutex       sync.RWMutex
	lPushArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	lPushReturns struct {
		result1 *redisa.IntCmd
	}
	lPushReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	LPushXStub        func(context.Context, string, ...interface{}) *redisa.IntCmd
	lPushXMutex       sync.RWMutex
	lPushXArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	lPushXReturns struct {
		result1 *redisa.IntCmd
	}
	lPushXReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	LRangeStub        func(context.Context, string, int64, int64) *redisa.StringSliceCmd
	lRangeMutex       sync.RWMutex
	lRangeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	lRangeReturns struct {
		result1 *redisa.StringSliceCmd
	}
	lRangeReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	LRemStub        func(context.Context, string, int64, interface{}) *redisa.IntCmd
	lRemMutex       sync.RWMutex
	lRemArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 interface{}
	}
	lRemReturns struct {
		result1 *redisa.IntCmd
	}
	lRemReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	LSetStub        func(context.Context, string, int64, interface{}) *redisa.StatusCmd
	lSetMutex       sync.RWMutex
	lSetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 interface{}
	}
	lSetReturns struct {
		result1 *redisa.StatusCmd
	}
	lSetReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	LTrimStub        func(context.Context, string, int64, int64) *redisa.StatusCmd
	lTrimMutex       sync.RWMutex
	lTrimArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	lTrimReturns struct {
		result1 *redisa.StatusCmd
	}
	lTrimReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	LastSaveStub        func(context.Context) *redisa.IntCmd
	lastSaveMutex       sync.RWMutex
	lastSaveArgsForCall []struct {
		arg1 context.Context
	}
	lastSaveReturns struct {
		result1 *redisa.IntCmd
	}
	lastSaveReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	MGetStub        func(context.Context, ...string) *redisa.SliceCmd
	mGetMutex       sync.RWMutex
	mGetArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	mGetReturns struct {
		result1 *redisa.SliceCmd
	}
	mGetReturnsOnCall map[int]struct {
		result1 *redisa.SliceCmd
	}
	MSetStub        func(context.Context, ...interface{}) *redisa.StatusCmd
	mSetMutex       sync.RWMutex
	mSetArgsForCall []struct {
		arg1 context.Context
		arg2 []interface{}
	}
	mSetReturns struct {
		result1 *redisa.StatusCmd
	}
	mSetReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	MSetNXStub        func(context.Context, ...interface{}) *redisa.BoolCmd
	mSetNXMutex       sync.RWMutex
	mSetNXArgsForCall []struct {
		arg1 context.Context
		arg2 []interface{}
	}
	mSetNXReturns struct {
		result1 *redisa.BoolCmd
	}
	mSetNXReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	MemoryUsageStub        func(context.Context, string, ...int) *redisa.IntCmd
	memoryUsageMutex       sync.RWMutex
	memoryUsageArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []int
	}
	memoryUsageReturns struct {
		result1 *redisa.IntCmd
	}
	memoryUsageReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	MigrateStub        func(context.Context, string, string, string, int, time.Duration) *redisa.StatusCmd
	migrateMutex       sync.RWMutex
	migrateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 int
		arg6 time.Duration
	}
	migrateReturns struct {
		result1 *redisa.StatusCmd
	}
	migrateReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ModuleLoadexStub        func(context.Context, *redisa.ModuleLoadexConfig) *redisa.StringCmd
	moduleLoadexMutex       sync.RWMutex
	moduleLoadexArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.ModuleLoadexConfig
	}
	moduleLoadexReturns struct {
		result1 *redisa.StringCmd
	}
	moduleLoadexReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	MoveStub        func(context.Context, string, int) *redisa.BoolCmd
	moveMutex       sync.RWMutex
	moveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}
	moveReturns struct {
		result1 *redisa.BoolCmd
	}
	moveReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	ObjectEncodingStub        func(context.Context, string) *redisa.StringCmd
	objectEncodingMutex       sync.RWMutex
	objectEncodingArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	objectEncodingReturns struct {
		result1 *redisa.StringCmd
	}
	objectEncodingReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	ObjectFreqStub        func(context.Context, string) *redisa.IntCmd
	objectFreqMutex       sync.RWMutex
	objectFreqArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	objectFreqReturns struct {
		result1 *redisa.IntCmd
	}
	objectFreqReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ObjectIdleTimeStub        func(context.Context, string) *redisa.DurationCmd
	objectIdleTimeMutex       sync.RWMutex
	objectIdleTimeArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	objectIdleTimeReturns struct {
		result1 *redisa.DurationCmd
	}
	objectIdleTimeReturnsOnCall map[int]struct {
		result1 *redisa.DurationCmd
	}
	ObjectRefCountStub        func(context.Context, string) *redisa.IntCmd
	objectRefCountMutex       sync.RWMutex
	objectRefCountArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	objectRefCountReturns struct {
		result1 *redisa.IntCmd
	}
	objectRefCountReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	PExpireStub        func(context.Context, string, time.Duration) *redisa.BoolCmd
	pExpireMutex       sync.RWMutex
	pExpireArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}
	pExpireReturns struct {
		result1 *redisa.BoolCmd
	}
	pExpireReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	PExpireAtStub        func(context.Context, string, time.Time) *redisa.BoolCmd
	pExpireAtMutex       sync.RWMutex
	pExpireAtArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Time
	}
	pExpireAtReturns struct {
		result1 *redisa.BoolCmd
	}
	pExpireAtReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	PExpireTimeStub        func(context.Context, string) *redisa.DurationCmd
	pExpireTimeMutex       sync.RWMutex
	pExpireTimeArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	pExpireTimeReturns struct {
		result1 *redisa.DurationCmd
	}
	pExpireTimeReturnsOnCall map[int]struct {
		result1 *redisa.DurationCmd
	}
	PFAddStub        func(context.Context, string, ...interface{}) *redisa.IntCmd
	pFAddMutex       sync.RWMutex
	pFAddArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	pFAddReturns struct {
		result1 *redisa.IntCmd
	}
	pFAddReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	PFCountStub        func(context.Context, ...string) *redisa.IntCmd
	pFCountMutex       sync.RWMutex
	pFCountArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	pFCountReturns struct {
		result1 *redisa.IntCmd
	}
	pFCountReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	PFMergeStub        func(context.Context, string, ...string) *redisa.StatusCmd
	pFMergeMutex       sync.RWMutex
	pFMergeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	pFMergeReturns struct {
		result1 *redisa.StatusCmd
	}
	pFMergeReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	PTTLStub        func(context.Context, string) *redisa.DurationCmd
	pTTLMutex       sync.RWMutex
	pTTLArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	pTTLReturns struct {
		result1 *redisa.DurationCmd
	}
	pTTLReturnsOnCall map[int]struct {
		result1 *redisa.DurationCmd
	}
	PersistStub        func(context.Context, string) *redisa.BoolCmd
	persistMutex       sync.RWMutex
	persistArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	persistReturns struct {
		result1 *redisa.BoolCmd
	}
	persistReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	PingStub        func(context.Context) *redisa.StatusCmd
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
		arg1 context.Context
	}
	pingReturns struct {
		result1 *redisa.StatusCmd
	}
	pingReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	PipelineStub        func() redisa.Pipeliner
	pipelineMutex       sync.RWMutex
	pipelineArgsForCall []struct {
	}
	pipelineReturns struct {
		result1 redisa.Pipeliner
	}
	pipelineReturnsOnCall map[int]struct {
		result1 redisa.Pipeliner
	}
	PipelinedStub        func(context.Context, func(redisa.Pipeliner) error) ([]redisa.Cmder, error)
	pipelinedMutex       sync.RWMutex
	pipelinedArgsForCall []struct {
		arg1 context.Context
		arg2 func(redisa.Pipeliner) error
	}
	pipelinedReturns struct {
		result1 []redisa.Cmder
		result2 error
	}
	pipelinedReturnsOnCall map[int]struct {
		result1 []redisa.Cmder
		result2 error
	}
	PubSubChannelsStub        func(context.Context, string) *redisa.StringSliceCmd
	pubSubChannelsMutex       sync.RWMutex
	pubSubChannelsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	pubSubChannelsReturns struct {
		result1 *redisa.StringSliceCmd
	}
	pubSubChannelsReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	PubSubNumPatStub        func(context.Context) *redisa.IntCmd
	pubSubNumPatMutex       sync.RWMutex
	pubSubNumPatArgsForCall []struct {
		arg1 context.Context
	}
	pubSubNumPatReturns struct {
		result1 *redisa.IntCmd
	}
	pubSubNumPatReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	PubSubNumSubStub        func(context.Context, ...string) *redisa.MapStringIntCmd
	pubSubNumSubMutex       sync.RWMutex
	pubSubNumSubArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	pubSubNumSubReturns struct {
		result1 *redisa.MapStringIntCmd
	}
	pubSubNumSubReturnsOnCall map[int]struct {
		result1 *redisa.MapStringIntCmd
	}
	PubSubShardChannelsStub        func(context.Context, string) *redisa.StringSliceCmd
	pubSubShardChannelsMutex       sync.RWMutex
	pubSubShardChannelsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	pubSubShardChannelsReturns struct {
		result1 *redisa.StringSliceCmd
	}
	pubSubShardChannelsReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	PubSubShardNumSubStub        func(context.Context, ...string) *redisa.MapStringIntCmd
	pubSubShardNumSubMutex       sync.RWMutex
	pubSubShardNumSubArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	pubSubShardNumSubReturns struct {
		result1 *redisa.MapStringIntCmd
	}
	pubSubShardNumSubReturnsOnCall map[int]struct {
		result1 *redisa.MapStringIntCmd
	}
	PublishStub        func(context.Context, string, interface{}) *redisa.IntCmd
	publishMutex       sync.RWMutex
	publishArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}
	publishReturns struct {
		result1 *redisa.IntCmd
	}
	publishReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	QuitStub        func(context.Context) *redisa.StatusCmd
	quitMutex       sync.RWMutex
	quitArgsForCall []struct {
		arg1 context.Context
	}
	quitReturns struct {
		result1 *redisa.StatusCmd
	}
	quitReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	RPopStub        func(context.Context, string) *redisa.StringCmd
	rPopMutex       sync.RWMutex
	rPopArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	rPopReturns struct {
		result1 *redisa.StringCmd
	}
	rPopReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	RPopCountStub        func(context.Context, string, int) *redisa.StringSliceCmd
	rPopCountMutex       sync.RWMutex
	rPopCountArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}
	rPopCountReturns struct {
		result1 *redisa.StringSliceCmd
	}
	rPopCountReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	RPopLPushStub        func(context.Context, string, string) *redisa.StringCmd
	rPopLPushMutex       sync.RWMutex
	rPopLPushArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	rPopLPushReturns struct {
		result1 *redisa.StringCmd
	}
	rPopLPushReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	RPushStub        func(context.Context, string, ...interface{}) *redisa.IntCmd
	rPushMutex       sync.RWMutex
	rPushArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	rPushReturns struct {
		result1 *redisa.IntCmd
	}
	rPushReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	RPushXStub        func(context.Context, string, ...interface{}) *redisa.IntCmd
	rPushXMutex       sync.RWMutex
	rPushXArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	rPushXReturns struct {
		result1 *redisa.IntCmd
	}
	rPushXReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	RandomKeyStub        func(context.Context) *redisa.StringCmd
	randomKeyMutex       sync.RWMutex
	randomKeyArgsForCall []struct {
		arg1 context.Context
	}
	randomKeyReturns struct {
		result1 *redisa.StringCmd
	}
	randomKeyReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	ReadOnlyStub        func(context.Context) *redisa.StatusCmd
	readOnlyMutex       sync.RWMutex
	readOnlyArgsForCall []struct {
		arg1 context.Context
	}
	readOnlyReturns struct {
		result1 *redisa.StatusCmd
	}
	readOnlyReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ReadWriteStub        func(context.Context) *redisa.StatusCmd
	readWriteMutex       sync.RWMutex
	readWriteArgsForCall []struct {
		arg1 context.Context
	}
	readWriteReturns struct {
		result1 *redisa.StatusCmd
	}
	readWriteReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	RenameStub        func(context.Context, string, string) *redisa.StatusCmd
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	renameReturns struct {
		result1 *redisa.StatusCmd
	}
	renameReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	RenameNXStub        func(context.Context, string, string) *redisa.BoolCmd
	renameNXMutex       sync.RWMutex
	renameNXArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	renameNXReturns struct {
		result1 *redisa.BoolCmd
	}
	renameNXReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	RestoreStub        func(context.Context, string, time.Duration, string) *redisa.StatusCmd
	restoreMutex       sync.RWMutex
	restoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
		arg4 string
	}
	restoreReturns struct {
		result1 *redisa.StatusCmd
	}
	restoreReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	RestoreReplaceStub        func(context.Context, string, time.Duration, string) *redisa.StatusCmd
	restoreReplaceMutex       sync.RWMutex
	restoreReplaceArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
		arg4 string
	}
	restoreReplaceReturns struct {
		result1 *redisa.StatusCmd
	}
	restoreReplaceReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	SAddStub        func(context.Context, string, ...interface{}) *redisa.IntCmd
	sAddMutex       sync.RWMutex
	sAddArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	sAddReturns struct {
		result1 *redisa.IntCmd
	}
	sAddReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	SCardStub        func(context.Context, string) *redisa.IntCmd
	sCardMutex       sync.RWMutex
	sCardArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	sCardReturns struct {
		result1 *redisa.IntCmd
	}
	sCardReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	SDiffStub        func(context.Context, ...string) *redisa.StringSliceCmd
	sDiffMutex       sync.RWMutex
	sDiffArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	sDiffReturns struct {
		result1 *redisa.StringSliceCmd
	}
	sDiffReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	SDiffStoreStub        func(context.Context, string, ...string) *redisa.IntCmd
	sDiffStoreMutex       sync.RWMutex
	sDiffStoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	sDiffStoreReturns struct {
		result1 *redisa.IntCmd
	}
	sDiffStoreReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	SInterStub        func(context.Context, ...string) *redisa.StringSliceCmd
	sInterMutex       sync.RWMutex
	sInterArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	sInterReturns struct {
		result1 *redisa.StringSliceCmd
	}
	sInterReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	SInterCardStub        func(context.Context, int64, ...string) *redisa.IntCmd
	sInterCardMutex       sync.RWMutex
	sInterCardArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 []string
	}
	sInterCardReturns struct {
		result1 *redisa.IntCmd
	}
	sInterCardReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	SInterStoreStub        func(context.Context, string, ...string) *redisa.IntCmd
	sInterStoreMutex       sync.RWMutex
	sInterStoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	sInterStoreReturns struct {
		result1 *redisa.IntCmd
	}
	sInterStoreReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	SIsMemberStub        func(context.Context, string, interface{}) *redisa.BoolCmd
	sIsMemberMutex       sync.RWMutex
	sIsMemberArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}
	sIsMemberReturns struct {
		result1 *redisa.BoolCmd
	}
	sIsMemberReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	SMIsMemberStub        func(context.Context, string, ...interface{}) *redisa.BoolSliceCmd
	sMIsMemberMutex       sync.RWMutex
	sMIsMemberArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	sMIsMemberReturns struct {
		result1 *redisa.BoolSliceCmd
	}
	sMIsMemberReturnsOnCall map[int]struct {
		result1 *redisa.BoolSliceCmd
	}
	SMembersStub        func(context.Context, string) *redisa.StringSliceCmd
	sMembersMutex       sync.RWMutex
	sMembersArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	sMembersReturns struct {
		result1 *redisa.StringSliceCmd
	}
	sMembersReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	SMembersMapStub        func(context.Context, string) *redisa.StringStructMapCmd
	sMembersMapMutex       sync.RWMutex
	sMembersMapArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	sMembersMapReturns struct {
		result1 *redisa.StringStructMapCmd
	}
	sMembersMapReturnsOnCall map[int]struct {
		result1 *redisa.StringStructMapCmd
	}
	SMoveStub        func(context.Context, string, string, interface{}) *redisa.BoolCmd
	sMoveMutex       sync.RWMutex
	sMoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 interface{}
	}
	sMoveReturns struct {
		result1 *redisa.BoolCmd
	}
	sMoveReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	SPopStub        func(context.Context, string) *redisa.StringCmd
	sPopMutex       sync.RWMutex
	sPopArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	sPopReturns struct {
		result1 *redisa.StringCmd
	}
	sPopReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	SPopNStub        func(context.Context, string, int64) *redisa.StringSliceCmd
	sPopNMutex       sync.RWMutex
	sPopNArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}
	sPopNReturns struct {
		result1 *redisa.StringSliceCmd
	}
	sPopNReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	SPublishStub        func(context.Context, string, interface{}) *redisa.IntCmd
	sPublishMutex       sync.RWMutex
	sPublishArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}
	sPublishReturns struct {
		result1 *redisa.IntCmd
	}
	sPublishReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	SRandMemberStub        func(context.Context, string) *redisa.StringCmd
	sRandMemberMutex       sync.RWMutex
	sRandMemberArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	sRandMemberReturns struct {
		result1 *redisa.StringCmd
	}
	sRandMemberReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	SRandMemberNStub        func(context.Context, string, int64) *redisa.StringSliceCmd
	sRandMemberNMutex       sync.RWMutex
	sRandMemberNArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}
	sRandMemberNReturns struct {
		result1 *redisa.StringSliceCmd
	}
	sRandMemberNReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	SRemStub        func(context.Context, string, ...interface{}) *redisa.IntCmd
	sRemMutex       sync.RWMutex
	sRemArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	sRemReturns struct {
		result1 *redisa.IntCmd
	}
	sRemReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	SScanStub        func(context.Context, string, uint64, string, int64) *redisa.ScanCmd
	sScanMutex       sync.RWMutex
	sScanArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 uint64
		arg4 string
		arg5 int64
	}
	sScanReturns struct {
		result1 *redisa.ScanCmd
	}
	sScanReturnsOnCall map[int]struct {
		result1 *redisa.ScanCmd
	}
	SUnionStub        func(context.Context, ...string) *redisa.StringSliceCmd
	sUnionMutex       sync.RWMutex
	sUnionArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	sUnionReturns struct {
		result1 *redisa.StringSliceCmd
	}
	sUnionReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	SUnionStoreStub        func(context.Context, string, ...string) *redisa.IntCmd
	sUnionStoreMutex       sync.RWMutex
	sUnionStoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	sUnionStoreReturns struct {
		result1 *redisa.IntCmd
	}
	sUnionStoreReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	SaveStub        func(context.Context) *redisa.StatusCmd
	saveMutex       sync.RWMutex
	saveArgsForCall []struct {
		arg1 context.Context
	}
	saveReturns struct {
		result1 *redisa.StatusCmd
	}
	saveReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ScanStub        func(context.Context, uint64, string, int64) *redisa.ScanCmd
	scanMutex       sync.RWMutex
	scanArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
		arg3 string
		arg4 int64
	}
	scanReturns struct {
		result1 *redisa.ScanCmd
	}
	scanReturnsOnCall map[int]struct {
		result1 *redisa.ScanCmd
	}
	ScanTypeStub        func(context.Context, uint64, string, int64, string) *redisa.ScanCmd
	scanTypeMutex       sync.RWMutex
	scanTypeArgsForCall []struct {
		arg1 context.Context
		arg2 uint64
		arg3 string
		arg4 int64
		arg5 string
	}
	scanTypeReturns struct {
		result1 *redisa.ScanCmd
	}
	scanTypeReturnsOnCall map[int]struct {
		result1 *redisa.ScanCmd
	}
	ScriptExistsStub        func(context.Context, ...string) *redisa.BoolSliceCmd
	scriptExistsMutex       sync.RWMutex
	scriptExistsArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	scriptExistsReturns struct {
		result1 *redisa.BoolSliceCmd
	}
	scriptExistsReturnsOnCall map[int]struct {
		result1 *redisa.BoolSliceCmd
	}
	ScriptFlushStub        func(context.Context) *redisa.StatusCmd
	scriptFlushMutex       sync.RWMutex
	scriptFlushArgsForCall []struct {
		arg1 context.Context
	}
	scriptFlushReturns struct {
		result1 *redisa.StatusCmd
	}
	scriptFlushReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ScriptKillStub        func(context.Context) *redisa.StatusCmd
	scriptKillMutex       sync.RWMutex
	scriptKillArgsForCall []struct {
		arg1 context.Context
	}
	scriptKillReturns struct {
		result1 *redisa.StatusCmd
	}
	scriptKillReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ScriptLoadStub        func(context.Context, string) *redisa.StringCmd
	scriptLoadMutex       sync.RWMutex
	scriptLoadArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	scriptLoadReturns struct {
		result1 *redisa.StringCmd
	}
	scriptLoadReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	SetStub        func(context.Context, string, interface{}, time.Duration) *redisa.StatusCmd
	setMutex       sync.RWMutex
	setArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 time.Duration
	}
	setReturns struct {
		result1 *redisa.StatusCmd
	}
	setReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	SetArgsStub        func(context.Context, string, interface{}, redisa.SetArgs) *redisa.StatusCmd
	setArgsMutex       sync.RWMutex
	setArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 redisa.SetArgs
	}
	setArgsReturns struct {
		result1 *redisa.StatusCmd
	}
	setArgsReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	SetBitStub        func(context.Context, string, int64, int) *redisa.IntCmd
	setBitMutex       sync.RWMutex
	setBitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int
	}
	setBitReturns struct {
		result1 *redisa.IntCmd
	}
	setBitReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	SetExStub        func(context.Context, string, interface{}, time.Duration) *redisa.StatusCmd
	setExMutex       sync.RWMutex
	setExArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 time.Duration
	}
	setExReturns struct {
		result1 *redisa.StatusCmd
	}
	setExReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	SetNXStub        func(context.Context, string, interface{}, time.Duration) *redisa.BoolCmd
	setNXMutex       sync.RWMutex
	setNXArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 time.Duration
	}
	setNXReturns struct {
		result1 *redisa.BoolCmd
	}
	setNXReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	SetRangeStub        func(context.Context, string, int64, string) *redisa.IntCmd
	setRangeMutex       sync.RWMutex
	setRangeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 string
	}
	setRangeReturns struct {
		result1 *redisa.IntCmd
	}
	setRangeReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	SetXXStub        func(context.Context, string, interface{}, time.Duration) *redisa.BoolCmd
	setXXMutex       sync.RWMutex
	setXXArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 time.Duration
	}
	setXXReturns struct {
		result1 *redisa.BoolCmd
	}
	setXXReturnsOnCall map[int]struct {
		result1 *redisa.BoolCmd
	}
	ShutdownStub        func(context.Context) *redisa.StatusCmd
	shutdownMutex       sync.RWMutex
	shutdownArgsForCall []struct {
		arg1 context.Context
	}
	shutdownReturns struct {
		result1 *redisa.StatusCmd
	}
	shutdownReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ShutdownNoSaveStub        func(context.Context) *redisa.StatusCmd
	shutdownNoSaveMutex       sync.RWMutex
	shutdownNoSaveArgsForCall []struct {
		arg1 context.Context
	}
	shutdownNoSaveReturns struct {
		result1 *redisa.StatusCmd
	}
	shutdownNoSaveReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	ShutdownSaveStub        func(context.Context) *redisa.StatusCmd
	shutdownSaveMutex       sync.RWMutex
	shutdownSaveArgsForCall []struct {
		arg1 context.Context
	}
	shutdownSaveReturns struct {
		result1 *redisa.StatusCmd
	}
	shutdownSaveReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	SlaveOfStub        func(context.Context, string, string) *redisa.StatusCmd
	slaveOfMutex       sync.RWMutex
	slaveOfArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	slaveOfReturns struct {
		result1 *redisa.StatusCmd
	}
	slaveOfReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	SlowLogGetStub        func(context.Context, int64) *redisa.SlowLogCmd
	slowLogGetMutex       sync.RWMutex
	slowLogGetArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	slowLogGetReturns struct {
		result1 *redisa.SlowLogCmd
	}
	slowLogGetReturnsOnCall map[int]struct {
		result1 *redisa.SlowLogCmd
	}
	SortStub        func(context.Context, string, *redisa.Sort) *redisa.StringSliceCmd
	sortMutex       sync.RWMutex
	sortArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.Sort
	}
	sortReturns struct {
		result1 *redisa.StringSliceCmd
	}
	sortReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	SortInterfacesStub        func(context.Context, string, *redisa.Sort) *redisa.SliceCmd
	sortInterfacesMutex       sync.RWMutex
	sortInterfacesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.Sort
	}
	sortInterfacesReturns struct {
		result1 *redisa.SliceCmd
	}
	sortInterfacesReturnsOnCall map[int]struct {
		result1 *redisa.SliceCmd
	}
	SortROStub        func(context.Context, string, *redisa.Sort) *redisa.StringSliceCmd
	sortROMutex       sync.RWMutex
	sortROArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.Sort
	}
	sortROReturns struct {
		result1 *redisa.StringSliceCmd
	}
	sortROReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	SortStoreStub        func(context.Context, string, string, *redisa.Sort) *redisa.IntCmd
	sortStoreMutex       sync.RWMutex
	sortStoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.Sort
	}
	sortStoreReturns struct {
		result1 *redisa.IntCmd
	}
	sortStoreReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	StrLenStub        func(context.Context, string) *redisa.IntCmd
	strLenMutex       sync.RWMutex
	strLenArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	strLenReturns struct {
		result1 *redisa.IntCmd
	}
	strLenReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	TDigestAddStub        func(context.Context, string, ...float64) *redisa.StatusCmd
	tDigestAddMutex       sync.RWMutex
	tDigestAddArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []float64
	}
	tDigestAddReturns struct {
		result1 *redisa.StatusCmd
	}
	tDigestAddReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TDigestByRankStub        func(context.Context, string, ...uint64) *redisa.FloatSliceCmd
	tDigestByRankMutex       sync.RWMutex
	tDigestByRankArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []uint64
	}
	tDigestByRankReturns struct {
		result1 *redisa.FloatSliceCmd
	}
	tDigestByRankReturnsOnCall map[int]struct {
		result1 *redisa.FloatSliceCmd
	}
	TDigestByRevRankStub        func(context.Context, string, ...uint64) *redisa.FloatSliceCmd
	tDigestByRevRankMutex       sync.RWMutex
	tDigestByRevRankArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []uint64
	}
	tDigestByRevRankReturns struct {
		result1 *redisa.FloatSliceCmd
	}
	tDigestByRevRankReturnsOnCall map[int]struct {
		result1 *redisa.FloatSliceCmd
	}
	TDigestCDFStub        func(context.Context, string, ...float64) *redisa.FloatSliceCmd
	tDigestCDFMutex       sync.RWMutex
	tDigestCDFArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []float64
	}
	tDigestCDFReturns struct {
		result1 *redisa.FloatSliceCmd
	}
	tDigestCDFReturnsOnCall map[int]struct {
		result1 *redisa.FloatSliceCmd
	}
	TDigestCreateStub        func(context.Context, string) *redisa.StatusCmd
	tDigestCreateMutex       sync.RWMutex
	tDigestCreateArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	tDigestCreateReturns struct {
		result1 *redisa.StatusCmd
	}
	tDigestCreateReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TDigestCreateWithCompressionStub        func(context.Context, string, int64) *redisa.StatusCmd
	tDigestCreateWithCompressionMutex       sync.RWMutex
	tDigestCreateWithCompressionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}
	tDigestCreateWithCompressionReturns struct {
		result1 *redisa.StatusCmd
	}
	tDigestCreateWithCompressionReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TDigestInfoStub        func(context.Context, string) *redisa.TDigestInfoCmd
	tDigestInfoMutex       sync.RWMutex
	tDigestInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	tDigestInfoReturns struct {
		result1 *redisa.TDigestInfoCmd
	}
	tDigestInfoReturnsOnCall map[int]struct {
		result1 *redisa.TDigestInfoCmd
	}
	TDigestMaxStub        func(context.Context, string) *redisa.FloatCmd
	tDigestMaxMutex       sync.RWMutex
	tDigestMaxArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	tDigestMaxReturns struct {
		result1 *redisa.FloatCmd
	}
	tDigestMaxReturnsOnCall map[int]struct {
		result1 *redisa.FloatCmd
	}
	TDigestMergeStub        func(context.Context, string, *redisa.TDigestMergeOptions, ...string) *redisa.StatusCmd
	tDigestMergeMutex       sync.RWMutex
	tDigestMergeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.TDigestMergeOptions
		arg4 []string
	}
	tDigestMergeReturns struct {
		result1 *redisa.StatusCmd
	}
	tDigestMergeReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TDigestMinStub        func(context.Context, string) *redisa.FloatCmd
	tDigestMinMutex       sync.RWMutex
	tDigestMinArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	tDigestMinReturns struct {
		result1 *redisa.FloatCmd
	}
	tDigestMinReturnsOnCall map[int]struct {
		result1 *redisa.FloatCmd
	}
	TDigestQuantileStub        func(context.Context, string, ...float64) *redisa.FloatSliceCmd
	tDigestQuantileMutex       sync.RWMutex
	tDigestQuantileArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []float64
	}
	tDigestQuantileReturns struct {
		result1 *redisa.FloatSliceCmd
	}
	tDigestQuantileReturnsOnCall map[int]struct {
		result1 *redisa.FloatSliceCmd
	}
	TDigestRankStub        func(context.Context, string, ...float64) *redisa.IntSliceCmd
	tDigestRankMutex       sync.RWMutex
	tDigestRankArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []float64
	}
	tDigestRankReturns struct {
		result1 *redisa.IntSliceCmd
	}
	tDigestRankReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	TDigestResetStub        func(context.Context, string) *redisa.StatusCmd
	tDigestResetMutex       sync.RWMutex
	tDigestResetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	tDigestResetReturns struct {
		result1 *redisa.StatusCmd
	}
	tDigestResetReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TDigestRevRankStub        func(context.Context, string, ...float64) *redisa.IntSliceCmd
	tDigestRevRankMutex       sync.RWMutex
	tDigestRevRankArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []float64
	}
	tDigestRevRankReturns struct {
		result1 *redisa.IntSliceCmd
	}
	tDigestRevRankReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	TDigestTrimmedMeanStub        func(context.Context, string, float64, float64) *redisa.FloatCmd
	tDigestTrimmedMeanMutex       sync.RWMutex
	tDigestTrimmedMeanArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 float64
	}
	tDigestTrimmedMeanReturns struct {
		result1 *redisa.FloatCmd
	}
	tDigestTrimmedMeanReturnsOnCall map[int]struct {
		result1 *redisa.FloatCmd
	}
	TFCallStub        func(context.Context, string, string, int) *redisa.Cmd
	tFCallMutex       sync.RWMutex
	tFCallArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	tFCallReturns struct {
		result1 *redisa.Cmd
	}
	tFCallReturnsOnCall map[int]struct {
		result1 *redisa.Cmd
	}
	TFCallASYNCStub        func(context.Context, string, string, int) *redisa.Cmd
	tFCallASYNCMutex       sync.RWMutex
	tFCallASYNCArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	tFCallASYNCReturns struct {
		result1 *redisa.Cmd
	}
	tFCallASYNCReturnsOnCall map[int]struct {
		result1 *redisa.Cmd
	}
	TFCallASYNCArgsStub        func(context.Context, string, string, int, *redisa.TFCallOptions) *redisa.Cmd
	tFCallASYNCArgsMutex       sync.RWMutex
	tFCallASYNCArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *redisa.TFCallOptions
	}
	tFCallASYNCArgsReturns struct {
		result1 *redisa.Cmd
	}
	tFCallASYNCArgsReturnsOnCall map[int]struct {
		result1 *redisa.Cmd
	}
	TFCallArgsStub        func(context.Context, string, string, int, *redisa.TFCallOptions) *redisa.Cmd
	tFCallArgsMutex       sync.RWMutex
	tFCallArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *redisa.TFCallOptions
	}
	tFCallArgsReturns struct {
		result1 *redisa.Cmd
	}
	tFCallArgsReturnsOnCall map[int]struct {
		result1 *redisa.Cmd
	}
	TFunctionDeleteStub        func(context.Context, string) *redisa.StatusCmd
	tFunctionDeleteMutex       sync.RWMutex
	tFunctionDeleteArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	tFunctionDeleteReturns struct {
		result1 *redisa.StatusCmd
	}
	tFunctionDeleteReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TFunctionListStub        func(context.Context) *redisa.MapStringInterfaceSliceCmd
	tFunctionListMutex       sync.RWMutex
	tFunctionListArgsForCall []struct {
		arg1 context.Context
	}
	tFunctionListReturns struct {
		result1 *redisa.MapStringInterfaceSliceCmd
	}
	tFunctionListReturnsOnCall map[int]struct {
		result1 *redisa.MapStringInterfaceSliceCmd
	}
	TFunctionListArgsStub        func(context.Context, *redisa.TFunctionListOptions) *redisa.MapStringInterfaceSliceCmd
	tFunctionListArgsMutex       sync.RWMutex
	tFunctionListArgsArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.TFunctionListOptions
	}
	tFunctionListArgsReturns struct {
		result1 *redisa.MapStringInterfaceSliceCmd
	}
	tFunctionListArgsReturnsOnCall map[int]struct {
		result1 *redisa.MapStringInterfaceSliceCmd
	}
	TFunctionLoadStub        func(context.Context, string) *redisa.StatusCmd
	tFunctionLoadMutex       sync.RWMutex
	tFunctionLoadArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	tFunctionLoadReturns struct {
		result1 *redisa.StatusCmd
	}
	tFunctionLoadReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TFunctionLoadArgsStub        func(context.Context, string, *redisa.TFunctionLoadOptions) *redisa.StatusCmd
	tFunctionLoadArgsMutex       sync.RWMutex
	tFunctionLoadArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.TFunctionLoadOptions
	}
	tFunctionLoadArgsReturns struct {
		result1 *redisa.StatusCmd
	}
	tFunctionLoadArgsReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TSAddStub        func(context.Context, string, interface{}, float64) *redisa.IntCmd
	tSAddMutex       sync.RWMutex
	tSAddArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 float64
	}
	tSAddReturns struct {
		result1 *redisa.IntCmd
	}
	tSAddReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	TSAddWithArgsStub        func(context.Context, string, interface{}, float64, *redisa.TSOptions) *redisa.IntCmd
	tSAddWithArgsMutex       sync.RWMutex
	tSAddWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 float64
		arg5 *redisa.TSOptions
	}
	tSAddWithArgsReturns struct {
		result1 *redisa.IntCmd
	}
	tSAddWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	TSAlterStub        func(context.Context, string, *redisa.TSAlterOptions) *redisa.StatusCmd
	tSAlterMutex       sync.RWMutex
	tSAlterArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.TSAlterOptions
	}
	tSAlterReturns struct {
		result1 *redisa.StatusCmd
	}
	tSAlterReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TSCreateStub        func(context.Context, string) *redisa.StatusCmd
	tSCreateMutex       sync.RWMutex
	tSCreateArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	tSCreateReturns struct {
		result1 *redisa.StatusCmd
	}
	tSCreateReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TSCreateRuleStub        func(context.Context, string, string, redisa.Aggregator, int) *redisa.StatusCmd
	tSCreateRuleMutex       sync.RWMutex
	tSCreateRuleArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 redisa.Aggregator
		arg5 int
	}
	tSCreateRuleReturns struct {
		result1 *redisa.StatusCmd
	}
	tSCreateRuleReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TSCreateRuleWithArgsStub        func(context.Context, string, string, redisa.Aggregator, int, *redisa.TSCreateRuleOptions) *redisa.StatusCmd
	tSCreateRuleWithArgsMutex       sync.RWMutex
	tSCreateRuleWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 redisa.Aggregator
		arg5 int
		arg6 *redisa.TSCreateRuleOptions
	}
	tSCreateRuleWithArgsReturns struct {
		result1 *redisa.StatusCmd
	}
	tSCreateRuleWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TSCreateWithArgsStub        func(context.Context, string, *redisa.TSOptions) *redisa.StatusCmd
	tSCreateWithArgsMutex       sync.RWMutex
	tSCreateWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.TSOptions
	}
	tSCreateWithArgsReturns struct {
		result1 *redisa.StatusCmd
	}
	tSCreateWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TSDecrByStub        func(context.Context, string, float64) *redisa.IntCmd
	tSDecrByMutex       sync.RWMutex
	tSDecrByArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 float64
	}
	tSDecrByReturns struct {
		result1 *redisa.IntCmd
	}
	tSDecrByReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	TSDecrByWithArgsStub        func(context.Context, string, float64, *redisa.TSIncrDecrOptions) *redisa.IntCmd
	tSDecrByWithArgsMutex       sync.RWMutex
	tSDecrByWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 *redisa.TSIncrDecrOptions
	}
	tSDecrByWithArgsReturns struct {
		result1 *redisa.IntCmd
	}
	tSDecrByWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	TSDelStub        func(context.Context, string, int, int) *redisa.IntCmd
	tSDelMutex       sync.RWMutex
	tSDelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 int
	}
	tSDelReturns struct {
		result1 *redisa.IntCmd
	}
	tSDelReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	TSDeleteRuleStub        func(context.Context, string, string) *redisa.StatusCmd
	tSDeleteRuleMutex       sync.RWMutex
	tSDeleteRuleArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	tSDeleteRuleReturns struct {
		result1 *redisa.StatusCmd
	}
	tSDeleteRuleReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TSGetStub        func(context.Context, string) *redisa.TSTimestampValueCmd
	tSGetMutex       sync.RWMutex
	tSGetArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	tSGetReturns struct {
		result1 *redisa.TSTimestampValueCmd
	}
	tSGetReturnsOnCall map[int]struct {
		result1 *redisa.TSTimestampValueCmd
	}
	TSGetWithArgsStub        func(context.Context, string, *redisa.TSGetOptions) *redisa.TSTimestampValueCmd
	tSGetWithArgsMutex       sync.RWMutex
	tSGetWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.TSGetOptions
	}
	tSGetWithArgsReturns struct {
		result1 *redisa.TSTimestampValueCmd
	}
	tSGetWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.TSTimestampValueCmd
	}
	TSIncrByStub        func(context.Context, string, float64) *redisa.IntCmd
	tSIncrByMutex       sync.RWMutex
	tSIncrByArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 float64
	}
	tSIncrByReturns struct {
		result1 *redisa.IntCmd
	}
	tSIncrByReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	TSIncrByWithArgsStub        func(context.Context, string, float64, *redisa.TSIncrDecrOptions) *redisa.IntCmd
	tSIncrByWithArgsMutex       sync.RWMutex
	tSIncrByWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 *redisa.TSIncrDecrOptions
	}
	tSIncrByWithArgsReturns struct {
		result1 *redisa.IntCmd
	}
	tSIncrByWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	TSInfoStub        func(context.Context, string) *redisa.MapStringInterfaceCmd
	tSInfoMutex       sync.RWMutex
	tSInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	tSInfoReturns struct {
		result1 *redisa.MapStringInterfaceCmd
	}
	tSInfoReturnsOnCall map[int]struct {
		result1 *redisa.MapStringInterfaceCmd
	}
	TSInfoWithArgsStub        func(context.Context, string, *redisa.TSInfoOptions) *redisa.MapStringInterfaceCmd
	tSInfoWithArgsMutex       sync.RWMutex
	tSInfoWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.TSInfoOptions
	}
	tSInfoWithArgsReturns struct {
		result1 *redisa.MapStringInterfaceCmd
	}
	tSInfoWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.MapStringInterfaceCmd
	}
	TSMAddStub        func(context.Context, [][]interface{}) *redisa.IntSliceCmd
	tSMAddMutex       sync.RWMutex
	tSMAddArgsForCall []struct {
		arg1 context.Context
		arg2 [][]interface{}
	}
	tSMAddReturns struct {
		result1 *redisa.IntSliceCmd
	}
	tSMAddReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	TSMGetStub        func(context.Context, []string) *redisa.MapStringSliceInterfaceCmd
	tSMGetMutex       sync.RWMutex
	tSMGetArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	tSMGetReturns struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}
	tSMGetReturnsOnCall map[int]struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}
	TSMGetWithArgsStub        func(context.Context, []string, *redisa.TSMGetOptions) *redisa.MapStringSliceInterfaceCmd
	tSMGetWithArgsMutex       sync.RWMutex
	tSMGetWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 []string
		arg3 *redisa.TSMGetOptions
	}
	tSMGetWithArgsReturns struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}
	tSMGetWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}
	TSMRangeStub        func(context.Context, int, int, []string) *redisa.MapStringSliceInterfaceCmd
	tSMRangeMutex       sync.RWMutex
	tSMRangeArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 int
		arg4 []string
	}
	tSMRangeReturns struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}
	tSMRangeReturnsOnCall map[int]struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}
	TSMRangeWithArgsStub        func(context.Context, int, int, []string, *redisa.TSMRangeOptions) *redisa.MapStringSliceInterfaceCmd
	tSMRangeWithArgsMutex       sync.RWMutex
	tSMRangeWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 int
		arg4 []string
		arg5 *redisa.TSMRangeOptions
	}
	tSMRangeWithArgsReturns struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}
	tSMRangeWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}
	TSMRevRangeStub        func(context.Context, int, int, []string) *redisa.MapStringSliceInterfaceCmd
	tSMRevRangeMutex       sync.RWMutex
	tSMRevRangeArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 int
		arg4 []string
	}
	tSMRevRangeReturns struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}
	tSMRevRangeReturnsOnCall map[int]struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}
	TSMRevRangeWithArgsStub        func(context.Context, int, int, []string, *redisa.TSMRevRangeOptions) *redisa.MapStringSliceInterfaceCmd
	tSMRevRangeWithArgsMutex       sync.RWMutex
	tSMRevRangeWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 int
		arg4 []string
		arg5 *redisa.TSMRevRangeOptions
	}
	tSMRevRangeWithArgsReturns struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}
	tSMRevRangeWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}
	TSQueryIndexStub        func(context.Context, []string) *redisa.StringSliceCmd
	tSQueryIndexMutex       sync.RWMutex
	tSQueryIndexArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	tSQueryIndexReturns struct {
		result1 *redisa.StringSliceCmd
	}
	tSQueryIndexReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	TSRangeStub        func(context.Context, string, int, int) *redisa.TSTimestampValueSliceCmd
	tSRangeMutex       sync.RWMutex
	tSRangeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 int
	}
	tSRangeReturns struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}
	tSRangeReturnsOnCall map[int]struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}
	TSRangeWithArgsStub        func(context.Context, string, int, int, *redisa.TSRangeOptions) *redisa.TSTimestampValueSliceCmd
	tSRangeWithArgsMutex       sync.RWMutex
	tSRangeWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 int
		arg5 *redisa.TSRangeOptions
	}
	tSRangeWithArgsReturns struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}
	tSRangeWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}
	TSRevRangeStub        func(context.Context, string, int, int) *redisa.TSTimestampValueSliceCmd
	tSRevRangeMutex       sync.RWMutex
	tSRevRangeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 int
	}
	tSRevRangeReturns struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}
	tSRevRangeReturnsOnCall map[int]struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}
	TSRevRangeWithArgsStub        func(context.Context, string, int, int, *redisa.TSRevRangeOptions) *redisa.TSTimestampValueSliceCmd
	tSRevRangeWithArgsMutex       sync.RWMutex
	tSRevRangeWithArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 int
		arg5 *redisa.TSRevRangeOptions
	}
	tSRevRangeWithArgsReturns struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}
	tSRevRangeWithArgsReturnsOnCall map[int]struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}
	TTLStub        func(context.Context, string) *redisa.DurationCmd
	tTLMutex       sync.RWMutex
	tTLArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	tTLReturns struct {
		result1 *redisa.DurationCmd
	}
	tTLReturnsOnCall map[int]struct {
		result1 *redisa.DurationCmd
	}
	TimeStub        func(context.Context) *redisa.TimeCmd
	timeMutex       sync.RWMutex
	timeArgsForCall []struct {
		arg1 context.Context
	}
	timeReturns struct {
		result1 *redisa.TimeCmd
	}
	timeReturnsOnCall map[int]struct {
		result1 *redisa.TimeCmd
	}
	TopKAddStub        func(context.Context, string, ...interface{}) *redisa.StringSliceCmd
	topKAddMutex       sync.RWMutex
	topKAddArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	topKAddReturns struct {
		result1 *redisa.StringSliceCmd
	}
	topKAddReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	TopKCountStub        func(context.Context, string, ...interface{}) *redisa.IntSliceCmd
	topKCountMutex       sync.RWMutex
	topKCountArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	topKCountReturns struct {
		result1 *redisa.IntSliceCmd
	}
	topKCountReturnsOnCall map[int]struct {
		result1 *redisa.IntSliceCmd
	}
	TopKIncrByStub        func(context.Context, string, ...interface{}) *redisa.StringSliceCmd
	topKIncrByMutex       sync.RWMutex
	topKIncrByArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	topKIncrByReturns struct {
		result1 *redisa.StringSliceCmd
	}
	topKIncrByReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	TopKInfoStub        func(context.Context, string) *redisa.TopKInfoCmd
	topKInfoMutex       sync.RWMutex
	topKInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	topKInfoReturns struct {
		result1 *redisa.TopKInfoCmd
	}
	topKInfoReturnsOnCall map[int]struct {
		result1 *redisa.TopKInfoCmd
	}
	TopKListStub        func(context.Context, string) *redisa.StringSliceCmd
	topKListMutex       sync.RWMutex
	topKListArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	topKListReturns struct {
		result1 *redisa.StringSliceCmd
	}
	topKListReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	TopKListWithCountStub        func(context.Context, string) *redisa.MapStringIntCmd
	topKListWithCountMutex       sync.RWMutex
	topKListWithCountArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	topKListWithCountReturns struct {
		result1 *redisa.MapStringIntCmd
	}
	topKListWithCountReturnsOnCall map[int]struct {
		result1 *redisa.MapStringIntCmd
	}
	TopKQueryStub        func(context.Context, string, ...interface{}) *redisa.BoolSliceCmd
	topKQueryMutex       sync.RWMutex
	topKQueryArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	topKQueryReturns struct {
		result1 *redisa.BoolSliceCmd
	}
	topKQueryReturnsOnCall map[int]struct {
		result1 *redisa.BoolSliceCmd
	}
	TopKReserveStub        func(context.Context, string, int64) *redisa.StatusCmd
	topKReserveMutex       sync.RWMutex
	topKReserveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}
	topKReserveReturns struct {
		result1 *redisa.StatusCmd
	}
	topKReserveReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TopKReserveWithOptionsStub        func(context.Context, string, int64, int64, int64, float64) *redisa.StatusCmd
	topKReserveWithOptionsMutex       sync.RWMutex
	topKReserveWithOptionsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
		arg5 int64
		arg6 float64
	}
	topKReserveWithOptionsReturns struct {
		result1 *redisa.StatusCmd
	}
	topKReserveWithOptionsReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	TouchStub        func(context.Context, ...string) *redisa.IntCmd
	touchMutex       sync.RWMutex
	touchArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	touchReturns struct {
		result1 *redisa.IntCmd
	}
	touchReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	TxPipelineStub        func() redisa.Pipeliner
	txPipelineMutex       sync.RWMutex
	txPipelineArgsForCall []struct {
	}
	txPipelineReturns struct {
		result1 redisa.Pipeliner
	}
	txPipelineReturnsOnCall map[int]struct {
		result1 redisa.Pipeliner
	}
	TxPipelinedStub        func(context.Context, func(redisa.Pipeliner) error) ([]redisa.Cmder, error)
	txPipelinedMutex       sync.RWMutex
	txPipelinedArgsForCall []struct {
		arg1 context.Context
		arg2 func(redisa.Pipeliner) error
	}
	txPipelinedReturns struct {
		result1 []redisa.Cmder
		result2 error
	}
	txPipelinedReturnsOnCall map[int]struct {
		result1 []redisa.Cmder
		result2 error
	}
	TypeStub        func(context.Context, string) *redisa.StatusCmd
	typeMutex       sync.RWMutex
	typeArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	typeReturns struct {
		result1 *redisa.StatusCmd
	}
	typeReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	UnlinkStub        func(context.Context, ...string) *redisa.IntCmd
	unlinkMutex       sync.RWMutex
	unlinkArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	unlinkReturns struct {
		result1 *redisa.IntCmd
	}
	unlinkReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	WatchStub        func(context.Context, func(*redisa.Tx) error, ...string) error
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
		arg1 context.Context
		arg2 func(*redisa.Tx) error
		arg3 []string
	}
	watchReturns struct {
		result1 error
	}
	watchReturnsOnCall map[int]struct {
		result1 error
	}
	XAckStub        func(context.Context, string, string, ...string) *redisa.IntCmd
	xAckMutex       sync.RWMutex
	xAckArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []string
	}
	xAckReturns struct {
		result1 *redisa.IntCmd
	}
	xAckReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	XAddStub        func(context.Context, *redisa.XAddArgs) *redisa.StringCmd
	xAddMutex       sync.RWMutex
	xAddArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.XAddArgs
	}
	xAddReturns struct {
		result1 *redisa.StringCmd
	}
	xAddReturnsOnCall map[int]struct {
		result1 *redisa.StringCmd
	}
	XAutoClaimStub        func(context.Context, *redisa.XAutoClaimArgs) *redisa.XAutoClaimCmd
	xAutoClaimMutex       sync.RWMutex
	xAutoClaimArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.XAutoClaimArgs
	}
	xAutoClaimReturns struct {
		result1 *redisa.XAutoClaimCmd
	}
	xAutoClaimReturnsOnCall map[int]struct {
		result1 *redisa.XAutoClaimCmd
	}
	XAutoClaimJustIDStub        func(context.Context, *redisa.XAutoClaimArgs) *redisa.XAutoClaimJustIDCmd
	xAutoClaimJustIDMutex       sync.RWMutex
	xAutoClaimJustIDArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.XAutoClaimArgs
	}
	xAutoClaimJustIDReturns struct {
		result1 *redisa.XAutoClaimJustIDCmd
	}
	xAutoClaimJustIDReturnsOnCall map[int]struct {
		result1 *redisa.XAutoClaimJustIDCmd
	}
	XClaimStub        func(context.Context, *redisa.XClaimArgs) *redisa.XMessageSliceCmd
	xClaimMutex       sync.RWMutex
	xClaimArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.XClaimArgs
	}
	xClaimReturns struct {
		result1 *redisa.XMessageSliceCmd
	}
	xClaimReturnsOnCall map[int]struct {
		result1 *redisa.XMessageSliceCmd
	}
	XClaimJustIDStub        func(context.Context, *redisa.XClaimArgs) *redisa.StringSliceCmd
	xClaimJustIDMutex       sync.RWMutex
	xClaimJustIDArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.XClaimArgs
	}
	xClaimJustIDReturns struct {
		result1 *redisa.StringSliceCmd
	}
	xClaimJustIDReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	XDelStub        func(context.Context, string, ...string) *redisa.IntCmd
	xDelMutex       sync.RWMutex
	xDelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	xDelReturns struct {
		result1 *redisa.IntCmd
	}
	xDelReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	XGroupCreateStub        func(context.Context, string, string, string) *redisa.StatusCmd
	xGroupCreateMutex       sync.RWMutex
	xGroupCreateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	xGroupCreateReturns struct {
		result1 *redisa.StatusCmd
	}
	xGroupCreateReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	XGroupCreateConsumerStub        func(context.Context, string, string, string) *redisa.IntCmd
	xGroupCreateConsumerMutex       sync.RWMutex
	xGroupCreateConsumerArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	xGroupCreateConsumerReturns struct {
		result1 *redisa.IntCmd
	}
	xGroupCreateConsumerReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	XGroupCreateMkStreamStub        func(context.Context, string, string, string) *redisa.StatusCmd
	xGroupCreateMkStreamMutex       sync.RWMutex
	xGroupCreateMkStreamArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	xGroupCreateMkStreamReturns struct {
		result1 *redisa.StatusCmd
	}
	xGroupCreateMkStreamReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	XGroupDelConsumerStub        func(context.Context, string, string, string) *redisa.IntCmd
	xGroupDelConsumerMutex       sync.RWMutex
	xGroupDelConsumerArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	xGroupDelConsumerReturns struct {
		result1 *redisa.IntCmd
	}
	xGroupDelConsumerReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	XGroupDestroyStub        func(context.Context, string, string) *redisa.IntCmd
	xGroupDestroyMutex       sync.RWMutex
	xGroupDestroyArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	xGroupDestroyReturns struct {
		result1 *redisa.IntCmd
	}
	xGroupDestroyReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	XGroupSetIDStub        func(context.Context, string, string, string) *redisa.StatusCmd
	xGroupSetIDMutex       sync.RWMutex
	xGroupSetIDArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	xGroupSetIDReturns struct {
		result1 *redisa.StatusCmd
	}
	xGroupSetIDReturnsOnCall map[int]struct {
		result1 *redisa.StatusCmd
	}
	XInfoConsumersStub        func(context.Context, string, string) *redisa.XInfoConsumersCmd
	xInfoConsumersMutex       sync.RWMutex
	xInfoConsumersArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	xInfoConsumersReturns struct {
		result1 *redisa.XInfoConsumersCmd
	}
	xInfoConsumersReturnsOnCall map[int]struct {
		result1 *redisa.XInfoConsumersCmd
	}
	XInfoGroupsStub        func(context.Context, string) *redisa.XInfoGroupsCmd
	xInfoGroupsMutex       sync.RWMutex
	xInfoGroupsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	xInfoGroupsReturns struct {
		result1 *redisa.XInfoGroupsCmd
	}
	xInfoGroupsReturnsOnCall map[int]struct {
		result1 *redisa.XInfoGroupsCmd
	}
	XInfoStreamStub        func(context.Context, string) *redisa.XInfoStreamCmd
	xInfoStreamMutex       sync.RWMutex
	xInfoStreamArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	xInfoStreamReturns struct {
		result1 *redisa.XInfoStreamCmd
	}
	xInfoStreamReturnsOnCall map[int]struct {
		result1 *redisa.XInfoStreamCmd
	}
	XInfoStreamFullStub        func(context.Context, string, int) *redisa.XInfoStreamFullCmd
	xInfoStreamFullMutex       sync.RWMutex
	xInfoStreamFullArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}
	xInfoStreamFullReturns struct {
		result1 *redisa.XInfoStreamFullCmd
	}
	xInfoStreamFullReturnsOnCall map[int]struct {
		result1 *redisa.XInfoStreamFullCmd
	}
	XLenStub        func(context.Context, string) *redisa.IntCmd
	xLenMutex       sync.RWMutex
	xLenArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	xLenReturns struct {
		result1 *redisa.IntCmd
	}
	xLenReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	XPendingStub        func(context.Context, string, string) *redisa.XPendingCmd
	xPendingMutex       sync.RWMutex
	xPendingArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	xPendingReturns struct {
		result1 *redisa.XPendingCmd
	}
	xPendingReturnsOnCall map[int]struct {
		result1 *redisa.XPendingCmd
	}
	XPendingExtStub        func(context.Context, *redisa.XPendingExtArgs) *redisa.XPendingExtCmd
	xPendingExtMutex       sync.RWMutex
	xPendingExtArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.XPendingExtArgs
	}
	xPendingExtReturns struct {
		result1 *redisa.XPendingExtCmd
	}
	xPendingExtReturnsOnCall map[int]struct {
		result1 *redisa.XPendingExtCmd
	}
	XRangeStub        func(context.Context, string, string, string) *redisa.XMessageSliceCmd
	xRangeMutex       sync.RWMutex
	xRangeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	xRangeReturns struct {
		result1 *redisa.XMessageSliceCmd
	}
	xRangeReturnsOnCall map[int]struct {
		result1 *redisa.XMessageSliceCmd
	}
	XRangeNStub        func(context.Context, string, string, string, int64) *redisa.XMessageSliceCmd
	xRangeNMutex       sync.RWMutex
	xRangeNArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 int64
	}
	xRangeNReturns struct {
		result1 *redisa.XMessageSliceCmd
	}
	xRangeNReturnsOnCall map[int]struct {
		result1 *redisa.XMessageSliceCmd
	}
	XReadStub        func(context.Context, *redisa.XReadArgs) *redisa.XStreamSliceCmd
	xReadMutex       sync.RWMutex
	xReadArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.XReadArgs
	}
	xReadReturns struct {
		result1 *redisa.XStreamSliceCmd
	}
	xReadReturnsOnCall map[int]struct {
		result1 *redisa.XStreamSliceCmd
	}
	XReadGroupStub        func(context.Context, *redisa.XReadGroupArgs) *redisa.XStreamSliceCmd
	xReadGroupMutex       sync.RWMutex
	xReadGroupArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.XReadGroupArgs
	}
	xReadGroupReturns struct {
		result1 *redisa.XStreamSliceCmd
	}
	xReadGroupReturnsOnCall map[int]struct {
		result1 *redisa.XStreamSliceCmd
	}
	XReadStreamsStub        func(context.Context, ...string) *redisa.XStreamSliceCmd
	xReadStreamsMutex       sync.RWMutex
	xReadStreamsArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	xReadStreamsReturns struct {
		result1 *redisa.XStreamSliceCmd
	}
	xReadStreamsReturnsOnCall map[int]struct {
		result1 *redisa.XStreamSliceCmd
	}
	XRevRangeStub        func(context.Context, string, string, string) *redisa.XMessageSliceCmd
	xRevRangeMutex       sync.RWMutex
	xRevRangeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	xRevRangeReturns struct {
		result1 *redisa.XMessageSliceCmd
	}
	xRevRangeReturnsOnCall map[int]struct {
		result1 *redisa.XMessageSliceCmd
	}
	XRevRangeNStub        func(context.Context, string, string, string, int64) *redisa.XMessageSliceCmd
	xRevRangeNMutex       sync.RWMutex
	xRevRangeNArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 int64
	}
	xRevRangeNReturns struct {
		result1 *redisa.XMessageSliceCmd
	}
	xRevRangeNReturnsOnCall map[int]struct {
		result1 *redisa.XMessageSliceCmd
	}
	XTrimMaxLenStub        func(context.Context, string, int64) *redisa.IntCmd
	xTrimMaxLenMutex       sync.RWMutex
	xTrimMaxLenArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}
	xTrimMaxLenReturns struct {
		result1 *redisa.IntCmd
	}
	xTrimMaxLenReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	XTrimMaxLenApproxStub        func(context.Context, string, int64, int64) *redisa.IntCmd
	xTrimMaxLenApproxMutex       sync.RWMutex
	xTrimMaxLenApproxArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	xTrimMaxLenApproxReturns struct {
		result1 *redisa.IntCmd
	}
	xTrimMaxLenApproxReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	XTrimMinIDStub        func(context.Context, string, string) *redisa.IntCmd
	xTrimMinIDMutex       sync.RWMutex
	xTrimMinIDArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	xTrimMinIDReturns struct {
		result1 *redisa.IntCmd
	}
	xTrimMinIDReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	XTrimMinIDApproxStub        func(context.Context, string, string, int64) *redisa.IntCmd
	xTrimMinIDApproxMutex       sync.RWMutex
	xTrimMinIDApproxArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}
	xTrimMinIDApproxReturns struct {
		result1 *redisa.IntCmd
	}
	xTrimMinIDApproxReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZAddStub        func(context.Context, string, ...redisa.Z) *redisa.IntCmd
	zAddMutex       sync.RWMutex
	zAddArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []redisa.Z
	}
	zAddReturns struct {
		result1 *redisa.IntCmd
	}
	zAddReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZAddArgsStub        func(context.Context, string, redisa.ZAddArgs) *redisa.IntCmd
	zAddArgsMutex       sync.RWMutex
	zAddArgsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 redisa.ZAddArgs
	}
	zAddArgsReturns struct {
		result1 *redisa.IntCmd
	}
	zAddArgsReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZAddArgsIncrStub        func(context.Context, string, redisa.ZAddArgs) *redisa.FloatCmd
	zAddArgsIncrMutex       sync.RWMutex
	zAddArgsIncrArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 redisa.ZAddArgs
	}
	zAddArgsIncrReturns struct {
		result1 *redisa.FloatCmd
	}
	zAddArgsIncrReturnsOnCall map[int]struct {
		result1 *redisa.FloatCmd
	}
	ZAddGTStub        func(context.Context, string, ...redisa.Z) *redisa.IntCmd
	zAddGTMutex       sync.RWMutex
	zAddGTArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []redisa.Z
	}
	zAddGTReturns struct {
		result1 *redisa.IntCmd
	}
	zAddGTReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZAddLTStub        func(context.Context, string, ...redisa.Z) *redisa.IntCmd
	zAddLTMutex       sync.RWMutex
	zAddLTArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []redisa.Z
	}
	zAddLTReturns struct {
		result1 *redisa.IntCmd
	}
	zAddLTReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZAddNXStub        func(context.Context, string, ...redisa.Z) *redisa.IntCmd
	zAddNXMutex       sync.RWMutex
	zAddNXArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []redisa.Z
	}
	zAddNXReturns struct {
		result1 *redisa.IntCmd
	}
	zAddNXReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZAddXXStub        func(context.Context, string, ...redisa.Z) *redisa.IntCmd
	zAddXXMutex       sync.RWMutex
	zAddXXArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []redisa.Z
	}
	zAddXXReturns struct {
		result1 *redisa.IntCmd
	}
	zAddXXReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZCardStub        func(context.Context, string) *redisa.IntCmd
	zCardMutex       sync.RWMutex
	zCardArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	zCardReturns struct {
		result1 *redisa.IntCmd
	}
	zCardReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZCountStub        func(context.Context, string, string, string) *redisa.IntCmd
	zCountMutex       sync.RWMutex
	zCountArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	zCountReturns struct {
		result1 *redisa.IntCmd
	}
	zCountReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZDiffStub        func(context.Context, ...string) *redisa.StringSliceCmd
	zDiffMutex       sync.RWMutex
	zDiffArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	zDiffReturns struct {
		result1 *redisa.StringSliceCmd
	}
	zDiffReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ZDiffStoreStub        func(context.Context, string, ...string) *redisa.IntCmd
	zDiffStoreMutex       sync.RWMutex
	zDiffStoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	zDiffStoreReturns struct {
		result1 *redisa.IntCmd
	}
	zDiffStoreReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZDiffWithScoresStub        func(context.Context, ...string) *redisa.ZSliceCmd
	zDiffWithScoresMutex       sync.RWMutex
	zDiffWithScoresArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	zDiffWithScoresReturns struct {
		result1 *redisa.ZSliceCmd
	}
	zDiffWithScoresReturnsOnCall map[int]struct {
		result1 *redisa.ZSliceCmd
	}
	ZIncrByStub        func(context.Context, string, float64, string) *redisa.FloatCmd
	zIncrByMutex       sync.RWMutex
	zIncrByArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 string
	}
	zIncrByReturns struct {
		result1 *redisa.FloatCmd
	}
	zIncrByReturnsOnCall map[int]struct {
		result1 *redisa.FloatCmd
	}
	ZInterStub        func(context.Context, *redisa.ZStore) *redisa.StringSliceCmd
	zInterMutex       sync.RWMutex
	zInterArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.ZStore
	}
	zInterReturns struct {
		result1 *redisa.StringSliceCmd
	}
	zInterReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ZInterCardStub        func(context.Context, int64, ...string) *redisa.IntCmd
	zInterCardMutex       sync.RWMutex
	zInterCardArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 []string
	}
	zInterCardReturns struct {
		result1 *redisa.IntCmd
	}
	zInterCardReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZInterStoreStub        func(context.Context, string, *redisa.ZStore) *redisa.IntCmd
	zInterStoreMutex       sync.RWMutex
	zInterStoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZStore
	}
	zInterStoreReturns struct {
		result1 *redisa.IntCmd
	}
	zInterStoreReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZInterWithScoresStub        func(context.Context, *redisa.ZStore) *redisa.ZSliceCmd
	zInterWithScoresMutex       sync.RWMutex
	zInterWithScoresArgsForCall []struct {
		arg1 context.Context
		arg2 *redisa.ZStore
	}
	zInterWithScoresReturns struct {
		result1 *redisa.ZSliceCmd
	}
	zInterWithScoresReturnsOnCall map[int]struct {
		result1 *redisa.ZSliceCmd
	}
	ZLexCountStub        func(context.Context, string, string, string) *redisa.IntCmd
	zLexCountMutex       sync.RWMutex
	zLexCountArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	zLexCountReturns struct {
		result1 *redisa.IntCmd
	}
	zLexCountReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZMPopStub        func(context.Context, string, int64, ...string) *redisa.ZSliceWithKeyCmd
	zMPopMutex       sync.RWMutex
	zMPopArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 []string
	}
	zMPopReturns struct {
		result1 *redisa.ZSliceWithKeyCmd
	}
	zMPopReturnsOnCall map[int]struct {
		result1 *redisa.ZSliceWithKeyCmd
	}
	ZMScoreStub        func(context.Context, string, ...string) *redisa.FloatSliceCmd
	zMScoreMutex       sync.RWMutex
	zMScoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	zMScoreReturns struct {
		result1 *redisa.FloatSliceCmd
	}
	zMScoreReturnsOnCall map[int]struct {
		result1 *redisa.FloatSliceCmd
	}
	ZPopMaxStub        func(context.Context, string, ...int64) *redisa.ZSliceCmd
	zPopMaxMutex       sync.RWMutex
	zPopMaxArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []int64
	}
	zPopMaxReturns struct {
		result1 *redisa.ZSliceCmd
	}
	zPopMaxReturnsOnCall map[int]struct {
		result1 *redisa.ZSliceCmd
	}
	ZPopMinStub        func(context.Context, string, ...int64) *redisa.ZSliceCmd
	zPopMinMutex       sync.RWMutex
	zPopMinArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []int64
	}
	zPopMinReturns struct {
		result1 *redisa.ZSliceCmd
	}
	zPopMinReturnsOnCall map[int]struct {
		result1 *redisa.ZSliceCmd
	}
	ZRandMemberStub        func(context.Context, string, int) *redisa.StringSliceCmd
	zRandMemberMutex       sync.RWMutex
	zRandMemberArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}
	zRandMemberReturns struct {
		result1 *redisa.StringSliceCmd
	}
	zRandMemberReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ZRandMemberWithScoresStub        func(context.Context, string, int) *redisa.ZSliceCmd
	zRandMemberWithScoresMutex       sync.RWMutex
	zRandMemberWithScoresArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}
	zRandMemberWithScoresReturns struct {
		result1 *redisa.ZSliceCmd
	}
	zRandMemberWithScoresReturnsOnCall map[int]struct {
		result1 *redisa.ZSliceCmd
	}
	ZRangeStub        func(context.Context, string, int64, int64) *redisa.StringSliceCmd
	zRangeMutex       sync.RWMutex
	zRangeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	zRangeReturns struct {
		result1 *redisa.StringSliceCmd
	}
	zRangeReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ZRangeArgsStub        func(context.Context, redisa.ZRangeArgs) *redisa.StringSliceCmd
	zRangeArgsMutex       sync.RWMutex
	zRangeArgsArgsForCall []struct {
		arg1 context.Context
		arg2 redisa.ZRangeArgs
	}
	zRangeArgsReturns struct {
		result1 *redisa.StringSliceCmd
	}
	zRangeArgsReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ZRangeArgsWithScoresStub        func(context.Context, redisa.ZRangeArgs) *redisa.ZSliceCmd
	zRangeArgsWithScoresMutex       sync.RWMutex
	zRangeArgsWithScoresArgsForCall []struct {
		arg1 context.Context
		arg2 redisa.ZRangeArgs
	}
	zRangeArgsWithScoresReturns struct {
		result1 *redisa.ZSliceCmd
	}
	zRangeArgsWithScoresReturnsOnCall map[int]struct {
		result1 *redisa.ZSliceCmd
	}
	ZRangeByLexStub        func(context.Context, string, *redisa.ZRangeBy) *redisa.StringSliceCmd
	zRangeByLexMutex       sync.RWMutex
	zRangeByLexArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZRangeBy
	}
	zRangeByLexReturns struct {
		result1 *redisa.StringSliceCmd
	}
	zRangeByLexReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ZRangeByScoreStub        func(context.Context, string, *redisa.ZRangeBy) *redisa.StringSliceCmd
	zRangeByScoreMutex       sync.RWMutex
	zRangeByScoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZRangeBy
	}
	zRangeByScoreReturns struct {
		result1 *redisa.StringSliceCmd
	}
	zRangeByScoreReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ZRangeByScoreWithScoresStub        func(context.Context, string, *redisa.ZRangeBy) *redisa.ZSliceCmd
	zRangeByScoreWithScoresMutex       sync.RWMutex
	zRangeByScoreWithScoresArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZRangeBy
	}
	zRangeByScoreWithScoresReturns struct {
		result1 *redisa.ZSliceCmd
	}
	zRangeByScoreWithScoresReturnsOnCall map[int]struct {
		result1 *redisa.ZSliceCmd
	}
	ZRangeStoreStub        func(context.Context, string, redisa.ZRangeArgs) *redisa.IntCmd
	zRangeStoreMutex       sync.RWMutex
	zRangeStoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 redisa.ZRangeArgs
	}
	zRangeStoreReturns struct {
		result1 *redisa.IntCmd
	}
	zRangeStoreReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZRangeWithScoresStub        func(context.Context, string, int64, int64) *redisa.ZSliceCmd
	zRangeWithScoresMutex       sync.RWMutex
	zRangeWithScoresArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	zRangeWithScoresReturns struct {
		result1 *redisa.ZSliceCmd
	}
	zRangeWithScoresReturnsOnCall map[int]struct {
		result1 *redisa.ZSliceCmd
	}
	ZRankStub        func(context.Context, string, string) *redisa.IntCmd
	zRankMutex       sync.RWMutex
	zRankArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	zRankReturns struct {
		result1 *redisa.IntCmd
	}
	zRankReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZRankWithScoreStub        func(context.Context, string, string) *redisa.RankWithScoreCmd
	zRankWithScoreMutex       sync.RWMutex
	zRankWithScoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	zRankWithScoreReturns struct {
		result1 *redisa.RankWithScoreCmd
	}
	zRankWithScoreReturnsOnCall map[int]struct {
		result1 *redisa.RankWithScoreCmd
	}
	ZRemStub        func(context.Context, string, ...interface{}) *redisa.IntCmd
	zRemMutex       sync.RWMutex
	zRemArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	zRemReturns struct {
		result1 *redisa.IntCmd
	}
	zRemReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZRemRangeByLexStub        func(context.Context, string, string, string) *redisa.IntCmd
	zRemRangeByLexMutex       sync.RWMutex
	zRemRangeByLexArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	zRemRangeByLexReturns struct {
		result1 *redisa.IntCmd
	}
	zRemRangeByLexReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZRemRangeByRankStub        func(context.Context, string, int64, int64) *redisa.IntCmd
	zRemRangeByRankMutex       sync.RWMutex
	zRemRangeByRankArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	zRemRangeByRankReturns struct {
		result1 *redisa.IntCmd
	}
	zRemRangeByRankReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZRemRangeByScoreStub        func(context.Context, string, string, string) *redisa.IntCmd
	zRemRangeByScoreMutex       sync.RWMutex
	zRemRangeByScoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	zRemRangeByScoreReturns struct {
		result1 *redisa.IntCmd
	}
	zRemRangeByScoreReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZRevRangeStub        func(context.Context, string, int64, int64) *redisa.StringSliceCmd
	zRevRangeMutex       sync.RWMutex
	zRevRangeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	zRevRangeReturns struct {
		result1 *redisa.StringSliceCmd
	}
	zRevRangeReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ZRevRangeByLexStub        func(context.Context, string, *redisa.ZRangeBy) *redisa.StringSliceCmd
	zRevRangeByLexMutex       sync.RWMutex
	zRevRangeByLexArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZRangeBy
	}
	zRevRangeByLexReturns struct {
		result1 *redisa.StringSliceCmd
	}
	zRevRangeByLexReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ZRevRangeByScoreStub        func(context.Context, string, *redisa.ZRangeBy) *redisa.StringSliceCmd
	zRevRangeByScoreMutex       sync.RWMutex
	zRevRangeByScoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZRangeBy
	}
	zRevRangeByScoreReturns struct {
		result1 *redisa.StringSliceCmd
	}
	zRevRangeByScoreReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ZRevRangeByScoreWithScoresStub        func(context.Context, string, *redisa.ZRangeBy) *redisa.ZSliceCmd
	zRevRangeByScoreWithScoresMutex       sync.RWMutex
	zRevRangeByScoreWithScoresArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZRangeBy
	}
	zRevRangeByScoreWithScoresReturns struct {
		result1 *redisa.ZSliceCmd
	}
	zRevRangeByScoreWithScoresReturnsOnCall map[int]struct {
		result1 *redisa.ZSliceCmd
	}
	ZRevRangeWithScoresStub        func(context.Context, string, int64, int64) *redisa.ZSliceCmd
	zRevRangeWithScoresMutex       sync.RWMutex
	zRevRangeWithScoresArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}
	zRevRangeWithScoresReturns struct {
		result1 *redisa.ZSliceCmd
	}
	zRevRangeWithScoresReturnsOnCall map[int]struct {
		result1 *redisa.ZSliceCmd
	}
	ZRevRankStub        func(context.Context, string, string) *redisa.IntCmd
	zRevRankMutex       sync.RWMutex
	zRevRankArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	zRevRankReturns struct {
		result1 *redisa.IntCmd
	}
	zRevRankReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZRevRankWithScoreStub        func(context.Context, string, string) *redisa.RankWithScoreCmd
	zRevRankWithScoreMutex       sync.RWMutex
	zRevRankWithScoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	zRevRankWithScoreReturns struct {
		result1 *redisa.RankWithScoreCmd
	}
	zRevRankWithScoreReturnsOnCall map[int]struct {
		result1 *redisa.RankWithScoreCmd
	}
	ZScanStub        func(context.Context, string, uint64, string, int64) *redisa.ScanCmd
	zScanMutex       sync.RWMutex
	zScanArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 uint64
		arg4 string
		arg5 int64
	}
	zScanReturns struct {
		result1 *redisa.ScanCmd
	}
	zScanReturnsOnCall map[int]struct {
		result1 *redisa.ScanCmd
	}
	ZScoreStub        func(context.Context, string, string) *redisa.FloatCmd
	zScoreMutex       sync.RWMutex
	zScoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	zScoreReturns struct {
		result1 *redisa.FloatCmd
	}
	zScoreReturnsOnCall map[int]struct {
		result1 *redisa.FloatCmd
	}
	ZUnionStub        func(context.Context, redisa.ZStore) *redisa.StringSliceCmd
	zUnionMutex       sync.RWMutex
	zUnionArgsForCall []struct {
		arg1 context.Context
		arg2 redisa.ZStore
	}
	zUnionReturns struct {
		result1 *redisa.StringSliceCmd
	}
	zUnionReturnsOnCall map[int]struct {
		result1 *redisa.StringSliceCmd
	}
	ZUnionStoreStub        func(context.Context, string, *redisa.ZStore) *redisa.IntCmd
	zUnionStoreMutex       sync.RWMutex
	zUnionStoreArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZStore
	}
	zUnionStoreReturns struct {
		result1 *redisa.IntCmd
	}
	zUnionStoreReturnsOnCall map[int]struct {
		result1 *redisa.IntCmd
	}
	ZUnionWithScoresStub        func(context.Context, redisa.ZStore) *redisa.ZSliceCmd
	zUnionWithScoresMutex       sync.RWMutex
	zUnionWithScoresArgsForCall []struct {
		arg1 context.Context
		arg2 redisa.ZStore
	}
	zUnionWithScoresReturns struct {
		result1 *redisa.ZSliceCmd
	}
	zUnionWithScoresReturnsOnCall map[int]struct {
		result1 *redisa.ZSliceCmd
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) ACLDryRun(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.StringCmd {
	fake.aCLDryRunMutex.Lock()
	ret, specificReturn := fake.aCLDryRunReturnsOnCall[len(fake.aCLDryRunArgsForCall)]
	fake.aCLDryRunArgsForCall = append(fake.aCLDryRunArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.ACLDryRunStub
	fakeReturns := fake.aCLDryRunReturns
	fake.recordInvocation("ACLDryRun", []interface{}{arg1, arg2, arg3})
	fake.aCLDryRunMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ACLDryRunCallCount() int {
	fake.aCLDryRunMutex.RLock()
	defer fake.aCLDryRunMutex.RUnlock()
	return len(fake.aCLDryRunArgsForCall)
}

func (fake *FakeClient) ACLDryRunCalls(stub func(context.Context, string, ...interface{}) *redisa.StringCmd) {
	fake.aCLDryRunMutex.Lock()
	defer fake.aCLDryRunMutex.Unlock()
	fake.ACLDryRunStub = stub
}

func (fake *FakeClient) ACLDryRunArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.aCLDryRunMutex.RLock()
	defer fake.aCLDryRunMutex.RUnlock()
	argsForCall := fake.aCLDryRunArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ACLDryRunReturns(result1 *redisa.StringCmd) {
	fake.aCLDryRunMutex.Lock()
	defer fake.aCLDryRunMutex.Unlock()
	fake.ACLDryRunStub = nil
	fake.aCLDryRunReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ACLDryRunReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.aCLDryRunMutex.Lock()
	defer fake.aCLDryRunMutex.Unlock()
	fake.ACLDryRunStub = nil
	if fake.aCLDryRunReturnsOnCall == nil {
		fake.aCLDryRunReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.aCLDryRunReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ACLLog(arg1 context.Context, arg2 int64) *redisa.ACLLogCmd {
	fake.aCLLogMutex.Lock()
	ret, specificReturn := fake.aCLLogReturnsOnCall[len(fake.aCLLogArgsForCall)]
	fake.aCLLogArgsForCall = append(fake.aCLLogArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.ACLLogStub
	fakeReturns := fake.aCLLogReturns
	fake.recordInvocation("ACLLog", []interface{}{arg1, arg2})
	fake.aCLLogMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ACLLogCallCount() int {
	fake.aCLLogMutex.RLock()
	defer fake.aCLLogMutex.RUnlock()
	return len(fake.aCLLogArgsForCall)
}

func (fake *FakeClient) ACLLogCalls(stub func(context.Context, int64) *redisa.ACLLogCmd) {
	fake.aCLLogMutex.Lock()
	defer fake.aCLLogMutex.Unlock()
	fake.ACLLogStub = stub
}

func (fake *FakeClient) ACLLogArgsForCall(i int) (context.Context, int64) {
	fake.aCLLogMutex.RLock()
	defer fake.aCLLogMutex.RUnlock()
	argsForCall := fake.aCLLogArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ACLLogReturns(result1 *redisa.ACLLogCmd) {
	fake.aCLLogMutex.Lock()
	defer fake.aCLLogMutex.Unlock()
	fake.ACLLogStub = nil
	fake.aCLLogReturns = struct {
		result1 *redisa.ACLLogCmd
	}{result1}
}

func (fake *FakeClient) ACLLogReturnsOnCall(i int, result1 *redisa.ACLLogCmd) {
	fake.aCLLogMutex.Lock()
	defer fake.aCLLogMutex.Unlock()
	fake.ACLLogStub = nil
	if fake.aCLLogReturnsOnCall == nil {
		fake.aCLLogReturnsOnCall = make(map[int]struct {
			result1 *redisa.ACLLogCmd
		})
	}
	fake.aCLLogReturnsOnCall[i] = struct {
		result1 *redisa.ACLLogCmd
	}{result1}
}

func (fake *FakeClient) ACLLogReset(arg1 context.Context) *redisa.StatusCmd {
	fake.aCLLogResetMutex.Lock()
	ret, specificReturn := fake.aCLLogResetReturnsOnCall[len(fake.aCLLogResetArgsForCall)]
	fake.aCLLogResetArgsForCall = append(fake.aCLLogResetArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ACLLogResetStub
	fakeReturns := fake.aCLLogResetReturns
	fake.recordInvocation("ACLLogReset", []interface{}{arg1})
	fake.aCLLogResetMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ACLLogResetCallCount() int {
	fake.aCLLogResetMutex.RLock()
	defer fake.aCLLogResetMutex.RUnlock()
	return len(fake.aCLLogResetArgsForCall)
}

func (fake *FakeClient) ACLLogResetCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.aCLLogResetMutex.Lock()
	defer fake.aCLLogResetMutex.Unlock()
	fake.ACLLogResetStub = stub
}

func (fake *FakeClient) ACLLogResetArgsForCall(i int) context.Context {
	fake.aCLLogResetMutex.RLock()
	defer fake.aCLLogResetMutex.RUnlock()
	argsForCall := fake.aCLLogResetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ACLLogResetReturns(result1 *redisa.StatusCmd) {
	fake.aCLLogResetMutex.Lock()
	defer fake.aCLLogResetMutex.Unlock()
	fake.ACLLogResetStub = nil
	fake.aCLLogResetReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ACLLogResetReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.aCLLogResetMutex.Lock()
	defer fake.aCLLogResetMutex.Unlock()
	fake.ACLLogResetStub = nil
	if fake.aCLLogResetReturnsOnCall == nil {
		fake.aCLLogResetReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.aCLLogResetReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) Append(arg1 context.Context, arg2 string, arg3 string) *redisa.IntCmd {
	fake.appendMutex.Lock()
	ret, specificReturn := fake.appendReturnsOnCall[len(fake.appendArgsForCall)]
	fake.appendArgsForCall = append(fake.appendArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AppendStub
	fakeReturns := fake.appendReturns
	fake.recordInvocation("Append", []interface{}{arg1, arg2, arg3})
	fake.appendMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) AppendCallCount() int {
	fake.appendMutex.RLock()
	defer fake.appendMutex.RUnlock()
	return len(fake.appendArgsForCall)
}

func (fake *FakeClient) AppendCalls(stub func(context.Context, string, string) *redisa.IntCmd) {
	fake.appendMutex.Lock()
	defer fake.appendMutex.Unlock()
	fake.AppendStub = stub
}

func (fake *FakeClient) AppendArgsForCall(i int) (context.Context, string, string) {
	fake.appendMutex.RLock()
	defer fake.appendMutex.RUnlock()
	argsForCall := fake.appendArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) AppendReturns(result1 *redisa.IntCmd) {
	fake.appendMutex.Lock()
	defer fake.appendMutex.Unlock()
	fake.AppendStub = nil
	fake.appendReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) AppendReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.appendMutex.Lock()
	defer fake.appendMutex.Unlock()
	fake.AppendStub = nil
	if fake.appendReturnsOnCall == nil {
		fake.appendReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.appendReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BFAdd(arg1 context.Context, arg2 string, arg3 interface{}) *redisa.BoolCmd {
	fake.bFAddMutex.Lock()
	ret, specificReturn := fake.bFAddReturnsOnCall[len(fake.bFAddArgsForCall)]
	fake.bFAddArgsForCall = append(fake.bFAddArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.BFAddStub
	fakeReturns := fake.bFAddReturns
	fake.recordInvocation("BFAdd", []interface{}{arg1, arg2, arg3})
	fake.bFAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFAddCallCount() int {
	fake.bFAddMutex.RLock()
	defer fake.bFAddMutex.RUnlock()
	return len(fake.bFAddArgsForCall)
}

func (fake *FakeClient) BFAddCalls(stub func(context.Context, string, interface{}) *redisa.BoolCmd) {
	fake.bFAddMutex.Lock()
	defer fake.bFAddMutex.Unlock()
	fake.BFAddStub = stub
}

func (fake *FakeClient) BFAddArgsForCall(i int) (context.Context, string, interface{}) {
	fake.bFAddMutex.RLock()
	defer fake.bFAddMutex.RUnlock()
	argsForCall := fake.bFAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BFAddReturns(result1 *redisa.BoolCmd) {
	fake.bFAddMutex.Lock()
	defer fake.bFAddMutex.Unlock()
	fake.BFAddStub = nil
	fake.bFAddReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) BFAddReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.bFAddMutex.Lock()
	defer fake.bFAddMutex.Unlock()
	fake.BFAddStub = nil
	if fake.bFAddReturnsOnCall == nil {
		fake.bFAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.bFAddReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) BFCard(arg1 context.Context, arg2 string) *redisa.IntCmd {
	fake.bFCardMutex.Lock()
	ret, specificReturn := fake.bFCardReturnsOnCall[len(fake.bFCardArgsForCall)]
	fake.bFCardArgsForCall = append(fake.bFCardArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.BFCardStub
	fakeReturns := fake.bFCardReturns
	fake.recordInvocation("BFCard", []interface{}{arg1, arg2})
	fake.bFCardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFCardCallCount() int {
	fake.bFCardMutex.RLock()
	defer fake.bFCardMutex.RUnlock()
	return len(fake.bFCardArgsForCall)
}

func (fake *FakeClient) BFCardCalls(stub func(context.Context, string) *redisa.IntCmd) {
	fake.bFCardMutex.Lock()
	defer fake.bFCardMutex.Unlock()
	fake.BFCardStub = stub
}

func (fake *FakeClient) BFCardArgsForCall(i int) (context.Context, string) {
	fake.bFCardMutex.RLock()
	defer fake.bFCardMutex.RUnlock()
	argsForCall := fake.bFCardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) BFCardReturns(result1 *redisa.IntCmd) {
	fake.bFCardMutex.Lock()
	defer fake.bFCardMutex.Unlock()
	fake.BFCardStub = nil
	fake.bFCardReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BFCardReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.bFCardMutex.Lock()
	defer fake.bFCardMutex.Unlock()
	fake.BFCardStub = nil
	if fake.bFCardReturnsOnCall == nil {
		fake.bFCardReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.bFCardReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BFExists(arg1 context.Context, arg2 string, arg3 interface{}) *redisa.BoolCmd {
	fake.bFExistsMutex.Lock()
	ret, specificReturn := fake.bFExistsReturnsOnCall[len(fake.bFExistsArgsForCall)]
	fake.bFExistsArgsForCall = append(fake.bFExistsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.BFExistsStub
	fakeReturns := fake.bFExistsReturns
	fake.recordInvocation("BFExists", []interface{}{arg1, arg2, arg3})
	fake.bFExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFExistsCallCount() int {
	fake.bFExistsMutex.RLock()
	defer fake.bFExistsMutex.RUnlock()
	return len(fake.bFExistsArgsForCall)
}

func (fake *FakeClient) BFExistsCalls(stub func(context.Context, string, interface{}) *redisa.BoolCmd) {
	fake.bFExistsMutex.Lock()
	defer fake.bFExistsMutex.Unlock()
	fake.BFExistsStub = stub
}

func (fake *FakeClient) BFExistsArgsForCall(i int) (context.Context, string, interface{}) {
	fake.bFExistsMutex.RLock()
	defer fake.bFExistsMutex.RUnlock()
	argsForCall := fake.bFExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BFExistsReturns(result1 *redisa.BoolCmd) {
	fake.bFExistsMutex.Lock()
	defer fake.bFExistsMutex.Unlock()
	fake.BFExistsStub = nil
	fake.bFExistsReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) BFExistsReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.bFExistsMutex.Lock()
	defer fake.bFExistsMutex.Unlock()
	fake.BFExistsStub = nil
	if fake.bFExistsReturnsOnCall == nil {
		fake.bFExistsReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.bFExistsReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) BFInfo(arg1 context.Context, arg2 string) *redisa.BFInfoCmd {
	fake.bFInfoMutex.Lock()
	ret, specificReturn := fake.bFInfoReturnsOnCall[len(fake.bFInfoArgsForCall)]
	fake.bFInfoArgsForCall = append(fake.bFInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.BFInfoStub
	fakeReturns := fake.bFInfoReturns
	fake.recordInvocation("BFInfo", []interface{}{arg1, arg2})
	fake.bFInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFInfoCallCount() int {
	fake.bFInfoMutex.RLock()
	defer fake.bFInfoMutex.RUnlock()
	return len(fake.bFInfoArgsForCall)
}

func (fake *FakeClient) BFInfoCalls(stub func(context.Context, string) *redisa.BFInfoCmd) {
	fake.bFInfoMutex.Lock()
	defer fake.bFInfoMutex.Unlock()
	fake.BFInfoStub = stub
}

func (fake *FakeClient) BFInfoArgsForCall(i int) (context.Context, string) {
	fake.bFInfoMutex.RLock()
	defer fake.bFInfoMutex.RUnlock()
	argsForCall := fake.bFInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) BFInfoReturns(result1 *redisa.BFInfoCmd) {
	fake.bFInfoMutex.Lock()
	defer fake.bFInfoMutex.Unlock()
	fake.BFInfoStub = nil
	fake.bFInfoReturns = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInfoReturnsOnCall(i int, result1 *redisa.BFInfoCmd) {
	fake.bFInfoMutex.Lock()
	defer fake.bFInfoMutex.Unlock()
	fake.BFInfoStub = nil
	if fake.bFInfoReturnsOnCall == nil {
		fake.bFInfoReturnsOnCall = make(map[int]struct {
			result1 *redisa.BFInfoCmd
		})
	}
	fake.bFInfoReturnsOnCall[i] = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInfoArg(arg1 context.Context, arg2 string, arg3 string) *redisa.BFInfoCmd {
	fake.bFInfoArgMutex.Lock()
	ret, specificReturn := fake.bFInfoArgReturnsOnCall[len(fake.bFInfoArgArgsForCall)]
	fake.bFInfoArgArgsForCall = append(fake.bFInfoArgArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.BFInfoArgStub
	fakeReturns := fake.bFInfoArgReturns
	fake.recordInvocation("BFInfoArg", []interface{}{arg1, arg2, arg3})
	fake.bFInfoArgMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFInfoArgCallCount() int {
	fake.bFInfoArgMutex.RLock()
	defer fake.bFInfoArgMutex.RUnlock()
	return len(fake.bFInfoArgArgsForCall)
}

func (fake *FakeClient) BFInfoArgCalls(stub func(context.Context, string, string) *redisa.BFInfoCmd) {
	fake.bFInfoArgMutex.Lock()
	defer fake.bFInfoArgMutex.Unlock()
	fake.BFInfoArgStub = stub
}

func (fake *FakeClient) BFInfoArgArgsForCall(i int) (context.Context, string, string) {
	fake.bFInfoArgMutex.RLock()
	defer fake.bFInfoArgMutex.RUnlock()
	argsForCall := fake.bFInfoArgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BFInfoArgReturns(result1 *redisa.BFInfoCmd) {
	fake.bFInfoArgMutex.Lock()
	defer fake.bFInfoArgMutex.Unlock()
	fake.BFInfoArgStub = nil
	fake.bFInfoArgReturns = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInfoArgReturnsOnCall(i int, result1 *redisa.BFInfoCmd) {
	fake.bFInfoArgMutex.Lock()
	defer fake.bFInfoArgMutex.Unlock()
	fake.BFInfoArgStub = nil
	if fake.bFInfoArgReturnsOnCall == nil {
		fake.bFInfoArgReturnsOnCall = make(map[int]struct {
			result1 *redisa.BFInfoCmd
		})
	}
	fake.bFInfoArgReturnsOnCall[i] = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInfoCapacity(arg1 context.Context, arg2 string) *redisa.BFInfoCmd {
	fake.bFInfoCapacityMutex.Lock()
	ret, specificReturn := fake.bFInfoCapacityReturnsOnCall[len(fake.bFInfoCapacityArgsForCall)]
	fake.bFInfoCapacityArgsForCall = append(fake.bFInfoCapacityArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.BFInfoCapacityStub
	fakeReturns := fake.bFInfoCapacityReturns
	fake.recordInvocation("BFInfoCapacity", []interface{}{arg1, arg2})
	fake.bFInfoCapacityMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFInfoCapacityCallCount() int {
	fake.bFInfoCapacityMutex.RLock()
	defer fake.bFInfoCapacityMutex.RUnlock()
	return len(fake.bFInfoCapacityArgsForCall)
}

func (fake *FakeClient) BFInfoCapacityCalls(stub func(context.Context, string) *redisa.BFInfoCmd) {
	fake.bFInfoCapacityMutex.Lock()
	defer fake.bFInfoCapacityMutex.Unlock()
	fake.BFInfoCapacityStub = stub
}

func (fake *FakeClient) BFInfoCapacityArgsForCall(i int) (context.Context, string) {
	fake.bFInfoCapacityMutex.RLock()
	defer fake.bFInfoCapacityMutex.RUnlock()
	argsForCall := fake.bFInfoCapacityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) BFInfoCapacityReturns(result1 *redisa.BFInfoCmd) {
	fake.bFInfoCapacityMutex.Lock()
	defer fake.bFInfoCapacityMutex.Unlock()
	fake.BFInfoCapacityStub = nil
	fake.bFInfoCapacityReturns = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInfoCapacityReturnsOnCall(i int, result1 *redisa.BFInfoCmd) {
	fake.bFInfoCapacityMutex.Lock()
	defer fake.bFInfoCapacityMutex.Unlock()
	fake.BFInfoCapacityStub = nil
	if fake.bFInfoCapacityReturnsOnCall == nil {
		fake.bFInfoCapacityReturnsOnCall = make(map[int]struct {
			result1 *redisa.BFInfoCmd
		})
	}
	fake.bFInfoCapacityReturnsOnCall[i] = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInfoExpansion(arg1 context.Context, arg2 string) *redisa.BFInfoCmd {
	fake.bFInfoExpansionMutex.Lock()
	ret, specificReturn := fake.bFInfoExpansionReturnsOnCall[len(fake.bFInfoExpansionArgsForCall)]
	fake.bFInfoExpansionArgsForCall = append(fake.bFInfoExpansionArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.BFInfoExpansionStub
	fakeReturns := fake.bFInfoExpansionReturns
	fake.recordInvocation("BFInfoExpansion", []interface{}{arg1, arg2})
	fake.bFInfoExpansionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFInfoExpansionCallCount() int {
	fake.bFInfoExpansionMutex.RLock()
	defer fake.bFInfoExpansionMutex.RUnlock()
	return len(fake.bFInfoExpansionArgsForCall)
}

func (fake *FakeClient) BFInfoExpansionCalls(stub func(context.Context, string) *redisa.BFInfoCmd) {
	fake.bFInfoExpansionMutex.Lock()
	defer fake.bFInfoExpansionMutex.Unlock()
	fake.BFInfoExpansionStub = stub
}

func (fake *FakeClient) BFInfoExpansionArgsForCall(i int) (context.Context, string) {
	fake.bFInfoExpansionMutex.RLock()
	defer fake.bFInfoExpansionMutex.RUnlock()
	argsForCall := fake.bFInfoExpansionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) BFInfoExpansionReturns(result1 *redisa.BFInfoCmd) {
	fake.bFInfoExpansionMutex.Lock()
	defer fake.bFInfoExpansionMutex.Unlock()
	fake.BFInfoExpansionStub = nil
	fake.bFInfoExpansionReturns = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInfoExpansionReturnsOnCall(i int, result1 *redisa.BFInfoCmd) {
	fake.bFInfoExpansionMutex.Lock()
	defer fake.bFInfoExpansionMutex.Unlock()
	fake.BFInfoExpansionStub = nil
	if fake.bFInfoExpansionReturnsOnCall == nil {
		fake.bFInfoExpansionReturnsOnCall = make(map[int]struct {
			result1 *redisa.BFInfoCmd
		})
	}
	fake.bFInfoExpansionReturnsOnCall[i] = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInfoFilters(arg1 context.Context, arg2 string) *redisa.BFInfoCmd {
	fake.bFInfoFiltersMutex.Lock()
	ret, specificReturn := fake.bFInfoFiltersReturnsOnCall[len(fake.bFInfoFiltersArgsForCall)]
	fake.bFInfoFiltersArgsForCall = append(fake.bFInfoFiltersArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.BFInfoFiltersStub
	fakeReturns := fake.bFInfoFiltersReturns
	fake.recordInvocation("BFInfoFilters", []interface{}{arg1, arg2})
	fake.bFInfoFiltersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFInfoFiltersCallCount() int {
	fake.bFInfoFiltersMutex.RLock()
	defer fake.bFInfoFiltersMutex.RUnlock()
	return len(fake.bFInfoFiltersArgsForCall)
}

func (fake *FakeClient) BFInfoFiltersCalls(stub func(context.Context, string) *redisa.BFInfoCmd) {
	fake.bFInfoFiltersMutex.Lock()
	defer fake.bFInfoFiltersMutex.Unlock()
	fake.BFInfoFiltersStub = stub
}

func (fake *FakeClient) BFInfoFiltersArgsForCall(i int) (context.Context, string) {
	fake.bFInfoFiltersMutex.RLock()
	defer fake.bFInfoFiltersMutex.RUnlock()
	argsForCall := fake.bFInfoFiltersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) BFInfoFiltersReturns(result1 *redisa.BFInfoCmd) {
	fake.bFInfoFiltersMutex.Lock()
	defer fake.bFInfoFiltersMutex.Unlock()
	fake.BFInfoFiltersStub = nil
	fake.bFInfoFiltersReturns = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInfoFiltersReturnsOnCall(i int, result1 *redisa.BFInfoCmd) {
	fake.bFInfoFiltersMutex.Lock()
	defer fake.bFInfoFiltersMutex.Unlock()
	fake.BFInfoFiltersStub = nil
	if fake.bFInfoFiltersReturnsOnCall == nil {
		fake.bFInfoFiltersReturnsOnCall = make(map[int]struct {
			result1 *redisa.BFInfoCmd
		})
	}
	fake.bFInfoFiltersReturnsOnCall[i] = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInfoItems(arg1 context.Context, arg2 string) *redisa.BFInfoCmd {
	fake.bFInfoItemsMutex.Lock()
	ret, specificReturn := fake.bFInfoItemsReturnsOnCall[len(fake.bFInfoItemsArgsForCall)]
	fake.bFInfoItemsArgsForCall = append(fake.bFInfoItemsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.BFInfoItemsStub
	fakeReturns := fake.bFInfoItemsReturns
	fake.recordInvocation("BFInfoItems", []interface{}{arg1, arg2})
	fake.bFInfoItemsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFInfoItemsCallCount() int {
	fake.bFInfoItemsMutex.RLock()
	defer fake.bFInfoItemsMutex.RUnlock()
	return len(fake.bFInfoItemsArgsForCall)
}

func (fake *FakeClient) BFInfoItemsCalls(stub func(context.Context, string) *redisa.BFInfoCmd) {
	fake.bFInfoItemsMutex.Lock()
	defer fake.bFInfoItemsMutex.Unlock()
	fake.BFInfoItemsStub = stub
}

func (fake *FakeClient) BFInfoItemsArgsForCall(i int) (context.Context, string) {
	fake.bFInfoItemsMutex.RLock()
	defer fake.bFInfoItemsMutex.RUnlock()
	argsForCall := fake.bFInfoItemsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) BFInfoItemsReturns(result1 *redisa.BFInfoCmd) {
	fake.bFInfoItemsMutex.Lock()
	defer fake.bFInfoItemsMutex.Unlock()
	fake.BFInfoItemsStub = nil
	fake.bFInfoItemsReturns = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInfoItemsReturnsOnCall(i int, result1 *redisa.BFInfoCmd) {
	fake.bFInfoItemsMutex.Lock()
	defer fake.bFInfoItemsMutex.Unlock()
	fake.BFInfoItemsStub = nil
	if fake.bFInfoItemsReturnsOnCall == nil {
		fake.bFInfoItemsReturnsOnCall = make(map[int]struct {
			result1 *redisa.BFInfoCmd
		})
	}
	fake.bFInfoItemsReturnsOnCall[i] = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInfoSize(arg1 context.Context, arg2 string) *redisa.BFInfoCmd {
	fake.bFInfoSizeMutex.Lock()
	ret, specificReturn := fake.bFInfoSizeReturnsOnCall[len(fake.bFInfoSizeArgsForCall)]
	fake.bFInfoSizeArgsForCall = append(fake.bFInfoSizeArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.BFInfoSizeStub
	fakeReturns := fake.bFInfoSizeReturns
	fake.recordInvocation("BFInfoSize", []interface{}{arg1, arg2})
	fake.bFInfoSizeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFInfoSizeCallCount() int {
	fake.bFInfoSizeMutex.RLock()
	defer fake.bFInfoSizeMutex.RUnlock()
	return len(fake.bFInfoSizeArgsForCall)
}

func (fake *FakeClient) BFInfoSizeCalls(stub func(context.Context, string) *redisa.BFInfoCmd) {
	fake.bFInfoSizeMutex.Lock()
	defer fake.bFInfoSizeMutex.Unlock()
	fake.BFInfoSizeStub = stub
}

func (fake *FakeClient) BFInfoSizeArgsForCall(i int) (context.Context, string) {
	fake.bFInfoSizeMutex.RLock()
	defer fake.bFInfoSizeMutex.RUnlock()
	argsForCall := fake.bFInfoSizeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) BFInfoSizeReturns(result1 *redisa.BFInfoCmd) {
	fake.bFInfoSizeMutex.Lock()
	defer fake.bFInfoSizeMutex.Unlock()
	fake.BFInfoSizeStub = nil
	fake.bFInfoSizeReturns = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInfoSizeReturnsOnCall(i int, result1 *redisa.BFInfoCmd) {
	fake.bFInfoSizeMutex.Lock()
	defer fake.bFInfoSizeMutex.Unlock()
	fake.BFInfoSizeStub = nil
	if fake.bFInfoSizeReturnsOnCall == nil {
		fake.bFInfoSizeReturnsOnCall = make(map[int]struct {
			result1 *redisa.BFInfoCmd
		})
	}
	fake.bFInfoSizeReturnsOnCall[i] = struct {
		result1 *redisa.BFInfoCmd
	}{result1}
}

func (fake *FakeClient) BFInsert(arg1 context.Context, arg2 string, arg3 *redisa.BFInsertOptions, arg4 ...interface{}) *redisa.BoolSliceCmd {
	fake.bFInsertMutex.Lock()
	ret, specificReturn := fake.bFInsertReturnsOnCall[len(fake.bFInsertArgsForCall)]
	fake.bFInsertArgsForCall = append(fake.bFInsertArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.BFInsertOptions
		arg4 []interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.BFInsertStub
	fakeReturns := fake.bFInsertReturns
	fake.recordInvocation("BFInsert", []interface{}{arg1, arg2, arg3, arg4})
	fake.bFInsertMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFInsertCallCount() int {
	fake.bFInsertMutex.RLock()
	defer fake.bFInsertMutex.RUnlock()
	return len(fake.bFInsertArgsForCall)
}

func (fake *FakeClient) BFInsertCalls(stub func(context.Context, string, *redisa.BFInsertOptions, ...interface{}) *redisa.BoolSliceCmd) {
	fake.bFInsertMutex.Lock()
	defer fake.bFInsertMutex.Unlock()
	fake.BFInsertStub = stub
}

func (fake *FakeClient) BFInsertArgsForCall(i int) (context.Context, string, *redisa.BFInsertOptions, []interface{}) {
	fake.bFInsertMutex.RLock()
	defer fake.bFInsertMutex.RUnlock()
	argsForCall := fake.bFInsertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) BFInsertReturns(result1 *redisa.BoolSliceCmd) {
	fake.bFInsertMutex.Lock()
	defer fake.bFInsertMutex.Unlock()
	fake.BFInsertStub = nil
	fake.bFInsertReturns = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) BFInsertReturnsOnCall(i int, result1 *redisa.BoolSliceCmd) {
	fake.bFInsertMutex.Lock()
	defer fake.bFInsertMutex.Unlock()
	fake.BFInsertStub = nil
	if fake.bFInsertReturnsOnCall == nil {
		fake.bFInsertReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolSliceCmd
		})
	}
	fake.bFInsertReturnsOnCall[i] = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) BFLoadChunk(arg1 context.Context, arg2 string, arg3 int64, arg4 interface{}) *redisa.StatusCmd {
	fake.bFLoadChunkMutex.Lock()
	ret, specificReturn := fake.bFLoadChunkReturnsOnCall[len(fake.bFLoadChunkArgsForCall)]
	fake.bFLoadChunkArgsForCall = append(fake.bFLoadChunkArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.BFLoadChunkStub
	fakeReturns := fake.bFLoadChunkReturns
	fake.recordInvocation("BFLoadChunk", []interface{}{arg1, arg2, arg3, arg4})
	fake.bFLoadChunkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFLoadChunkCallCount() int {
	fake.bFLoadChunkMutex.RLock()
	defer fake.bFLoadChunkMutex.RUnlock()
	return len(fake.bFLoadChunkArgsForCall)
}

func (fake *FakeClient) BFLoadChunkCalls(stub func(context.Context, string, int64, interface{}) *redisa.StatusCmd) {
	fake.bFLoadChunkMutex.Lock()
	defer fake.bFLoadChunkMutex.Unlock()
	fake.BFLoadChunkStub = stub
}

func (fake *FakeClient) BFLoadChunkArgsForCall(i int) (context.Context, string, int64, interface{}) {
	fake.bFLoadChunkMutex.RLock()
	defer fake.bFLoadChunkMutex.RUnlock()
	argsForCall := fake.bFLoadChunkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) BFLoadChunkReturns(result1 *redisa.StatusCmd) {
	fake.bFLoadChunkMutex.Lock()
	defer fake.bFLoadChunkMutex.Unlock()
	fake.BFLoadChunkStub = nil
	fake.bFLoadChunkReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BFLoadChunkReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.bFLoadChunkMutex.Lock()
	defer fake.bFLoadChunkMutex.Unlock()
	fake.BFLoadChunkStub = nil
	if fake.bFLoadChunkReturnsOnCall == nil {
		fake.bFLoadChunkReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.bFLoadChunkReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BFMAdd(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.BoolSliceCmd {
	fake.bFMAddMutex.Lock()
	ret, specificReturn := fake.bFMAddReturnsOnCall[len(fake.bFMAddArgsForCall)]
	fake.bFMAddArgsForCall = append(fake.bFMAddArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.BFMAddStub
	fakeReturns := fake.bFMAddReturns
	fake.recordInvocation("BFMAdd", []interface{}{arg1, arg2, arg3})
	fake.bFMAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFMAddCallCount() int {
	fake.bFMAddMutex.RLock()
	defer fake.bFMAddMutex.RUnlock()
	return len(fake.bFMAddArgsForCall)
}

func (fake *FakeClient) BFMAddCalls(stub func(context.Context, string, ...interface{}) *redisa.BoolSliceCmd) {
	fake.bFMAddMutex.Lock()
	defer fake.bFMAddMutex.Unlock()
	fake.BFMAddStub = stub
}

func (fake *FakeClient) BFMAddArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.bFMAddMutex.RLock()
	defer fake.bFMAddMutex.RUnlock()
	argsForCall := fake.bFMAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BFMAddReturns(result1 *redisa.BoolSliceCmd) {
	fake.bFMAddMutex.Lock()
	defer fake.bFMAddMutex.Unlock()
	fake.BFMAddStub = nil
	fake.bFMAddReturns = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) BFMAddReturnsOnCall(i int, result1 *redisa.BoolSliceCmd) {
	fake.bFMAddMutex.Lock()
	defer fake.bFMAddMutex.Unlock()
	fake.BFMAddStub = nil
	if fake.bFMAddReturnsOnCall == nil {
		fake.bFMAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolSliceCmd
		})
	}
	fake.bFMAddReturnsOnCall[i] = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) BFMExists(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.BoolSliceCmd {
	fake.bFMExistsMutex.Lock()
	ret, specificReturn := fake.bFMExistsReturnsOnCall[len(fake.bFMExistsArgsForCall)]
	fake.bFMExistsArgsForCall = append(fake.bFMExistsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.BFMExistsStub
	fakeReturns := fake.bFMExistsReturns
	fake.recordInvocation("BFMExists", []interface{}{arg1, arg2, arg3})
	fake.bFMExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFMExistsCallCount() int {
	fake.bFMExistsMutex.RLock()
	defer fake.bFMExistsMutex.RUnlock()
	return len(fake.bFMExistsArgsForCall)
}

func (fake *FakeClient) BFMExistsCalls(stub func(context.Context, string, ...interface{}) *redisa.BoolSliceCmd) {
	fake.bFMExistsMutex.Lock()
	defer fake.bFMExistsMutex.Unlock()
	fake.BFMExistsStub = stub
}

func (fake *FakeClient) BFMExistsArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.bFMExistsMutex.RLock()
	defer fake.bFMExistsMutex.RUnlock()
	argsForCall := fake.bFMExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BFMExistsReturns(result1 *redisa.BoolSliceCmd) {
	fake.bFMExistsMutex.Lock()
	defer fake.bFMExistsMutex.Unlock()
	fake.BFMExistsStub = nil
	fake.bFMExistsReturns = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) BFMExistsReturnsOnCall(i int, result1 *redisa.BoolSliceCmd) {
	fake.bFMExistsMutex.Lock()
	defer fake.bFMExistsMutex.Unlock()
	fake.BFMExistsStub = nil
	if fake.bFMExistsReturnsOnCall == nil {
		fake.bFMExistsReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolSliceCmd
		})
	}
	fake.bFMExistsReturnsOnCall[i] = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) BFReserve(arg1 context.Context, arg2 string, arg3 float64, arg4 int64) *redisa.StatusCmd {
	fake.bFReserveMutex.Lock()
	ret, specificReturn := fake.bFReserveReturnsOnCall[len(fake.bFReserveArgsForCall)]
	fake.bFReserveArgsForCall = append(fake.bFReserveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.BFReserveStub
	fakeReturns := fake.bFReserveReturns
	fake.recordInvocation("BFReserve", []interface{}{arg1, arg2, arg3, arg4})
	fake.bFReserveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFReserveCallCount() int {
	fake.bFReserveMutex.RLock()
	defer fake.bFReserveMutex.RUnlock()
	return len(fake.bFReserveArgsForCall)
}

func (fake *FakeClient) BFReserveCalls(stub func(context.Context, string, float64, int64) *redisa.StatusCmd) {
	fake.bFReserveMutex.Lock()
	defer fake.bFReserveMutex.Unlock()
	fake.BFReserveStub = stub
}

func (fake *FakeClient) BFReserveArgsForCall(i int) (context.Context, string, float64, int64) {
	fake.bFReserveMutex.RLock()
	defer fake.bFReserveMutex.RUnlock()
	argsForCall := fake.bFReserveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) BFReserveReturns(result1 *redisa.StatusCmd) {
	fake.bFReserveMutex.Lock()
	defer fake.bFReserveMutex.Unlock()
	fake.BFReserveStub = nil
	fake.bFReserveReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BFReserveReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.bFReserveMutex.Lock()
	defer fake.bFReserveMutex.Unlock()
	fake.BFReserveStub = nil
	if fake.bFReserveReturnsOnCall == nil {
		fake.bFReserveReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.bFReserveReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BFReserveExpansion(arg1 context.Context, arg2 string, arg3 float64, arg4 int64, arg5 int64) *redisa.StatusCmd {
	fake.bFReserveExpansionMutex.Lock()
	ret, specificReturn := fake.bFReserveExpansionReturnsOnCall[len(fake.bFReserveExpansionArgsForCall)]
	fake.bFReserveExpansionArgsForCall = append(fake.bFReserveExpansionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 int64
		arg5 int64
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.BFReserveExpansionStub
	fakeReturns := fake.bFReserveExpansionReturns
	fake.recordInvocation("BFReserveExpansion", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.bFReserveExpansionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFReserveExpansionCallCount() int {
	fake.bFReserveExpansionMutex.RLock()
	defer fake.bFReserveExpansionMutex.RUnlock()
	return len(fake.bFReserveExpansionArgsForCall)
}

func (fake *FakeClient) BFReserveExpansionCalls(stub func(context.Context, string, float64, int64, int64) *redisa.StatusCmd) {
	fake.bFReserveExpansionMutex.Lock()
	defer fake.bFReserveExpansionMutex.Unlock()
	fake.BFReserveExpansionStub = stub
}

func (fake *FakeClient) BFReserveExpansionArgsForCall(i int) (context.Context, string, float64, int64, int64) {
	fake.bFReserveExpansionMutex.RLock()
	defer fake.bFReserveExpansionMutex.RUnlock()
	argsForCall := fake.bFReserveExpansionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) BFReserveExpansionReturns(result1 *redisa.StatusCmd) {
	fake.bFReserveExpansionMutex.Lock()
	defer fake.bFReserveExpansionMutex.Unlock()
	fake.BFReserveExpansionStub = nil
	fake.bFReserveExpansionReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BFReserveExpansionReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.bFReserveExpansionMutex.Lock()
	defer fake.bFReserveExpansionMutex.Unlock()
	fake.BFReserveExpansionStub = nil
	if fake.bFReserveExpansionReturnsOnCall == nil {
		fake.bFReserveExpansionReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.bFReserveExpansionReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BFReserveNonScaling(arg1 context.Context, arg2 string, arg3 float64, arg4 int64) *redisa.StatusCmd {
	fake.bFReserveNonScalingMutex.Lock()
	ret, specificReturn := fake.bFReserveNonScalingReturnsOnCall[len(fake.bFReserveNonScalingArgsForCall)]
	fake.bFReserveNonScalingArgsForCall = append(fake.bFReserveNonScalingArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.BFReserveNonScalingStub
	fakeReturns := fake.bFReserveNonScalingReturns
	fake.recordInvocation("BFReserveNonScaling", []interface{}{arg1, arg2, arg3, arg4})
	fake.bFReserveNonScalingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFReserveNonScalingCallCount() int {
	fake.bFReserveNonScalingMutex.RLock()
	defer fake.bFReserveNonScalingMutex.RUnlock()
	return len(fake.bFReserveNonScalingArgsForCall)
}

func (fake *FakeClient) BFReserveNonScalingCalls(stub func(context.Context, string, float64, int64) *redisa.StatusCmd) {
	fake.bFReserveNonScalingMutex.Lock()
	defer fake.bFReserveNonScalingMutex.Unlock()
	fake.BFReserveNonScalingStub = stub
}

func (fake *FakeClient) BFReserveNonScalingArgsForCall(i int) (context.Context, string, float64, int64) {
	fake.bFReserveNonScalingMutex.RLock()
	defer fake.bFReserveNonScalingMutex.RUnlock()
	argsForCall := fake.bFReserveNonScalingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) BFReserveNonScalingReturns(result1 *redisa.StatusCmd) {
	fake.bFReserveNonScalingMutex.Lock()
	defer fake.bFReserveNonScalingMutex.Unlock()
	fake.BFReserveNonScalingStub = nil
	fake.bFReserveNonScalingReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BFReserveNonScalingReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.bFReserveNonScalingMutex.Lock()
	defer fake.bFReserveNonScalingMutex.Unlock()
	fake.BFReserveNonScalingStub = nil
	if fake.bFReserveNonScalingReturnsOnCall == nil {
		fake.bFReserveNonScalingReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.bFReserveNonScalingReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BFReserveWithArgs(arg1 context.Context, arg2 string, arg3 *redisa.BFReserveOptions) *redisa.StatusCmd {
	fake.bFReserveWithArgsMutex.Lock()
	ret, specificReturn := fake.bFReserveWithArgsReturnsOnCall[len(fake.bFReserveWithArgsArgsForCall)]
	fake.bFReserveWithArgsArgsForCall = append(fake.bFReserveWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.BFReserveOptions
	}{arg1, arg2, arg3})
	stub := fake.BFReserveWithArgsStub
	fakeReturns := fake.bFReserveWithArgsReturns
	fake.recordInvocation("BFReserveWithArgs", []interface{}{arg1, arg2, arg3})
	fake.bFReserveWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFReserveWithArgsCallCount() int {
	fake.bFReserveWithArgsMutex.RLock()
	defer fake.bFReserveWithArgsMutex.RUnlock()
	return len(fake.bFReserveWithArgsArgsForCall)
}

func (fake *FakeClient) BFReserveWithArgsCalls(stub func(context.Context, string, *redisa.BFReserveOptions) *redisa.StatusCmd) {
	fake.bFReserveWithArgsMutex.Lock()
	defer fake.bFReserveWithArgsMutex.Unlock()
	fake.BFReserveWithArgsStub = stub
}

func (fake *FakeClient) BFReserveWithArgsArgsForCall(i int) (context.Context, string, *redisa.BFReserveOptions) {
	fake.bFReserveWithArgsMutex.RLock()
	defer fake.bFReserveWithArgsMutex.RUnlock()
	argsForCall := fake.bFReserveWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BFReserveWithArgsReturns(result1 *redisa.StatusCmd) {
	fake.bFReserveWithArgsMutex.Lock()
	defer fake.bFReserveWithArgsMutex.Unlock()
	fake.BFReserveWithArgsStub = nil
	fake.bFReserveWithArgsReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BFReserveWithArgsReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.bFReserveWithArgsMutex.Lock()
	defer fake.bFReserveWithArgsMutex.Unlock()
	fake.BFReserveWithArgsStub = nil
	if fake.bFReserveWithArgsReturnsOnCall == nil {
		fake.bFReserveWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.bFReserveWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BFScanDump(arg1 context.Context, arg2 string, arg3 int64) *redisa.ScanDumpCmd {
	fake.bFScanDumpMutex.Lock()
	ret, specificReturn := fake.bFScanDumpReturnsOnCall[len(fake.bFScanDumpArgsForCall)]
	fake.bFScanDumpArgsForCall = append(fake.bFScanDumpArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.BFScanDumpStub
	fakeReturns := fake.bFScanDumpReturns
	fake.recordInvocation("BFScanDump", []interface{}{arg1, arg2, arg3})
	fake.bFScanDumpMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BFScanDumpCallCount() int {
	fake.bFScanDumpMutex.RLock()
	defer fake.bFScanDumpMutex.RUnlock()
	return len(fake.bFScanDumpArgsForCall)
}

func (fake *FakeClient) BFScanDumpCalls(stub func(context.Context, string, int64) *redisa.ScanDumpCmd) {
	fake.bFScanDumpMutex.Lock()
	defer fake.bFScanDumpMutex.Unlock()
	fake.BFScanDumpStub = stub
}

func (fake *FakeClient) BFScanDumpArgsForCall(i int) (context.Context, string, int64) {
	fake.bFScanDumpMutex.RLock()
	defer fake.bFScanDumpMutex.RUnlock()
	argsForCall := fake.bFScanDumpArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BFScanDumpReturns(result1 *redisa.ScanDumpCmd) {
	fake.bFScanDumpMutex.Lock()
	defer fake.bFScanDumpMutex.Unlock()
	fake.BFScanDumpStub = nil
	fake.bFScanDumpReturns = struct {
		result1 *redisa.ScanDumpCmd
	}{result1}
}

func (fake *FakeClient) BFScanDumpReturnsOnCall(i int, result1 *redisa.ScanDumpCmd) {
	fake.bFScanDumpMutex.Lock()
	defer fake.bFScanDumpMutex.Unlock()
	fake.BFScanDumpStub = nil
	if fake.bFScanDumpReturnsOnCall == nil {
		fake.bFScanDumpReturnsOnCall = make(map[int]struct {
			result1 *redisa.ScanDumpCmd
		})
	}
	fake.bFScanDumpReturnsOnCall[i] = struct {
		result1 *redisa.ScanDumpCmd
	}{result1}
}

func (fake *FakeClient) BLMPop(arg1 context.Context, arg2 time.Duration, arg3 string, arg4 int64, arg5 ...string) *redisa.KeyValuesCmd {
	fake.bLMPopMutex.Lock()
	ret, specificReturn := fake.bLMPopReturnsOnCall[len(fake.bLMPopArgsForCall)]
	fake.bLMPopArgsForCall = append(fake.bLMPopArgsForCall, struct {
		arg1 context.Context
		arg2 time.Duration
		arg3 string
		arg4 int64
		arg5 []string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.BLMPopStub
	fakeReturns := fake.bLMPopReturns
	fake.recordInvocation("BLMPop", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.bLMPopMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BLMPopCallCount() int {
	fake.bLMPopMutex.RLock()
	defer fake.bLMPopMutex.RUnlock()
	return len(fake.bLMPopArgsForCall)
}

func (fake *FakeClient) BLMPopCalls(stub func(context.Context, time.Duration, string, int64, ...string) *redisa.KeyValuesCmd) {
	fake.bLMPopMutex.Lock()
	defer fake.bLMPopMutex.Unlock()
	fake.BLMPopStub = stub
}

func (fake *FakeClient) BLMPopArgsForCall(i int) (context.Context, time.Duration, string, int64, []string) {
	fake.bLMPopMutex.RLock()
	defer fake.bLMPopMutex.RUnlock()
	argsForCall := fake.bLMPopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) BLMPopReturns(result1 *redisa.KeyValuesCmd) {
	fake.bLMPopMutex.Lock()
	defer fake.bLMPopMutex.Unlock()
	fake.BLMPopStub = nil
	fake.bLMPopReturns = struct {
		result1 *redisa.KeyValuesCmd
	}{result1}
}

func (fake *FakeClient) BLMPopReturnsOnCall(i int, result1 *redisa.KeyValuesCmd) {
	fake.bLMPopMutex.Lock()
	defer fake.bLMPopMutex.Unlock()
	fake.BLMPopStub = nil
	if fake.bLMPopReturnsOnCall == nil {
		fake.bLMPopReturnsOnCall = make(map[int]struct {
			result1 *redisa.KeyValuesCmd
		})
	}
	fake.bLMPopReturnsOnCall[i] = struct {
		result1 *redisa.KeyValuesCmd
	}{result1}
}

func (fake *FakeClient) BLMove(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 time.Duration) *redisa.StringCmd {
	fake.bLMoveMutex.Lock()
	ret, specificReturn := fake.bLMoveReturnsOnCall[len(fake.bLMoveArgsForCall)]
	fake.bLMoveArgsForCall = append(fake.bLMoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 time.Duration
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.BLMoveStub
	fakeReturns := fake.bLMoveReturns
	fake.recordInvocation("BLMove", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.bLMoveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BLMoveCallCount() int {
	fake.bLMoveMutex.RLock()
	defer fake.bLMoveMutex.RUnlock()
	return len(fake.bLMoveArgsForCall)
}

func (fake *FakeClient) BLMoveCalls(stub func(context.Context, string, string, string, string, time.Duration) *redisa.StringCmd) {
	fake.bLMoveMutex.Lock()
	defer fake.bLMoveMutex.Unlock()
	fake.BLMoveStub = stub
}

func (fake *FakeClient) BLMoveArgsForCall(i int) (context.Context, string, string, string, string, time.Duration) {
	fake.bLMoveMutex.RLock()
	defer fake.bLMoveMutex.RUnlock()
	argsForCall := fake.bLMoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeClient) BLMoveReturns(result1 *redisa.StringCmd) {
	fake.bLMoveMutex.Lock()
	defer fake.bLMoveMutex.Unlock()
	fake.BLMoveStub = nil
	fake.bLMoveReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) BLMoveReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.bLMoveMutex.Lock()
	defer fake.bLMoveMutex.Unlock()
	fake.BLMoveStub = nil
	if fake.bLMoveReturnsOnCall == nil {
		fake.bLMoveReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.bLMoveReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) BLPop(arg1 context.Context, arg2 time.Duration, arg3 ...string) *redisa.StringSliceCmd {
	fake.bLPopMutex.Lock()
	ret, specificReturn := fake.bLPopReturnsOnCall[len(fake.bLPopArgsForCall)]
	fake.bLPopArgsForCall = append(fake.bLPopArgsForCall, struct {
		arg1 context.Context
		arg2 time.Duration
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.BLPopStub
	fakeReturns := fake.bLPopReturns
	fake.recordInvocation("BLPop", []interface{}{arg1, arg2, arg3})
	fake.bLPopMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BLPopCallCount() int {
	fake.bLPopMutex.RLock()
	defer fake.bLPopMutex.RUnlock()
	return len(fake.bLPopArgsForCall)
}

func (fake *FakeClient) BLPopCalls(stub func(context.Context, time.Duration, ...string) *redisa.StringSliceCmd) {
	fake.bLPopMutex.Lock()
	defer fake.bLPopMutex.Unlock()
	fake.BLPopStub = stub
}

func (fake *FakeClient) BLPopArgsForCall(i int) (context.Context, time.Duration, []string) {
	fake.bLPopMutex.RLock()
	defer fake.bLPopMutex.RUnlock()
	argsForCall := fake.bLPopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BLPopReturns(result1 *redisa.StringSliceCmd) {
	fake.bLPopMutex.Lock()
	defer fake.bLPopMutex.Unlock()
	fake.BLPopStub = nil
	fake.bLPopReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) BLPopReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.bLPopMutex.Lock()
	defer fake.bLPopMutex.Unlock()
	fake.BLPopStub = nil
	if fake.bLPopReturnsOnCall == nil {
		fake.bLPopReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.bLPopReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) BRPop(arg1 context.Context, arg2 time.Duration, arg3 ...string) *redisa.StringSliceCmd {
	fake.bRPopMutex.Lock()
	ret, specificReturn := fake.bRPopReturnsOnCall[len(fake.bRPopArgsForCall)]
	fake.bRPopArgsForCall = append(fake.bRPopArgsForCall, struct {
		arg1 context.Context
		arg2 time.Duration
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.BRPopStub
	fakeReturns := fake.bRPopReturns
	fake.recordInvocation("BRPop", []interface{}{arg1, arg2, arg3})
	fake.bRPopMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BRPopCallCount() int {
	fake.bRPopMutex.RLock()
	defer fake.bRPopMutex.RUnlock()
	return len(fake.bRPopArgsForCall)
}

func (fake *FakeClient) BRPopCalls(stub func(context.Context, time.Duration, ...string) *redisa.StringSliceCmd) {
	fake.bRPopMutex.Lock()
	defer fake.bRPopMutex.Unlock()
	fake.BRPopStub = stub
}

func (fake *FakeClient) BRPopArgsForCall(i int) (context.Context, time.Duration, []string) {
	fake.bRPopMutex.RLock()
	defer fake.bRPopMutex.RUnlock()
	argsForCall := fake.bRPopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BRPopReturns(result1 *redisa.StringSliceCmd) {
	fake.bRPopMutex.Lock()
	defer fake.bRPopMutex.Unlock()
	fake.BRPopStub = nil
	fake.bRPopReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) BRPopReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.bRPopMutex.Lock()
	defer fake.bRPopMutex.Unlock()
	fake.BRPopStub = nil
	if fake.bRPopReturnsOnCall == nil {
		fake.bRPopReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.bRPopReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) BRPopLPush(arg1 context.Context, arg2 string, arg3 string, arg4 time.Duration) *redisa.StringCmd {
	fake.bRPopLPushMutex.Lock()
	ret, specificReturn := fake.bRPopLPushReturnsOnCall[len(fake.bRPopLPushArgsForCall)]
	fake.bRPopLPushArgsForCall = append(fake.bRPopLPushArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 time.Duration
	}{arg1, arg2, arg3, arg4})
	stub := fake.BRPopLPushStub
	fakeReturns := fake.bRPopLPushReturns
	fake.recordInvocation("BRPopLPush", []interface{}{arg1, arg2, arg3, arg4})
	fake.bRPopLPushMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BRPopLPushCallCount() int {
	fake.bRPopLPushMutex.RLock()
	defer fake.bRPopLPushMutex.RUnlock()
	return len(fake.bRPopLPushArgsForCall)
}

func (fake *FakeClient) BRPopLPushCalls(stub func(context.Context, string, string, time.Duration) *redisa.StringCmd) {
	fake.bRPopLPushMutex.Lock()
	defer fake.bRPopLPushMutex.Unlock()
	fake.BRPopLPushStub = stub
}

func (fake *FakeClient) BRPopLPushArgsForCall(i int) (context.Context, string, string, time.Duration) {
	fake.bRPopLPushMutex.RLock()
	defer fake.bRPopLPushMutex.RUnlock()
	argsForCall := fake.bRPopLPushArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) BRPopLPushReturns(result1 *redisa.StringCmd) {
	fake.bRPopLPushMutex.Lock()
	defer fake.bRPopLPushMutex.Unlock()
	fake.BRPopLPushStub = nil
	fake.bRPopLPushReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) BRPopLPushReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.bRPopLPushMutex.Lock()
	defer fake.bRPopLPushMutex.Unlock()
	fake.BRPopLPushStub = nil
	if fake.bRPopLPushReturnsOnCall == nil {
		fake.bRPopLPushReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.bRPopLPushReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) BZMPop(arg1 context.Context, arg2 time.Duration, arg3 string, arg4 int64, arg5 ...string) *redisa.ZSliceWithKeyCmd {
	fake.bZMPopMutex.Lock()
	ret, specificReturn := fake.bZMPopReturnsOnCall[len(fake.bZMPopArgsForCall)]
	fake.bZMPopArgsForCall = append(fake.bZMPopArgsForCall, struct {
		arg1 context.Context
		arg2 time.Duration
		arg3 string
		arg4 int64
		arg5 []string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.BZMPopStub
	fakeReturns := fake.bZMPopReturns
	fake.recordInvocation("BZMPop", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.bZMPopMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BZMPopCallCount() int {
	fake.bZMPopMutex.RLock()
	defer fake.bZMPopMutex.RUnlock()
	return len(fake.bZMPopArgsForCall)
}

func (fake *FakeClient) BZMPopCalls(stub func(context.Context, time.Duration, string, int64, ...string) *redisa.ZSliceWithKeyCmd) {
	fake.bZMPopMutex.Lock()
	defer fake.bZMPopMutex.Unlock()
	fake.BZMPopStub = stub
}

func (fake *FakeClient) BZMPopArgsForCall(i int) (context.Context, time.Duration, string, int64, []string) {
	fake.bZMPopMutex.RLock()
	defer fake.bZMPopMutex.RUnlock()
	argsForCall := fake.bZMPopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) BZMPopReturns(result1 *redisa.ZSliceWithKeyCmd) {
	fake.bZMPopMutex.Lock()
	defer fake.bZMPopMutex.Unlock()
	fake.BZMPopStub = nil
	fake.bZMPopReturns = struct {
		result1 *redisa.ZSliceWithKeyCmd
	}{result1}
}

func (fake *FakeClient) BZMPopReturnsOnCall(i int, result1 *redisa.ZSliceWithKeyCmd) {
	fake.bZMPopMutex.Lock()
	defer fake.bZMPopMutex.Unlock()
	fake.BZMPopStub = nil
	if fake.bZMPopReturnsOnCall == nil {
		fake.bZMPopReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZSliceWithKeyCmd
		})
	}
	fake.bZMPopReturnsOnCall[i] = struct {
		result1 *redisa.ZSliceWithKeyCmd
	}{result1}
}

func (fake *FakeClient) BZPopMax(arg1 context.Context, arg2 time.Duration, arg3 ...string) *redisa.ZWithKeyCmd {
	fake.bZPopMaxMutex.Lock()
	ret, specificReturn := fake.bZPopMaxReturnsOnCall[len(fake.bZPopMaxArgsForCall)]
	fake.bZPopMaxArgsForCall = append(fake.bZPopMaxArgsForCall, struct {
		arg1 context.Context
		arg2 time.Duration
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.BZPopMaxStub
	fakeReturns := fake.bZPopMaxReturns
	fake.recordInvocation("BZPopMax", []interface{}{arg1, arg2, arg3})
	fake.bZPopMaxMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BZPopMaxCallCount() int {
	fake.bZPopMaxMutex.RLock()
	defer fake.bZPopMaxMutex.RUnlock()
	return len(fake.bZPopMaxArgsForCall)
}

func (fake *FakeClient) BZPopMaxCalls(stub func(context.Context, time.Duration, ...string) *redisa.ZWithKeyCmd) {
	fake.bZPopMaxMutex.Lock()
	defer fake.bZPopMaxMutex.Unlock()
	fake.BZPopMaxStub = stub
}

func (fake *FakeClient) BZPopMaxArgsForCall(i int) (context.Context, time.Duration, []string) {
	fake.bZPopMaxMutex.RLock()
	defer fake.bZPopMaxMutex.RUnlock()
	argsForCall := fake.bZPopMaxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BZPopMaxReturns(result1 *redisa.ZWithKeyCmd) {
	fake.bZPopMaxMutex.Lock()
	defer fake.bZPopMaxMutex.Unlock()
	fake.BZPopMaxStub = nil
	fake.bZPopMaxReturns = struct {
		result1 *redisa.ZWithKeyCmd
	}{result1}
}

func (fake *FakeClient) BZPopMaxReturnsOnCall(i int, result1 *redisa.ZWithKeyCmd) {
	fake.bZPopMaxMutex.Lock()
	defer fake.bZPopMaxMutex.Unlock()
	fake.BZPopMaxStub = nil
	if fake.bZPopMaxReturnsOnCall == nil {
		fake.bZPopMaxReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZWithKeyCmd
		})
	}
	fake.bZPopMaxReturnsOnCall[i] = struct {
		result1 *redisa.ZWithKeyCmd
	}{result1}
}

func (fake *FakeClient) BZPopMin(arg1 context.Context, arg2 time.Duration, arg3 ...string) *redisa.ZWithKeyCmd {
	fake.bZPopMinMutex.Lock()
	ret, specificReturn := fake.bZPopMinReturnsOnCall[len(fake.bZPopMinArgsForCall)]
	fake.bZPopMinArgsForCall = append(fake.bZPopMinArgsForCall, struct {
		arg1 context.Context
		arg2 time.Duration
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.BZPopMinStub
	fakeReturns := fake.bZPopMinReturns
	fake.recordInvocation("BZPopMin", []interface{}{arg1, arg2, arg3})
	fake.bZPopMinMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BZPopMinCallCount() int {
	fake.bZPopMinMutex.RLock()
	defer fake.bZPopMinMutex.RUnlock()
	return len(fake.bZPopMinArgsForCall)
}

func (fake *FakeClient) BZPopMinCalls(stub func(context.Context, time.Duration, ...string) *redisa.ZWithKeyCmd) {
	fake.bZPopMinMutex.Lock()
	defer fake.bZPopMinMutex.Unlock()
	fake.BZPopMinStub = stub
}

func (fake *FakeClient) BZPopMinArgsForCall(i int) (context.Context, time.Duration, []string) {
	fake.bZPopMinMutex.RLock()
	defer fake.bZPopMinMutex.RUnlock()
	argsForCall := fake.bZPopMinArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BZPopMinReturns(result1 *redisa.ZWithKeyCmd) {
	fake.bZPopMinMutex.Lock()
	defer fake.bZPopMinMutex.Unlock()
	fake.BZPopMinStub = nil
	fake.bZPopMinReturns = struct {
		result1 *redisa.ZWithKeyCmd
	}{result1}
}

func (fake *FakeClient) BZPopMinReturnsOnCall(i int, result1 *redisa.ZWithKeyCmd) {
	fake.bZPopMinMutex.Lock()
	defer fake.bZPopMinMutex.Unlock()
	fake.BZPopMinStub = nil
	if fake.bZPopMinReturnsOnCall == nil {
		fake.bZPopMinReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZWithKeyCmd
		})
	}
	fake.bZPopMinReturnsOnCall[i] = struct {
		result1 *redisa.ZWithKeyCmd
	}{result1}
}

func (fake *FakeClient) BgRewriteAOF(arg1 context.Context) *redisa.StatusCmd {
	fake.bgRewriteAOFMutex.Lock()
	ret, specificReturn := fake.bgRewriteAOFReturnsOnCall[len(fake.bgRewriteAOFArgsForCall)]
	fake.bgRewriteAOFArgsForCall = append(fake.bgRewriteAOFArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.BgRewriteAOFStub
	fakeReturns := fake.bgRewriteAOFReturns
	fake.recordInvocation("BgRewriteAOF", []interface{}{arg1})
	fake.bgRewriteAOFMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BgRewriteAOFCallCount() int {
	fake.bgRewriteAOFMutex.RLock()
	defer fake.bgRewriteAOFMutex.RUnlock()
	return len(fake.bgRewriteAOFArgsForCall)
}

func (fake *FakeClient) BgRewriteAOFCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.bgRewriteAOFMutex.Lock()
	defer fake.bgRewriteAOFMutex.Unlock()
	fake.BgRewriteAOFStub = stub
}

func (fake *FakeClient) BgRewriteAOFArgsForCall(i int) context.Context {
	fake.bgRewriteAOFMutex.RLock()
	defer fake.bgRewriteAOFMutex.RUnlock()
	argsForCall := fake.bgRewriteAOFArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) BgRewriteAOFReturns(result1 *redisa.StatusCmd) {
	fake.bgRewriteAOFMutex.Lock()
	defer fake.bgRewriteAOFMutex.Unlock()
	fake.BgRewriteAOFStub = nil
	fake.bgRewriteAOFReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BgRewriteAOFReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.bgRewriteAOFMutex.Lock()
	defer fake.bgRewriteAOFMutex.Unlock()
	fake.BgRewriteAOFStub = nil
	if fake.bgRewriteAOFReturnsOnCall == nil {
		fake.bgRewriteAOFReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.bgRewriteAOFReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BgSave(arg1 context.Context) *redisa.StatusCmd {
	fake.bgSaveMutex.Lock()
	ret, specificReturn := fake.bgSaveReturnsOnCall[len(fake.bgSaveArgsForCall)]
	fake.bgSaveArgsForCall = append(fake.bgSaveArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.BgSaveStub
	fakeReturns := fake.bgSaveReturns
	fake.recordInvocation("BgSave", []interface{}{arg1})
	fake.bgSaveMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BgSaveCallCount() int {
	fake.bgSaveMutex.RLock()
	defer fake.bgSaveMutex.RUnlock()
	return len(fake.bgSaveArgsForCall)
}

func (fake *FakeClient) BgSaveCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.bgSaveMutex.Lock()
	defer fake.bgSaveMutex.Unlock()
	fake.BgSaveStub = stub
}

func (fake *FakeClient) BgSaveArgsForCall(i int) context.Context {
	fake.bgSaveMutex.RLock()
	defer fake.bgSaveMutex.RUnlock()
	argsForCall := fake.bgSaveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) BgSaveReturns(result1 *redisa.StatusCmd) {
	fake.bgSaveMutex.Lock()
	defer fake.bgSaveMutex.Unlock()
	fake.BgSaveStub = nil
	fake.bgSaveReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BgSaveReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.bgSaveMutex.Lock()
	defer fake.bgSaveMutex.Unlock()
	fake.BgSaveStub = nil
	if fake.bgSaveReturnsOnCall == nil {
		fake.bgSaveReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.bgSaveReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) BitCount(arg1 context.Context, arg2 string, arg3 *redisa.BitCount) *redisa.IntCmd {
	fake.bitCountMutex.Lock()
	ret, specificReturn := fake.bitCountReturnsOnCall[len(fake.bitCountArgsForCall)]
	fake.bitCountArgsForCall = append(fake.bitCountArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.BitCount
	}{arg1, arg2, arg3})
	stub := fake.BitCountStub
	fakeReturns := fake.bitCountReturns
	fake.recordInvocation("BitCount", []interface{}{arg1, arg2, arg3})
	fake.bitCountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BitCountCallCount() int {
	fake.bitCountMutex.RLock()
	defer fake.bitCountMutex.RUnlock()
	return len(fake.bitCountArgsForCall)
}

func (fake *FakeClient) BitCountCalls(stub func(context.Context, string, *redisa.BitCount) *redisa.IntCmd) {
	fake.bitCountMutex.Lock()
	defer fake.bitCountMutex.Unlock()
	fake.BitCountStub = stub
}

func (fake *FakeClient) BitCountArgsForCall(i int) (context.Context, string, *redisa.BitCount) {
	fake.bitCountMutex.RLock()
	defer fake.bitCountMutex.RUnlock()
	argsForCall := fake.bitCountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BitCountReturns(result1 *redisa.IntCmd) {
	fake.bitCountMutex.Lock()
	defer fake.bitCountMutex.Unlock()
	fake.BitCountStub = nil
	fake.bitCountReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BitCountReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.bitCountMutex.Lock()
	defer fake.bitCountMutex.Unlock()
	fake.BitCountStub = nil
	if fake.bitCountReturnsOnCall == nil {
		fake.bitCountReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.bitCountReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BitField(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntSliceCmd {
	fake.bitFieldMutex.Lock()
	ret, specificReturn := fake.bitFieldReturnsOnCall[len(fake.bitFieldArgsForCall)]
	fake.bitFieldArgsForCall = append(fake.bitFieldArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.BitFieldStub
	fakeReturns := fake.bitFieldReturns
	fake.recordInvocation("BitField", []interface{}{arg1, arg2, arg3})
	fake.bitFieldMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BitFieldCallCount() int {
	fake.bitFieldMutex.RLock()
	defer fake.bitFieldMutex.RUnlock()
	return len(fake.bitFieldArgsForCall)
}

func (fake *FakeClient) BitFieldCalls(stub func(context.Context, string, ...interface{}) *redisa.IntSliceCmd) {
	fake.bitFieldMutex.Lock()
	defer fake.bitFieldMutex.Unlock()
	fake.BitFieldStub = stub
}

func (fake *FakeClient) BitFieldArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.bitFieldMutex.RLock()
	defer fake.bitFieldMutex.RUnlock()
	argsForCall := fake.bitFieldArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BitFieldReturns(result1 *redisa.IntSliceCmd) {
	fake.bitFieldMutex.Lock()
	defer fake.bitFieldMutex.Unlock()
	fake.BitFieldStub = nil
	fake.bitFieldReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) BitFieldReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.bitFieldMutex.Lock()
	defer fake.bitFieldMutex.Unlock()
	fake.BitFieldStub = nil
	if fake.bitFieldReturnsOnCall == nil {
		fake.bitFieldReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.bitFieldReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) BitFieldRO(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntSliceCmd {
	fake.bitFieldROMutex.Lock()
	ret, specificReturn := fake.bitFieldROReturnsOnCall[len(fake.bitFieldROArgsForCall)]
	fake.bitFieldROArgsForCall = append(fake.bitFieldROArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.BitFieldROStub
	fakeReturns := fake.bitFieldROReturns
	fake.recordInvocation("BitFieldRO", []interface{}{arg1, arg2, arg3})
	fake.bitFieldROMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BitFieldROCallCount() int {
	fake.bitFieldROMutex.RLock()
	defer fake.bitFieldROMutex.RUnlock()
	return len(fake.bitFieldROArgsForCall)
}

func (fake *FakeClient) BitFieldROCalls(stub func(context.Context, string, ...interface{}) *redisa.IntSliceCmd) {
	fake.bitFieldROMutex.Lock()
	defer fake.bitFieldROMutex.Unlock()
	fake.BitFieldROStub = stub
}

func (fake *FakeClient) BitFieldROArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.bitFieldROMutex.RLock()
	defer fake.bitFieldROMutex.RUnlock()
	argsForCall := fake.bitFieldROArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BitFieldROReturns(result1 *redisa.IntSliceCmd) {
	fake.bitFieldROMutex.Lock()
	defer fake.bitFieldROMutex.Unlock()
	fake.BitFieldROStub = nil
	fake.bitFieldROReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) BitFieldROReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.bitFieldROMutex.Lock()
	defer fake.bitFieldROMutex.Unlock()
	fake.BitFieldROStub = nil
	if fake.bitFieldROReturnsOnCall == nil {
		fake.bitFieldROReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.bitFieldROReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) BitOpAnd(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntCmd {
	fake.bitOpAndMutex.Lock()
	ret, specificReturn := fake.bitOpAndReturnsOnCall[len(fake.bitOpAndArgsForCall)]
	fake.bitOpAndArgsForCall = append(fake.bitOpAndArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.BitOpAndStub
	fakeReturns := fake.bitOpAndReturns
	fake.recordInvocation("BitOpAnd", []interface{}{arg1, arg2, arg3})
	fake.bitOpAndMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BitOpAndCallCount() int {
	fake.bitOpAndMutex.RLock()
	defer fake.bitOpAndMutex.RUnlock()
	return len(fake.bitOpAndArgsForCall)
}

func (fake *FakeClient) BitOpAndCalls(stub func(context.Context, string, ...string) *redisa.IntCmd) {
	fake.bitOpAndMutex.Lock()
	defer fake.bitOpAndMutex.Unlock()
	fake.BitOpAndStub = stub
}

func (fake *FakeClient) BitOpAndArgsForCall(i int) (context.Context, string, []string) {
	fake.bitOpAndMutex.RLock()
	defer fake.bitOpAndMutex.RUnlock()
	argsForCall := fake.bitOpAndArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BitOpAndReturns(result1 *redisa.IntCmd) {
	fake.bitOpAndMutex.Lock()
	defer fake.bitOpAndMutex.Unlock()
	fake.BitOpAndStub = nil
	fake.bitOpAndReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BitOpAndReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.bitOpAndMutex.Lock()
	defer fake.bitOpAndMutex.Unlock()
	fake.BitOpAndStub = nil
	if fake.bitOpAndReturnsOnCall == nil {
		fake.bitOpAndReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.bitOpAndReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BitOpNot(arg1 context.Context, arg2 string, arg3 string) *redisa.IntCmd {
	fake.bitOpNotMutex.Lock()
	ret, specificReturn := fake.bitOpNotReturnsOnCall[len(fake.bitOpNotArgsForCall)]
	fake.bitOpNotArgsForCall = append(fake.bitOpNotArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.BitOpNotStub
	fakeReturns := fake.bitOpNotReturns
	fake.recordInvocation("BitOpNot", []interface{}{arg1, arg2, arg3})
	fake.bitOpNotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BitOpNotCallCount() int {
	fake.bitOpNotMutex.RLock()
	defer fake.bitOpNotMutex.RUnlock()
	return len(fake.bitOpNotArgsForCall)
}

func (fake *FakeClient) BitOpNotCalls(stub func(context.Context, string, string) *redisa.IntCmd) {
	fake.bitOpNotMutex.Lock()
	defer fake.bitOpNotMutex.Unlock()
	fake.BitOpNotStub = stub
}

func (fake *FakeClient) BitOpNotArgsForCall(i int) (context.Context, string, string) {
	fake.bitOpNotMutex.RLock()
	defer fake.bitOpNotMutex.RUnlock()
	argsForCall := fake.bitOpNotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BitOpNotReturns(result1 *redisa.IntCmd) {
	fake.bitOpNotMutex.Lock()
	defer fake.bitOpNotMutex.Unlock()
	fake.BitOpNotStub = nil
	fake.bitOpNotReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BitOpNotReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.bitOpNotMutex.Lock()
	defer fake.bitOpNotMutex.Unlock()
	fake.BitOpNotStub = nil
	if fake.bitOpNotReturnsOnCall == nil {
		fake.bitOpNotReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.bitOpNotReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BitOpOr(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntCmd {
	fake.bitOpOrMutex.Lock()
	ret, specificReturn := fake.bitOpOrReturnsOnCall[len(fake.bitOpOrArgsForCall)]
	fake.bitOpOrArgsForCall = append(fake.bitOpOrArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.BitOpOrStub
	fakeReturns := fake.bitOpOrReturns
	fake.recordInvocation("BitOpOr", []interface{}{arg1, arg2, arg3})
	fake.bitOpOrMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BitOpOrCallCount() int {
	fake.bitOpOrMutex.RLock()
	defer fake.bitOpOrMutex.RUnlock()
	return len(fake.bitOpOrArgsForCall)
}

func (fake *FakeClient) BitOpOrCalls(stub func(context.Context, string, ...string) *redisa.IntCmd) {
	fake.bitOpOrMutex.Lock()
	defer fake.bitOpOrMutex.Unlock()
	fake.BitOpOrStub = stub
}

func (fake *FakeClient) BitOpOrArgsForCall(i int) (context.Context, string, []string) {
	fake.bitOpOrMutex.RLock()
	defer fake.bitOpOrMutex.RUnlock()
	argsForCall := fake.bitOpOrArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BitOpOrReturns(result1 *redisa.IntCmd) {
	fake.bitOpOrMutex.Lock()
	defer fake.bitOpOrMutex.Unlock()
	fake.BitOpOrStub = nil
	fake.bitOpOrReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BitOpOrReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.bitOpOrMutex.Lock()
	defer fake.bitOpOrMutex.Unlock()
	fake.BitOpOrStub = nil
	if fake.bitOpOrReturnsOnCall == nil {
		fake.bitOpOrReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.bitOpOrReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BitOpXor(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntCmd {
	fake.bitOpXorMutex.Lock()
	ret, specificReturn := fake.bitOpXorReturnsOnCall[len(fake.bitOpXorArgsForCall)]
	fake.bitOpXorArgsForCall = append(fake.bitOpXorArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.BitOpXorStub
	fakeReturns := fake.bitOpXorReturns
	fake.recordInvocation("BitOpXor", []interface{}{arg1, arg2, arg3})
	fake.bitOpXorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BitOpXorCallCount() int {
	fake.bitOpXorMutex.RLock()
	defer fake.bitOpXorMutex.RUnlock()
	return len(fake.bitOpXorArgsForCall)
}

func (fake *FakeClient) BitOpXorCalls(stub func(context.Context, string, ...string) *redisa.IntCmd) {
	fake.bitOpXorMutex.Lock()
	defer fake.bitOpXorMutex.Unlock()
	fake.BitOpXorStub = stub
}

func (fake *FakeClient) BitOpXorArgsForCall(i int) (context.Context, string, []string) {
	fake.bitOpXorMutex.RLock()
	defer fake.bitOpXorMutex.RUnlock()
	argsForCall := fake.bitOpXorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BitOpXorReturns(result1 *redisa.IntCmd) {
	fake.bitOpXorMutex.Lock()
	defer fake.bitOpXorMutex.Unlock()
	fake.BitOpXorStub = nil
	fake.bitOpXorReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BitOpXorReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.bitOpXorMutex.Lock()
	defer fake.bitOpXorMutex.Unlock()
	fake.BitOpXorStub = nil
	if fake.bitOpXorReturnsOnCall == nil {
		fake.bitOpXorReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.bitOpXorReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BitPos(arg1 context.Context, arg2 string, arg3 int64, arg4 ...int64) *redisa.IntCmd {
	fake.bitPosMutex.Lock()
	ret, specificReturn := fake.bitPosReturnsOnCall[len(fake.bitPosArgsForCall)]
	fake.bitPosArgsForCall = append(fake.bitPosArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 []int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.BitPosStub
	fakeReturns := fake.bitPosReturns
	fake.recordInvocation("BitPos", []interface{}{arg1, arg2, arg3, arg4})
	fake.bitPosMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BitPosCallCount() int {
	fake.bitPosMutex.RLock()
	defer fake.bitPosMutex.RUnlock()
	return len(fake.bitPosArgsForCall)
}

func (fake *FakeClient) BitPosCalls(stub func(context.Context, string, int64, ...int64) *redisa.IntCmd) {
	fake.bitPosMutex.Lock()
	defer fake.bitPosMutex.Unlock()
	fake.BitPosStub = stub
}

func (fake *FakeClient) BitPosArgsForCall(i int) (context.Context, string, int64, []int64) {
	fake.bitPosMutex.RLock()
	defer fake.bitPosMutex.RUnlock()
	argsForCall := fake.bitPosArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) BitPosReturns(result1 *redisa.IntCmd) {
	fake.bitPosMutex.Lock()
	defer fake.bitPosMutex.Unlock()
	fake.BitPosStub = nil
	fake.bitPosReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BitPosReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.bitPosMutex.Lock()
	defer fake.bitPosMutex.Unlock()
	fake.BitPosStub = nil
	if fake.bitPosReturnsOnCall == nil {
		fake.bitPosReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.bitPosReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BitPosSpan(arg1 context.Context, arg2 string, arg3 int8, arg4 int64, arg5 int64, arg6 string) *redisa.IntCmd {
	fake.bitPosSpanMutex.Lock()
	ret, specificReturn := fake.bitPosSpanReturnsOnCall[len(fake.bitPosSpanArgsForCall)]
	fake.bitPosSpanArgsForCall = append(fake.bitPosSpanArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int8
		arg4 int64
		arg5 int64
		arg6 string
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.BitPosSpanStub
	fakeReturns := fake.bitPosSpanReturns
	fake.recordInvocation("BitPosSpan", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.bitPosSpanMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BitPosSpanCallCount() int {
	fake.bitPosSpanMutex.RLock()
	defer fake.bitPosSpanMutex.RUnlock()
	return len(fake.bitPosSpanArgsForCall)
}

func (fake *FakeClient) BitPosSpanCalls(stub func(context.Context, string, int8, int64, int64, string) *redisa.IntCmd) {
	fake.bitPosSpanMutex.Lock()
	defer fake.bitPosSpanMutex.Unlock()
	fake.BitPosSpanStub = stub
}

func (fake *FakeClient) BitPosSpanArgsForCall(i int) (context.Context, string, int8, int64, int64, string) {
	fake.bitPosSpanMutex.RLock()
	defer fake.bitPosSpanMutex.RUnlock()
	argsForCall := fake.bitPosSpanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeClient) BitPosSpanReturns(result1 *redisa.IntCmd) {
	fake.bitPosSpanMutex.Lock()
	defer fake.bitPosSpanMutex.Unlock()
	fake.BitPosSpanStub = nil
	fake.bitPosSpanReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) BitPosSpanReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.bitPosSpanMutex.Lock()
	defer fake.bitPosSpanMutex.Unlock()
	fake.BitPosSpanStub = nil
	if fake.bitPosSpanReturnsOnCall == nil {
		fake.bitPosSpanReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.bitPosSpanReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) CFAdd(arg1 context.Context, arg2 string, arg3 interface{}) *redisa.BoolCmd {
	fake.cFAddMutex.Lock()
	ret, specificReturn := fake.cFAddReturnsOnCall[len(fake.cFAddArgsForCall)]
	fake.cFAddArgsForCall = append(fake.cFAddArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.CFAddStub
	fakeReturns := fake.cFAddReturns
	fake.recordInvocation("CFAdd", []interface{}{arg1, arg2, arg3})
	fake.cFAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFAddCallCount() int {
	fake.cFAddMutex.RLock()
	defer fake.cFAddMutex.RUnlock()
	return len(fake.cFAddArgsForCall)
}

func (fake *FakeClient) CFAddCalls(stub func(context.Context, string, interface{}) *redisa.BoolCmd) {
	fake.cFAddMutex.Lock()
	defer fake.cFAddMutex.Unlock()
	fake.CFAddStub = stub
}

func (fake *FakeClient) CFAddArgsForCall(i int) (context.Context, string, interface{}) {
	fake.cFAddMutex.RLock()
	defer fake.cFAddMutex.RUnlock()
	argsForCall := fake.cFAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CFAddReturns(result1 *redisa.BoolCmd) {
	fake.cFAddMutex.Lock()
	defer fake.cFAddMutex.Unlock()
	fake.CFAddStub = nil
	fake.cFAddReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) CFAddReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.cFAddMutex.Lock()
	defer fake.cFAddMutex.Unlock()
	fake.CFAddStub = nil
	if fake.cFAddReturnsOnCall == nil {
		fake.cFAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.cFAddReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) CFAddNX(arg1 context.Context, arg2 string, arg3 interface{}) *redisa.BoolCmd {
	fake.cFAddNXMutex.Lock()
	ret, specificReturn := fake.cFAddNXReturnsOnCall[len(fake.cFAddNXArgsForCall)]
	fake.cFAddNXArgsForCall = append(fake.cFAddNXArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.CFAddNXStub
	fakeReturns := fake.cFAddNXReturns
	fake.recordInvocation("CFAddNX", []interface{}{arg1, arg2, arg3})
	fake.cFAddNXMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFAddNXCallCount() int {
	fake.cFAddNXMutex.RLock()
	defer fake.cFAddNXMutex.RUnlock()
	return len(fake.cFAddNXArgsForCall)
}

func (fake *FakeClient) CFAddNXCalls(stub func(context.Context, string, interface{}) *redisa.BoolCmd) {
	fake.cFAddNXMutex.Lock()
	defer fake.cFAddNXMutex.Unlock()
	fake.CFAddNXStub = stub
}

func (fake *FakeClient) CFAddNXArgsForCall(i int) (context.Context, string, interface{}) {
	fake.cFAddNXMutex.RLock()
	defer fake.cFAddNXMutex.RUnlock()
	argsForCall := fake.cFAddNXArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CFAddNXReturns(result1 *redisa.BoolCmd) {
	fake.cFAddNXMutex.Lock()
	defer fake.cFAddNXMutex.Unlock()
	fake.CFAddNXStub = nil
	fake.cFAddNXReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) CFAddNXReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.cFAddNXMutex.Lock()
	defer fake.cFAddNXMutex.Unlock()
	fake.CFAddNXStub = nil
	if fake.cFAddNXReturnsOnCall == nil {
		fake.cFAddNXReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.cFAddNXReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) CFCount(arg1 context.Context, arg2 string, arg3 interface{}) *redisa.IntCmd {
	fake.cFCountMutex.Lock()
	ret, specificReturn := fake.cFCountReturnsOnCall[len(fake.cFCountArgsForCall)]
	fake.cFCountArgsForCall = append(fake.cFCountArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.CFCountStub
	fakeReturns := fake.cFCountReturns
	fake.recordInvocation("CFCount", []interface{}{arg1, arg2, arg3})
	fake.cFCountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFCountCallCount() int {
	fake.cFCountMutex.RLock()
	defer fake.cFCountMutex.RUnlock()
	return len(fake.cFCountArgsForCall)
}

func (fake *FakeClient) CFCountCalls(stub func(context.Context, string, interface{}) *redisa.IntCmd) {
	fake.cFCountMutex.Lock()
	defer fake.cFCountMutex.Unlock()
	fake.CFCountStub = stub
}

func (fake *FakeClient) CFCountArgsForCall(i int) (context.Context, string, interface{}) {
	fake.cFCountMutex.RLock()
	defer fake.cFCountMutex.RUnlock()
	argsForCall := fake.cFCountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CFCountReturns(result1 *redisa.IntCmd) {
	fake.cFCountMutex.Lock()
	defer fake.cFCountMutex.Unlock()
	fake.CFCountStub = nil
	fake.cFCountReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) CFCountReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.cFCountMutex.Lock()
	defer fake.cFCountMutex.Unlock()
	fake.CFCountStub = nil
	if fake.cFCountReturnsOnCall == nil {
		fake.cFCountReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.cFCountReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) CFDel(arg1 context.Context, arg2 string, arg3 interface{}) *redisa.BoolCmd {
	fake.cFDelMutex.Lock()
	ret, specificReturn := fake.cFDelReturnsOnCall[len(fake.cFDelArgsForCall)]
	fake.cFDelArgsForCall = append(fake.cFDelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.CFDelStub
	fakeReturns := fake.cFDelReturns
	fake.recordInvocation("CFDel", []interface{}{arg1, arg2, arg3})
	fake.cFDelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFDelCallCount() int {
	fake.cFDelMutex.RLock()
	defer fake.cFDelMutex.RUnlock()
	return len(fake.cFDelArgsForCall)
}

func (fake *FakeClient) CFDelCalls(stub func(context.Context, string, interface{}) *redisa.BoolCmd) {
	fake.cFDelMutex.Lock()
	defer fake.cFDelMutex.Unlock()
	fake.CFDelStub = stub
}

func (fake *FakeClient) CFDelArgsForCall(i int) (context.Context, string, interface{}) {
	fake.cFDelMutex.RLock()
	defer fake.cFDelMutex.RUnlock()
	argsForCall := fake.cFDelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CFDelReturns(result1 *redisa.BoolCmd) {
	fake.cFDelMutex.Lock()
	defer fake.cFDelMutex.Unlock()
	fake.CFDelStub = nil
	fake.cFDelReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) CFDelReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.cFDelMutex.Lock()
	defer fake.cFDelMutex.Unlock()
	fake.CFDelStub = nil
	if fake.cFDelReturnsOnCall == nil {
		fake.cFDelReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.cFDelReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) CFExists(arg1 context.Context, arg2 string, arg3 interface{}) *redisa.BoolCmd {
	fake.cFExistsMutex.Lock()
	ret, specificReturn := fake.cFExistsReturnsOnCall[len(fake.cFExistsArgsForCall)]
	fake.cFExistsArgsForCall = append(fake.cFExistsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.CFExistsStub
	fakeReturns := fake.cFExistsReturns
	fake.recordInvocation("CFExists", []interface{}{arg1, arg2, arg3})
	fake.cFExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFExistsCallCount() int {
	fake.cFExistsMutex.RLock()
	defer fake.cFExistsMutex.RUnlock()
	return len(fake.cFExistsArgsForCall)
}

func (fake *FakeClient) CFExistsCalls(stub func(context.Context, string, interface{}) *redisa.BoolCmd) {
	fake.cFExistsMutex.Lock()
	defer fake.cFExistsMutex.Unlock()
	fake.CFExistsStub = stub
}

func (fake *FakeClient) CFExistsArgsForCall(i int) (context.Context, string, interface{}) {
	fake.cFExistsMutex.RLock()
	defer fake.cFExistsMutex.RUnlock()
	argsForCall := fake.cFExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CFExistsReturns(result1 *redisa.BoolCmd) {
	fake.cFExistsMutex.Lock()
	defer fake.cFExistsMutex.Unlock()
	fake.CFExistsStub = nil
	fake.cFExistsReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) CFExistsReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.cFExistsMutex.Lock()
	defer fake.cFExistsMutex.Unlock()
	fake.CFExistsStub = nil
	if fake.cFExistsReturnsOnCall == nil {
		fake.cFExistsReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.cFExistsReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) CFInfo(arg1 context.Context, arg2 string) *redisa.CFInfoCmd {
	fake.cFInfoMutex.Lock()
	ret, specificReturn := fake.cFInfoReturnsOnCall[len(fake.cFInfoArgsForCall)]
	fake.cFInfoArgsForCall = append(fake.cFInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CFInfoStub
	fakeReturns := fake.cFInfoReturns
	fake.recordInvocation("CFInfo", []interface{}{arg1, arg2})
	fake.cFInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFInfoCallCount() int {
	fake.cFInfoMutex.RLock()
	defer fake.cFInfoMutex.RUnlock()
	return len(fake.cFInfoArgsForCall)
}

func (fake *FakeClient) CFInfoCalls(stub func(context.Context, string) *redisa.CFInfoCmd) {
	fake.cFInfoMutex.Lock()
	defer fake.cFInfoMutex.Unlock()
	fake.CFInfoStub = stub
}

func (fake *FakeClient) CFInfoArgsForCall(i int) (context.Context, string) {
	fake.cFInfoMutex.RLock()
	defer fake.cFInfoMutex.RUnlock()
	argsForCall := fake.cFInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) CFInfoReturns(result1 *redisa.CFInfoCmd) {
	fake.cFInfoMutex.Lock()
	defer fake.cFInfoMutex.Unlock()
	fake.CFInfoStub = nil
	fake.cFInfoReturns = struct {
		result1 *redisa.CFInfoCmd
	}{result1}
}

func (fake *FakeClient) CFInfoReturnsOnCall(i int, result1 *redisa.CFInfoCmd) {
	fake.cFInfoMutex.Lock()
	defer fake.cFInfoMutex.Unlock()
	fake.CFInfoStub = nil
	if fake.cFInfoReturnsOnCall == nil {
		fake.cFInfoReturnsOnCall = make(map[int]struct {
			result1 *redisa.CFInfoCmd
		})
	}
	fake.cFInfoReturnsOnCall[i] = struct {
		result1 *redisa.CFInfoCmd
	}{result1}
}

func (fake *FakeClient) CFInsert(arg1 context.Context, arg2 string, arg3 *redisa.CFInsertOptions, arg4 ...interface{}) *redisa.BoolSliceCmd {
	fake.cFInsertMutex.Lock()
	ret, specificReturn := fake.cFInsertReturnsOnCall[len(fake.cFInsertArgsForCall)]
	fake.cFInsertArgsForCall = append(fake.cFInsertArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.CFInsertOptions
		arg4 []interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.CFInsertStub
	fakeReturns := fake.cFInsertReturns
	fake.recordInvocation("CFInsert", []interface{}{arg1, arg2, arg3, arg4})
	fake.cFInsertMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFInsertCallCount() int {
	fake.cFInsertMutex.RLock()
	defer fake.cFInsertMutex.RUnlock()
	return len(fake.cFInsertArgsForCall)
}

func (fake *FakeClient) CFInsertCalls(stub func(context.Context, string, *redisa.CFInsertOptions, ...interface{}) *redisa.BoolSliceCmd) {
	fake.cFInsertMutex.Lock()
	defer fake.cFInsertMutex.Unlock()
	fake.CFInsertStub = stub
}

func (fake *FakeClient) CFInsertArgsForCall(i int) (context.Context, string, *redisa.CFInsertOptions, []interface{}) {
	fake.cFInsertMutex.RLock()
	defer fake.cFInsertMutex.RUnlock()
	argsForCall := fake.cFInsertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) CFInsertReturns(result1 *redisa.BoolSliceCmd) {
	fake.cFInsertMutex.Lock()
	defer fake.cFInsertMutex.Unlock()
	fake.CFInsertStub = nil
	fake.cFInsertReturns = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) CFInsertReturnsOnCall(i int, result1 *redisa.BoolSliceCmd) {
	fake.cFInsertMutex.Lock()
	defer fake.cFInsertMutex.Unlock()
	fake.CFInsertStub = nil
	if fake.cFInsertReturnsOnCall == nil {
		fake.cFInsertReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolSliceCmd
		})
	}
	fake.cFInsertReturnsOnCall[i] = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) CFInsertNX(arg1 context.Context, arg2 string, arg3 *redisa.CFInsertOptions, arg4 ...interface{}) *redisa.IntSliceCmd {
	fake.cFInsertNXMutex.Lock()
	ret, specificReturn := fake.cFInsertNXReturnsOnCall[len(fake.cFInsertNXArgsForCall)]
	fake.cFInsertNXArgsForCall = append(fake.cFInsertNXArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.CFInsertOptions
		arg4 []interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.CFInsertNXStub
	fakeReturns := fake.cFInsertNXReturns
	fake.recordInvocation("CFInsertNX", []interface{}{arg1, arg2, arg3, arg4})
	fake.cFInsertNXMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFInsertNXCallCount() int {
	fake.cFInsertNXMutex.RLock()
	defer fake.cFInsertNXMutex.RUnlock()
	return len(fake.cFInsertNXArgsForCall)
}

func (fake *FakeClient) CFInsertNXCalls(stub func(context.Context, string, *redisa.CFInsertOptions, ...interface{}) *redisa.IntSliceCmd) {
	fake.cFInsertNXMutex.Lock()
	defer fake.cFInsertNXMutex.Unlock()
	fake.CFInsertNXStub = stub
}

func (fake *FakeClient) CFInsertNXArgsForCall(i int) (context.Context, string, *redisa.CFInsertOptions, []interface{}) {
	fake.cFInsertNXMutex.RLock()
	defer fake.cFInsertNXMutex.RUnlock()
	argsForCall := fake.cFInsertNXArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) CFInsertNXReturns(result1 *redisa.IntSliceCmd) {
	fake.cFInsertNXMutex.Lock()
	defer fake.cFInsertNXMutex.Unlock()
	fake.CFInsertNXStub = nil
	fake.cFInsertNXReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) CFInsertNXReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.cFInsertNXMutex.Lock()
	defer fake.cFInsertNXMutex.Unlock()
	fake.CFInsertNXStub = nil
	if fake.cFInsertNXReturnsOnCall == nil {
		fake.cFInsertNXReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.cFInsertNXReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) CFLoadChunk(arg1 context.Context, arg2 string, arg3 int64, arg4 interface{}) *redisa.StatusCmd {
	fake.cFLoadChunkMutex.Lock()
	ret, specificReturn := fake.cFLoadChunkReturnsOnCall[len(fake.cFLoadChunkArgsForCall)]
	fake.cFLoadChunkArgsForCall = append(fake.cFLoadChunkArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.CFLoadChunkStub
	fakeReturns := fake.cFLoadChunkReturns
	fake.recordInvocation("CFLoadChunk", []interface{}{arg1, arg2, arg3, arg4})
	fake.cFLoadChunkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFLoadChunkCallCount() int {
	fake.cFLoadChunkMutex.RLock()
	defer fake.cFLoadChunkMutex.RUnlock()
	return len(fake.cFLoadChunkArgsForCall)
}

func (fake *FakeClient) CFLoadChunkCalls(stub func(context.Context, string, int64, interface{}) *redisa.StatusCmd) {
	fake.cFLoadChunkMutex.Lock()
	defer fake.cFLoadChunkMutex.Unlock()
	fake.CFLoadChunkStub = stub
}

func (fake *FakeClient) CFLoadChunkArgsForCall(i int) (context.Context, string, int64, interface{}) {
	fake.cFLoadChunkMutex.RLock()
	defer fake.cFLoadChunkMutex.RUnlock()
	argsForCall := fake.cFLoadChunkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) CFLoadChunkReturns(result1 *redisa.StatusCmd) {
	fake.cFLoadChunkMutex.Lock()
	defer fake.cFLoadChunkMutex.Unlock()
	fake.CFLoadChunkStub = nil
	fake.cFLoadChunkReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CFLoadChunkReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.cFLoadChunkMutex.Lock()
	defer fake.cFLoadChunkMutex.Unlock()
	fake.CFLoadChunkStub = nil
	if fake.cFLoadChunkReturnsOnCall == nil {
		fake.cFLoadChunkReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.cFLoadChunkReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CFMExists(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.BoolSliceCmd {
	fake.cFMExistsMutex.Lock()
	ret, specificReturn := fake.cFMExistsReturnsOnCall[len(fake.cFMExistsArgsForCall)]
	fake.cFMExistsArgsForCall = append(fake.cFMExistsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.CFMExistsStub
	fakeReturns := fake.cFMExistsReturns
	fake.recordInvocation("CFMExists", []interface{}{arg1, arg2, arg3})
	fake.cFMExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFMExistsCallCount() int {
	fake.cFMExistsMutex.RLock()
	defer fake.cFMExistsMutex.RUnlock()
	return len(fake.cFMExistsArgsForCall)
}

func (fake *FakeClient) CFMExistsCalls(stub func(context.Context, string, ...interface{}) *redisa.BoolSliceCmd) {
	fake.cFMExistsMutex.Lock()
	defer fake.cFMExistsMutex.Unlock()
	fake.CFMExistsStub = stub
}

func (fake *FakeClient) CFMExistsArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.cFMExistsMutex.RLock()
	defer fake.cFMExistsMutex.RUnlock()
	argsForCall := fake.cFMExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CFMExistsReturns(result1 *redisa.BoolSliceCmd) {
	fake.cFMExistsMutex.Lock()
	defer fake.cFMExistsMutex.Unlock()
	fake.CFMExistsStub = nil
	fake.cFMExistsReturns = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) CFMExistsReturnsOnCall(i int, result1 *redisa.BoolSliceCmd) {
	fake.cFMExistsMutex.Lock()
	defer fake.cFMExistsMutex.Unlock()
	fake.CFMExistsStub = nil
	if fake.cFMExistsReturnsOnCall == nil {
		fake.cFMExistsReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolSliceCmd
		})
	}
	fake.cFMExistsReturnsOnCall[i] = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) CFReserve(arg1 context.Context, arg2 string, arg3 int64) *redisa.StatusCmd {
	fake.cFReserveMutex.Lock()
	ret, specificReturn := fake.cFReserveReturnsOnCall[len(fake.cFReserveArgsForCall)]
	fake.cFReserveArgsForCall = append(fake.cFReserveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.CFReserveStub
	fakeReturns := fake.cFReserveReturns
	fake.recordInvocation("CFReserve", []interface{}{arg1, arg2, arg3})
	fake.cFReserveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFReserveCallCount() int {
	fake.cFReserveMutex.RLock()
	defer fake.cFReserveMutex.RUnlock()
	return len(fake.cFReserveArgsForCall)
}

func (fake *FakeClient) CFReserveCalls(stub func(context.Context, string, int64) *redisa.StatusCmd) {
	fake.cFReserveMutex.Lock()
	defer fake.cFReserveMutex.Unlock()
	fake.CFReserveStub = stub
}

func (fake *FakeClient) CFReserveArgsForCall(i int) (context.Context, string, int64) {
	fake.cFReserveMutex.RLock()
	defer fake.cFReserveMutex.RUnlock()
	argsForCall := fake.cFReserveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CFReserveReturns(result1 *redisa.StatusCmd) {
	fake.cFReserveMutex.Lock()
	defer fake.cFReserveMutex.Unlock()
	fake.CFReserveStub = nil
	fake.cFReserveReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CFReserveReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.cFReserveMutex.Lock()
	defer fake.cFReserveMutex.Unlock()
	fake.CFReserveStub = nil
	if fake.cFReserveReturnsOnCall == nil {
		fake.cFReserveReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.cFReserveReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CFReserveBucketSize(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) *redisa.StatusCmd {
	fake.cFReserveBucketSizeMutex.Lock()
	ret, specificReturn := fake.cFReserveBucketSizeReturnsOnCall[len(fake.cFReserveBucketSizeArgsForCall)]
	fake.cFReserveBucketSizeArgsForCall = append(fake.cFReserveBucketSizeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.CFReserveBucketSizeStub
	fakeReturns := fake.cFReserveBucketSizeReturns
	fake.recordInvocation("CFReserveBucketSize", []interface{}{arg1, arg2, arg3, arg4})
	fake.cFReserveBucketSizeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFReserveBucketSizeCallCount() int {
	fake.cFReserveBucketSizeMutex.RLock()
	defer fake.cFReserveBucketSizeMutex.RUnlock()
	return len(fake.cFReserveBucketSizeArgsForCall)
}

func (fake *FakeClient) CFReserveBucketSizeCalls(stub func(context.Context, string, int64, int64) *redisa.StatusCmd) {
	fake.cFReserveBucketSizeMutex.Lock()
	defer fake.cFReserveBucketSizeMutex.Unlock()
	fake.CFReserveBucketSizeStub = stub
}

func (fake *FakeClient) CFReserveBucketSizeArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.cFReserveBucketSizeMutex.RLock()
	defer fake.cFReserveBucketSizeMutex.RUnlock()
	argsForCall := fake.cFReserveBucketSizeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) CFReserveBucketSizeReturns(result1 *redisa.StatusCmd) {
	fake.cFReserveBucketSizeMutex.Lock()
	defer fake.cFReserveBucketSizeMutex.Unlock()
	fake.CFReserveBucketSizeStub = nil
	fake.cFReserveBucketSizeReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CFReserveBucketSizeReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.cFReserveBucketSizeMutex.Lock()
	defer fake.cFReserveBucketSizeMutex.Unlock()
	fake.CFReserveBucketSizeStub = nil
	if fake.cFReserveBucketSizeReturnsOnCall == nil {
		fake.cFReserveBucketSizeReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.cFReserveBucketSizeReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CFReserveExpansion(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) *redisa.StatusCmd {
	fake.cFReserveExpansionMutex.Lock()
	ret, specificReturn := fake.cFReserveExpansionReturnsOnCall[len(fake.cFReserveExpansionArgsForCall)]
	fake.cFReserveExpansionArgsForCall = append(fake.cFReserveExpansionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.CFReserveExpansionStub
	fakeReturns := fake.cFReserveExpansionReturns
	fake.recordInvocation("CFReserveExpansion", []interface{}{arg1, arg2, arg3, arg4})
	fake.cFReserveExpansionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFReserveExpansionCallCount() int {
	fake.cFReserveExpansionMutex.RLock()
	defer fake.cFReserveExpansionMutex.RUnlock()
	return len(fake.cFReserveExpansionArgsForCall)
}

func (fake *FakeClient) CFReserveExpansionCalls(stub func(context.Context, string, int64, int64) *redisa.StatusCmd) {
	fake.cFReserveExpansionMutex.Lock()
	defer fake.cFReserveExpansionMutex.Unlock()
	fake.CFReserveExpansionStub = stub
}

func (fake *FakeClient) CFReserveExpansionArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.cFReserveExpansionMutex.RLock()
	defer fake.cFReserveExpansionMutex.RUnlock()
	argsForCall := fake.cFReserveExpansionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) CFReserveExpansionReturns(result1 *redisa.StatusCmd) {
	fake.cFReserveExpansionMutex.Lock()
	defer fake.cFReserveExpansionMutex.Unlock()
	fake.CFReserveExpansionStub = nil
	fake.cFReserveExpansionReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CFReserveExpansionReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.cFReserveExpansionMutex.Lock()
	defer fake.cFReserveExpansionMutex.Unlock()
	fake.CFReserveExpansionStub = nil
	if fake.cFReserveExpansionReturnsOnCall == nil {
		fake.cFReserveExpansionReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.cFReserveExpansionReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CFReserveMaxIterations(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) *redisa.StatusCmd {
	fake.cFReserveMaxIterationsMutex.Lock()
	ret, specificReturn := fake.cFReserveMaxIterationsReturnsOnCall[len(fake.cFReserveMaxIterationsArgsForCall)]
	fake.cFReserveMaxIterationsArgsForCall = append(fake.cFReserveMaxIterationsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.CFReserveMaxIterationsStub
	fakeReturns := fake.cFReserveMaxIterationsReturns
	fake.recordInvocation("CFReserveMaxIterations", []interface{}{arg1, arg2, arg3, arg4})
	fake.cFReserveMaxIterationsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFReserveMaxIterationsCallCount() int {
	fake.cFReserveMaxIterationsMutex.RLock()
	defer fake.cFReserveMaxIterationsMutex.RUnlock()
	return len(fake.cFReserveMaxIterationsArgsForCall)
}

func (fake *FakeClient) CFReserveMaxIterationsCalls(stub func(context.Context, string, int64, int64) *redisa.StatusCmd) {
	fake.cFReserveMaxIterationsMutex.Lock()
	defer fake.cFReserveMaxIterationsMutex.Unlock()
	fake.CFReserveMaxIterationsStub = stub
}

func (fake *FakeClient) CFReserveMaxIterationsArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.cFReserveMaxIterationsMutex.RLock()
	defer fake.cFReserveMaxIterationsMutex.RUnlock()
	argsForCall := fake.cFReserveMaxIterationsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) CFReserveMaxIterationsReturns(result1 *redisa.StatusCmd) {
	fake.cFReserveMaxIterationsMutex.Lock()
	defer fake.cFReserveMaxIterationsMutex.Unlock()
	fake.CFReserveMaxIterationsStub = nil
	fake.cFReserveMaxIterationsReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CFReserveMaxIterationsReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.cFReserveMaxIterationsMutex.Lock()
	defer fake.cFReserveMaxIterationsMutex.Unlock()
	fake.CFReserveMaxIterationsStub = nil
	if fake.cFReserveMaxIterationsReturnsOnCall == nil {
		fake.cFReserveMaxIterationsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.cFReserveMaxIterationsReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CFReserveWithArgs(arg1 context.Context, arg2 string, arg3 *redisa.CFReserveOptions) *redisa.StatusCmd {
	fake.cFReserveWithArgsMutex.Lock()
	ret, specificReturn := fake.cFReserveWithArgsReturnsOnCall[len(fake.cFReserveWithArgsArgsForCall)]
	fake.cFReserveWithArgsArgsForCall = append(fake.cFReserveWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.CFReserveOptions
	}{arg1, arg2, arg3})
	stub := fake.CFReserveWithArgsStub
	fakeReturns := fake.cFReserveWithArgsReturns
	fake.recordInvocation("CFReserveWithArgs", []interface{}{arg1, arg2, arg3})
	fake.cFReserveWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFReserveWithArgsCallCount() int {
	fake.cFReserveWithArgsMutex.RLock()
	defer fake.cFReserveWithArgsMutex.RUnlock()
	return len(fake.cFReserveWithArgsArgsForCall)
}

func (fake *FakeClient) CFReserveWithArgsCalls(stub func(context.Context, string, *redisa.CFReserveOptions) *redisa.StatusCmd) {
	fake.cFReserveWithArgsMutex.Lock()
	defer fake.cFReserveWithArgsMutex.Unlock()
	fake.CFReserveWithArgsStub = stub
}

func (fake *FakeClient) CFReserveWithArgsArgsForCall(i int) (context.Context, string, *redisa.CFReserveOptions) {
	fake.cFReserveWithArgsMutex.RLock()
	defer fake.cFReserveWithArgsMutex.RUnlock()
	argsForCall := fake.cFReserveWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CFReserveWithArgsReturns(result1 *redisa.StatusCmd) {
	fake.cFReserveWithArgsMutex.Lock()
	defer fake.cFReserveWithArgsMutex.Unlock()
	fake.CFReserveWithArgsStub = nil
	fake.cFReserveWithArgsReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CFReserveWithArgsReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.cFReserveWithArgsMutex.Lock()
	defer fake.cFReserveWithArgsMutex.Unlock()
	fake.CFReserveWithArgsStub = nil
	if fake.cFReserveWithArgsReturnsOnCall == nil {
		fake.cFReserveWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.cFReserveWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CFScanDump(arg1 context.Context, arg2 string, arg3 int64) *redisa.ScanDumpCmd {
	fake.cFScanDumpMutex.Lock()
	ret, specificReturn := fake.cFScanDumpReturnsOnCall[len(fake.cFScanDumpArgsForCall)]
	fake.cFScanDumpArgsForCall = append(fake.cFScanDumpArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.CFScanDumpStub
	fakeReturns := fake.cFScanDumpReturns
	fake.recordInvocation("CFScanDump", []interface{}{arg1, arg2, arg3})
	fake.cFScanDumpMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CFScanDumpCallCount() int {
	fake.cFScanDumpMutex.RLock()
	defer fake.cFScanDumpMutex.RUnlock()
	return len(fake.cFScanDumpArgsForCall)
}

func (fake *FakeClient) CFScanDumpCalls(stub func(context.Context, string, int64) *redisa.ScanDumpCmd) {
	fake.cFScanDumpMutex.Lock()
	defer fake.cFScanDumpMutex.Unlock()
	fake.CFScanDumpStub = stub
}

func (fake *FakeClient) CFScanDumpArgsForCall(i int) (context.Context, string, int64) {
	fake.cFScanDumpMutex.RLock()
	defer fake.cFScanDumpMutex.RUnlock()
	argsForCall := fake.cFScanDumpArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CFScanDumpReturns(result1 *redisa.ScanDumpCmd) {
	fake.cFScanDumpMutex.Lock()
	defer fake.cFScanDumpMutex.Unlock()
	fake.CFScanDumpStub = nil
	fake.cFScanDumpReturns = struct {
		result1 *redisa.ScanDumpCmd
	}{result1}
}

func (fake *FakeClient) CFScanDumpReturnsOnCall(i int, result1 *redisa.ScanDumpCmd) {
	fake.cFScanDumpMutex.Lock()
	defer fake.cFScanDumpMutex.Unlock()
	fake.CFScanDumpStub = nil
	if fake.cFScanDumpReturnsOnCall == nil {
		fake.cFScanDumpReturnsOnCall = make(map[int]struct {
			result1 *redisa.ScanDumpCmd
		})
	}
	fake.cFScanDumpReturnsOnCall[i] = struct {
		result1 *redisa.ScanDumpCmd
	}{result1}
}

func (fake *FakeClient) CMSIncrBy(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntSliceCmd {
	fake.cMSIncrByMutex.Lock()
	ret, specificReturn := fake.cMSIncrByReturnsOnCall[len(fake.cMSIncrByArgsForCall)]
	fake.cMSIncrByArgsForCall = append(fake.cMSIncrByArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.CMSIncrByStub
	fakeReturns := fake.cMSIncrByReturns
	fake.recordInvocation("CMSIncrBy", []interface{}{arg1, arg2, arg3})
	fake.cMSIncrByMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CMSIncrByCallCount() int {
	fake.cMSIncrByMutex.RLock()
	defer fake.cMSIncrByMutex.RUnlock()
	return len(fake.cMSIncrByArgsForCall)
}

func (fake *FakeClient) CMSIncrByCalls(stub func(context.Context, string, ...interface{}) *redisa.IntSliceCmd) {
	fake.cMSIncrByMutex.Lock()
	defer fake.cMSIncrByMutex.Unlock()
	fake.CMSIncrByStub = stub
}

func (fake *FakeClient) CMSIncrByArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.cMSIncrByMutex.RLock()
	defer fake.cMSIncrByMutex.RUnlock()
	argsForCall := fake.cMSIncrByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CMSIncrByReturns(result1 *redisa.IntSliceCmd) {
	fake.cMSIncrByMutex.Lock()
	defer fake.cMSIncrByMutex.Unlock()
	fake.CMSIncrByStub = nil
	fake.cMSIncrByReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) CMSIncrByReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.cMSIncrByMutex.Lock()
	defer fake.cMSIncrByMutex.Unlock()
	fake.CMSIncrByStub = nil
	if fake.cMSIncrByReturnsOnCall == nil {
		fake.cMSIncrByReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.cMSIncrByReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) CMSInfo(arg1 context.Context, arg2 string) *redisa.CMSInfoCmd {
	fake.cMSInfoMutex.Lock()
	ret, specificReturn := fake.cMSInfoReturnsOnCall[len(fake.cMSInfoArgsForCall)]
	fake.cMSInfoArgsForCall = append(fake.cMSInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CMSInfoStub
	fakeReturns := fake.cMSInfoReturns
	fake.recordInvocation("CMSInfo", []interface{}{arg1, arg2})
	fake.cMSInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CMSInfoCallCount() int {
	fake.cMSInfoMutex.RLock()
	defer fake.cMSInfoMutex.RUnlock()
	return len(fake.cMSInfoArgsForCall)
}

func (fake *FakeClient) CMSInfoCalls(stub func(context.Context, string) *redisa.CMSInfoCmd) {
	fake.cMSInfoMutex.Lock()
	defer fake.cMSInfoMutex.Unlock()
	fake.CMSInfoStub = stub
}

func (fake *FakeClient) CMSInfoArgsForCall(i int) (context.Context, string) {
	fake.cMSInfoMutex.RLock()
	defer fake.cMSInfoMutex.RUnlock()
	argsForCall := fake.cMSInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) CMSInfoReturns(result1 *redisa.CMSInfoCmd) {
	fake.cMSInfoMutex.Lock()
	defer fake.cMSInfoMutex.Unlock()
	fake.CMSInfoStub = nil
	fake.cMSInfoReturns = struct {
		result1 *redisa.CMSInfoCmd
	}{result1}
}

func (fake *FakeClient) CMSInfoReturnsOnCall(i int, result1 *redisa.CMSInfoCmd) {
	fake.cMSInfoMutex.Lock()
	defer fake.cMSInfoMutex.Unlock()
	fake.CMSInfoStub = nil
	if fake.cMSInfoReturnsOnCall == nil {
		fake.cMSInfoReturnsOnCall = make(map[int]struct {
			result1 *redisa.CMSInfoCmd
		})
	}
	fake.cMSInfoReturnsOnCall[i] = struct {
		result1 *redisa.CMSInfoCmd
	}{result1}
}

func (fake *FakeClient) CMSInitByDim(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) *redisa.StatusCmd {
	fake.cMSInitByDimMutex.Lock()
	ret, specificReturn := fake.cMSInitByDimReturnsOnCall[len(fake.cMSInitByDimArgsForCall)]
	fake.cMSInitByDimArgsForCall = append(fake.cMSInitByDimArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.CMSInitByDimStub
	fakeReturns := fake.cMSInitByDimReturns
	fake.recordInvocation("CMSInitByDim", []interface{}{arg1, arg2, arg3, arg4})
	fake.cMSInitByDimMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CMSInitByDimCallCount() int {
	fake.cMSInitByDimMutex.RLock()
	defer fake.cMSInitByDimMutex.RUnlock()
	return len(fake.cMSInitByDimArgsForCall)
}

func (fake *FakeClient) CMSInitByDimCalls(stub func(context.Context, string, int64, int64) *redisa.StatusCmd) {
	fake.cMSInitByDimMutex.Lock()
	defer fake.cMSInitByDimMutex.Unlock()
	fake.CMSInitByDimStub = stub
}

func (fake *FakeClient) CMSInitByDimArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.cMSInitByDimMutex.RLock()
	defer fake.cMSInitByDimMutex.RUnlock()
	argsForCall := fake.cMSInitByDimArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) CMSInitByDimReturns(result1 *redisa.StatusCmd) {
	fake.cMSInitByDimMutex.Lock()
	defer fake.cMSInitByDimMutex.Unlock()
	fake.CMSInitByDimStub = nil
	fake.cMSInitByDimReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CMSInitByDimReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.cMSInitByDimMutex.Lock()
	defer fake.cMSInitByDimMutex.Unlock()
	fake.CMSInitByDimStub = nil
	if fake.cMSInitByDimReturnsOnCall == nil {
		fake.cMSInitByDimReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.cMSInitByDimReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CMSInitByProb(arg1 context.Context, arg2 string, arg3 float64, arg4 float64) *redisa.StatusCmd {
	fake.cMSInitByProbMutex.Lock()
	ret, specificReturn := fake.cMSInitByProbReturnsOnCall[len(fake.cMSInitByProbArgsForCall)]
	fake.cMSInitByProbArgsForCall = append(fake.cMSInitByProbArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 float64
	}{arg1, arg2, arg3, arg4})
	stub := fake.CMSInitByProbStub
	fakeReturns := fake.cMSInitByProbReturns
	fake.recordInvocation("CMSInitByProb", []interface{}{arg1, arg2, arg3, arg4})
	fake.cMSInitByProbMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CMSInitByProbCallCount() int {
	fake.cMSInitByProbMutex.RLock()
	defer fake.cMSInitByProbMutex.RUnlock()
	return len(fake.cMSInitByProbArgsForCall)
}

func (fake *FakeClient) CMSInitByProbCalls(stub func(context.Context, string, float64, float64) *redisa.StatusCmd) {
	fake.cMSInitByProbMutex.Lock()
	defer fake.cMSInitByProbMutex.Unlock()
	fake.CMSInitByProbStub = stub
}

func (fake *FakeClient) CMSInitByProbArgsForCall(i int) (context.Context, string, float64, float64) {
	fake.cMSInitByProbMutex.RLock()
	defer fake.cMSInitByProbMutex.RUnlock()
	argsForCall := fake.cMSInitByProbArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) CMSInitByProbReturns(result1 *redisa.StatusCmd) {
	fake.cMSInitByProbMutex.Lock()
	defer fake.cMSInitByProbMutex.Unlock()
	fake.CMSInitByProbStub = nil
	fake.cMSInitByProbReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CMSInitByProbReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.cMSInitByProbMutex.Lock()
	defer fake.cMSInitByProbMutex.Unlock()
	fake.CMSInitByProbStub = nil
	if fake.cMSInitByProbReturnsOnCall == nil {
		fake.cMSInitByProbReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.cMSInitByProbReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CMSMerge(arg1 context.Context, arg2 string, arg3 ...string) *redisa.StatusCmd {
	fake.cMSMergeMutex.Lock()
	ret, specificReturn := fake.cMSMergeReturnsOnCall[len(fake.cMSMergeArgsForCall)]
	fake.cMSMergeArgsForCall = append(fake.cMSMergeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.CMSMergeStub
	fakeReturns := fake.cMSMergeReturns
	fake.recordInvocation("CMSMerge", []interface{}{arg1, arg2, arg3})
	fake.cMSMergeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CMSMergeCallCount() int {
	fake.cMSMergeMutex.RLock()
	defer fake.cMSMergeMutex.RUnlock()
	return len(fake.cMSMergeArgsForCall)
}

func (fake *FakeClient) CMSMergeCalls(stub func(context.Context, string, ...string) *redisa.StatusCmd) {
	fake.cMSMergeMutex.Lock()
	defer fake.cMSMergeMutex.Unlock()
	fake.CMSMergeStub = stub
}

func (fake *FakeClient) CMSMergeArgsForCall(i int) (context.Context, string, []string) {
	fake.cMSMergeMutex.RLock()
	defer fake.cMSMergeMutex.RUnlock()
	argsForCall := fake.cMSMergeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CMSMergeReturns(result1 *redisa.StatusCmd) {
	fake.cMSMergeMutex.Lock()
	defer fake.cMSMergeMutex.Unlock()
	fake.CMSMergeStub = nil
	fake.cMSMergeReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CMSMergeReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.cMSMergeMutex.Lock()
	defer fake.cMSMergeMutex.Unlock()
	fake.CMSMergeStub = nil
	if fake.cMSMergeReturnsOnCall == nil {
		fake.cMSMergeReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.cMSMergeReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CMSMergeWithWeight(arg1 context.Context, arg2 string, arg3 map[string]int64) *redisa.StatusCmd {
	fake.cMSMergeWithWeightMutex.Lock()
	ret, specificReturn := fake.cMSMergeWithWeightReturnsOnCall[len(fake.cMSMergeWithWeightArgsForCall)]
	fake.cMSMergeWithWeightArgsForCall = append(fake.cMSMergeWithWeightArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 map[string]int64
	}{arg1, arg2, arg3})
	stub := fake.CMSMergeWithWeightStub
	fakeReturns := fake.cMSMergeWithWeightReturns
	fake.recordInvocation("CMSMergeWithWeight", []interface{}{arg1, arg2, arg3})
	fake.cMSMergeWithWeightMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CMSMergeWithWeightCallCount() int {
	fake.cMSMergeWithWeightMutex.RLock()
	defer fake.cMSMergeWithWeightMutex.RUnlock()
	return len(fake.cMSMergeWithWeightArgsForCall)
}

func (fake *FakeClient) CMSMergeWithWeightCalls(stub func(context.Context, string, map[string]int64) *redisa.StatusCmd) {
	fake.cMSMergeWithWeightMutex.Lock()
	defer fake.cMSMergeWithWeightMutex.Unlock()
	fake.CMSMergeWithWeightStub = stub
}

func (fake *FakeClient) CMSMergeWithWeightArgsForCall(i int) (context.Context, string, map[string]int64) {
	fake.cMSMergeWithWeightMutex.RLock()
	defer fake.cMSMergeWithWeightMutex.RUnlock()
	argsForCall := fake.cMSMergeWithWeightArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CMSMergeWithWeightReturns(result1 *redisa.StatusCmd) {
	fake.cMSMergeWithWeightMutex.Lock()
	defer fake.cMSMergeWithWeightMutex.Unlock()
	fake.CMSMergeWithWeightStub = nil
	fake.cMSMergeWithWeightReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CMSMergeWithWeightReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.cMSMergeWithWeightMutex.Lock()
	defer fake.cMSMergeWithWeightMutex.Unlock()
	fake.CMSMergeWithWeightStub = nil
	if fake.cMSMergeWithWeightReturnsOnCall == nil {
		fake.cMSMergeWithWeightReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.cMSMergeWithWeightReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) CMSQuery(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntSliceCmd {
	fake.cMSQueryMutex.Lock()
	ret, specificReturn := fake.cMSQueryReturnsOnCall[len(fake.cMSQueryArgsForCall)]
	fake.cMSQueryArgsForCall = append(fake.cMSQueryArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.CMSQueryStub
	fakeReturns := fake.cMSQueryReturns
	fake.recordInvocation("CMSQuery", []interface{}{arg1, arg2, arg3})
	fake.cMSQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CMSQueryCallCount() int {
	fake.cMSQueryMutex.RLock()
	defer fake.cMSQueryMutex.RUnlock()
	return len(fake.cMSQueryArgsForCall)
}

func (fake *FakeClient) CMSQueryCalls(stub func(context.Context, string, ...interface{}) *redisa.IntSliceCmd) {
	fake.cMSQueryMutex.Lock()
	defer fake.cMSQueryMutex.Unlock()
	fake.CMSQueryStub = stub
}

func (fake *FakeClient) CMSQueryArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.cMSQueryMutex.RLock()
	defer fake.cMSQueryMutex.RUnlock()
	argsForCall := fake.cMSQueryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CMSQueryReturns(result1 *redisa.IntSliceCmd) {
	fake.cMSQueryMutex.Lock()
	defer fake.cMSQueryMutex.Unlock()
	fake.CMSQueryStub = nil
	fake.cMSQueryReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) CMSQueryReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.cMSQueryMutex.Lock()
	defer fake.cMSQueryMutex.Unlock()
	fake.CMSQueryStub = nil
	if fake.cMSQueryReturnsOnCall == nil {
		fake.cMSQueryReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.cMSQueryReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) ClientGetName(arg1 context.Context) *redisa.StringCmd {
	fake.clientGetNameMutex.Lock()
	ret, specificReturn := fake.clientGetNameReturnsOnCall[len(fake.clientGetNameArgsForCall)]
	fake.clientGetNameArgsForCall = append(fake.clientGetNameArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClientGetNameStub
	fakeReturns := fake.clientGetNameReturns
	fake.recordInvocation("ClientGetName", []interface{}{arg1})
	fake.clientGetNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClientGetNameCallCount() int {
	fake.clientGetNameMutex.RLock()
	defer fake.clientGetNameMutex.RUnlock()
	return len(fake.clientGetNameArgsForCall)
}

func (fake *FakeClient) ClientGetNameCalls(stub func(context.Context) *redisa.StringCmd) {
	fake.clientGetNameMutex.Lock()
	defer fake.clientGetNameMutex.Unlock()
	fake.ClientGetNameStub = stub
}

func (fake *FakeClient) ClientGetNameArgsForCall(i int) context.Context {
	fake.clientGetNameMutex.RLock()
	defer fake.clientGetNameMutex.RUnlock()
	argsForCall := fake.clientGetNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClientGetNameReturns(result1 *redisa.StringCmd) {
	fake.clientGetNameMutex.Lock()
	defer fake.clientGetNameMutex.Unlock()
	fake.ClientGetNameStub = nil
	fake.clientGetNameReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ClientGetNameReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.clientGetNameMutex.Lock()
	defer fake.clientGetNameMutex.Unlock()
	fake.ClientGetNameStub = nil
	if fake.clientGetNameReturnsOnCall == nil {
		fake.clientGetNameReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.clientGetNameReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ClientID(arg1 context.Context) *redisa.IntCmd {
	fake.clientIDMutex.Lock()
	ret, specificReturn := fake.clientIDReturnsOnCall[len(fake.clientIDArgsForCall)]
	fake.clientIDArgsForCall = append(fake.clientIDArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClientIDStub
	fakeReturns := fake.clientIDReturns
	fake.recordInvocation("ClientID", []interface{}{arg1})
	fake.clientIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClientIDCallCount() int {
	fake.clientIDMutex.RLock()
	defer fake.clientIDMutex.RUnlock()
	return len(fake.clientIDArgsForCall)
}

func (fake *FakeClient) ClientIDCalls(stub func(context.Context) *redisa.IntCmd) {
	fake.clientIDMutex.Lock()
	defer fake.clientIDMutex.Unlock()
	fake.ClientIDStub = stub
}

func (fake *FakeClient) ClientIDArgsForCall(i int) context.Context {
	fake.clientIDMutex.RLock()
	defer fake.clientIDMutex.RUnlock()
	argsForCall := fake.clientIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClientIDReturns(result1 *redisa.IntCmd) {
	fake.clientIDMutex.Lock()
	defer fake.clientIDMutex.Unlock()
	fake.ClientIDStub = nil
	fake.clientIDReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClientIDReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.clientIDMutex.Lock()
	defer fake.clientIDMutex.Unlock()
	fake.ClientIDStub = nil
	if fake.clientIDReturnsOnCall == nil {
		fake.clientIDReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.clientIDReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClientInfo(arg1 context.Context) *redisa.ClientInfoCmd {
	fake.clientInfoMutex.Lock()
	ret, specificReturn := fake.clientInfoReturnsOnCall[len(fake.clientInfoArgsForCall)]
	fake.clientInfoArgsForCall = append(fake.clientInfoArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClientInfoStub
	fakeReturns := fake.clientInfoReturns
	fake.recordInvocation("ClientInfo", []interface{}{arg1})
	fake.clientInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClientInfoCallCount() int {
	fake.clientInfoMutex.RLock()
	defer fake.clientInfoMutex.RUnlock()
	return len(fake.clientInfoArgsForCall)
}

func (fake *FakeClient) ClientInfoCalls(stub func(context.Context) *redisa.ClientInfoCmd) {
	fake.clientInfoMutex.Lock()
	defer fake.clientInfoMutex.Unlock()
	fake.ClientInfoStub = stub
}

func (fake *FakeClient) ClientInfoArgsForCall(i int) context.Context {
	fake.clientInfoMutex.RLock()
	defer fake.clientInfoMutex.RUnlock()
	argsForCall := fake.clientInfoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClientInfoReturns(result1 *redisa.ClientInfoCmd) {
	fake.clientInfoMutex.Lock()
	defer fake.clientInfoMutex.Unlock()
	fake.ClientInfoStub = nil
	fake.clientInfoReturns = struct {
		result1 *redisa.ClientInfoCmd
	}{result1}
}

func (fake *FakeClient) ClientInfoReturnsOnCall(i int, result1 *redisa.ClientInfoCmd) {
	fake.clientInfoMutex.Lock()
	defer fake.clientInfoMutex.Unlock()
	fake.ClientInfoStub = nil
	if fake.clientInfoReturnsOnCall == nil {
		fake.clientInfoReturnsOnCall = make(map[int]struct {
			result1 *redisa.ClientInfoCmd
		})
	}
	fake.clientInfoReturnsOnCall[i] = struct {
		result1 *redisa.ClientInfoCmd
	}{result1}
}

func (fake *FakeClient) ClientKill(arg1 context.Context, arg2 string) *redisa.StatusCmd {
	fake.clientKillMutex.Lock()
	ret, specificReturn := fake.clientKillReturnsOnCall[len(fake.clientKillArgsForCall)]
	fake.clientKillArgsForCall = append(fake.clientKillArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ClientKillStub
	fakeReturns := fake.clientKillReturns
	fake.recordInvocation("ClientKill", []interface{}{arg1, arg2})
	fake.clientKillMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClientKillCallCount() int {
	fake.clientKillMutex.RLock()
	defer fake.clientKillMutex.RUnlock()
	return len(fake.clientKillArgsForCall)
}

func (fake *FakeClient) ClientKillCalls(stub func(context.Context, string) *redisa.StatusCmd) {
	fake.clientKillMutex.Lock()
	defer fake.clientKillMutex.Unlock()
	fake.ClientKillStub = stub
}

func (fake *FakeClient) ClientKillArgsForCall(i int) (context.Context, string) {
	fake.clientKillMutex.RLock()
	defer fake.clientKillMutex.RUnlock()
	argsForCall := fake.clientKillArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ClientKillReturns(result1 *redisa.StatusCmd) {
	fake.clientKillMutex.Lock()
	defer fake.clientKillMutex.Unlock()
	fake.ClientKillStub = nil
	fake.clientKillReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClientKillReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.clientKillMutex.Lock()
	defer fake.clientKillMutex.Unlock()
	fake.ClientKillStub = nil
	if fake.clientKillReturnsOnCall == nil {
		fake.clientKillReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.clientKillReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClientKillByFilter(arg1 context.Context, arg2 ...string) *redisa.IntCmd {
	fake.clientKillByFilterMutex.Lock()
	ret, specificReturn := fake.clientKillByFilterReturnsOnCall[len(fake.clientKillByFilterArgsForCall)]
	fake.clientKillByFilterArgsForCall = append(fake.clientKillByFilterArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.ClientKillByFilterStub
	fakeReturns := fake.clientKillByFilterReturns
	fake.recordInvocation("ClientKillByFilter", []interface{}{arg1, arg2})
	fake.clientKillByFilterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClientKillByFilterCallCount() int {
	fake.clientKillByFilterMutex.RLock()
	defer fake.clientKillByFilterMutex.RUnlock()
	return len(fake.clientKillByFilterArgsForCall)
}

func (fake *FakeClient) ClientKillByFilterCalls(stub func(context.Context, ...string) *redisa.IntCmd) {
	fake.clientKillByFilterMutex.Lock()
	defer fake.clientKillByFilterMutex.Unlock()
	fake.ClientKillByFilterStub = stub
}

func (fake *FakeClient) ClientKillByFilterArgsForCall(i int) (context.Context, []string) {
	fake.clientKillByFilterMutex.RLock()
	defer fake.clientKillByFilterMutex.RUnlock()
	argsForCall := fake.clientKillByFilterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ClientKillByFilterReturns(result1 *redisa.IntCmd) {
	fake.clientKillByFilterMutex.Lock()
	defer fake.clientKillByFilterMutex.Unlock()
	fake.ClientKillByFilterStub = nil
	fake.clientKillByFilterReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClientKillByFilterReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.clientKillByFilterMutex.Lock()
	defer fake.clientKillByFilterMutex.Unlock()
	fake.ClientKillByFilterStub = nil
	if fake.clientKillByFilterReturnsOnCall == nil {
		fake.clientKillByFilterReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.clientKillByFilterReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClientList(arg1 context.Context) *redisa.StringCmd {
	fake.clientListMutex.Lock()
	ret, specificReturn := fake.clientListReturnsOnCall[len(fake.clientListArgsForCall)]
	fake.clientListArgsForCall = append(fake.clientListArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClientListStub
	fakeReturns := fake.clientListReturns
	fake.recordInvocation("ClientList", []interface{}{arg1})
	fake.clientListMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClientListCallCount() int {
	fake.clientListMutex.RLock()
	defer fake.clientListMutex.RUnlock()
	return len(fake.clientListArgsForCall)
}

func (fake *FakeClient) ClientListCalls(stub func(context.Context) *redisa.StringCmd) {
	fake.clientListMutex.Lock()
	defer fake.clientListMutex.Unlock()
	fake.ClientListStub = stub
}

func (fake *FakeClient) ClientListArgsForCall(i int) context.Context {
	fake.clientListMutex.RLock()
	defer fake.clientListMutex.RUnlock()
	argsForCall := fake.clientListArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClientListReturns(result1 *redisa.StringCmd) {
	fake.clientListMutex.Lock()
	defer fake.clientListMutex.Unlock()
	fake.ClientListStub = nil
	fake.clientListReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ClientListReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.clientListMutex.Lock()
	defer fake.clientListMutex.Unlock()
	fake.ClientListStub = nil
	if fake.clientListReturnsOnCall == nil {
		fake.clientListReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.clientListReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ClientPause(arg1 context.Context, arg2 time.Duration) *redisa.BoolCmd {
	fake.clientPauseMutex.Lock()
	ret, specificReturn := fake.clientPauseReturnsOnCall[len(fake.clientPauseArgsForCall)]
	fake.clientPauseArgsForCall = append(fake.clientPauseArgsForCall, struct {
		arg1 context.Context
		arg2 time.Duration
	}{arg1, arg2})
	stub := fake.ClientPauseStub
	fakeReturns := fake.clientPauseReturns
	fake.recordInvocation("ClientPause", []interface{}{arg1, arg2})
	fake.clientPauseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClientPauseCallCount() int {
	fake.clientPauseMutex.RLock()
	defer fake.clientPauseMutex.RUnlock()
	return len(fake.clientPauseArgsForCall)
}

func (fake *FakeClient) ClientPauseCalls(stub func(context.Context, time.Duration) *redisa.BoolCmd) {
	fake.clientPauseMutex.Lock()
	defer fake.clientPauseMutex.Unlock()
	fake.ClientPauseStub = stub
}

func (fake *FakeClient) ClientPauseArgsForCall(i int) (context.Context, time.Duration) {
	fake.clientPauseMutex.RLock()
	defer fake.clientPauseMutex.RUnlock()
	argsForCall := fake.clientPauseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ClientPauseReturns(result1 *redisa.BoolCmd) {
	fake.clientPauseMutex.Lock()
	defer fake.clientPauseMutex.Unlock()
	fake.ClientPauseStub = nil
	fake.clientPauseReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ClientPauseReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.clientPauseMutex.Lock()
	defer fake.clientPauseMutex.Unlock()
	fake.ClientPauseStub = nil
	if fake.clientPauseReturnsOnCall == nil {
		fake.clientPauseReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.clientPauseReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ClientUnblock(arg1 context.Context, arg2 int64) *redisa.IntCmd {
	fake.clientUnblockMutex.Lock()
	ret, specificReturn := fake.clientUnblockReturnsOnCall[len(fake.clientUnblockArgsForCall)]
	fake.clientUnblockArgsForCall = append(fake.clientUnblockArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.ClientUnblockStub
	fakeReturns := fake.clientUnblockReturns
	fake.recordInvocation("ClientUnblock", []interface{}{arg1, arg2})
	fake.clientUnblockMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClientUnblockCallCount() int {
	fake.clientUnblockMutex.RLock()
	defer fake.clientUnblockMutex.RUnlock()
	return len(fake.clientUnblockArgsForCall)
}

func (fake *FakeClient) ClientUnblockCalls(stub func(context.Context, int64) *redisa.IntCmd) {
	fake.clientUnblockMutex.Lock()
	defer fake.clientUnblockMutex.Unlock()
	fake.ClientUnblockStub = stub
}

func (fake *FakeClient) ClientUnblockArgsForCall(i int) (context.Context, int64) {
	fake.clientUnblockMutex.RLock()
	defer fake.clientUnblockMutex.RUnlock()
	argsForCall := fake.clientUnblockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ClientUnblockReturns(result1 *redisa.IntCmd) {
	fake.clientUnblockMutex.Lock()
	defer fake.clientUnblockMutex.Unlock()
	fake.ClientUnblockStub = nil
	fake.clientUnblockReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClientUnblockReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.clientUnblockMutex.Lock()
	defer fake.clientUnblockMutex.Unlock()
	fake.ClientUnblockStub = nil
	if fake.clientUnblockReturnsOnCall == nil {
		fake.clientUnblockReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.clientUnblockReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClientUnblockWithError(arg1 context.Context, arg2 int64) *redisa.IntCmd {
	fake.clientUnblockWithErrorMutex.Lock()
	ret, specificReturn := fake.clientUnblockWithErrorReturnsOnCall[len(fake.clientUnblockWithErrorArgsForCall)]
	fake.clientUnblockWithErrorArgsForCall = append(fake.clientUnblockWithErrorArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.ClientUnblockWithErrorStub
	fakeReturns := fake.clientUnblockWithErrorReturns
	fake.recordInvocation("ClientUnblockWithError", []interface{}{arg1, arg2})
	fake.clientUnblockWithErrorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClientUnblockWithErrorCallCount() int {
	fake.clientUnblockWithErrorMutex.RLock()
	defer fake.clientUnblockWithErrorMutex.RUnlock()
	return len(fake.clientUnblockWithErrorArgsForCall)
}

func (fake *FakeClient) ClientUnblockWithErrorCalls(stub func(context.Context, int64) *redisa.IntCmd) {
	fake.clientUnblockWithErrorMutex.Lock()
	defer fake.clientUnblockWithErrorMutex.Unlock()
	fake.ClientUnblockWithErrorStub = stub
}

func (fake *FakeClient) ClientUnblockWithErrorArgsForCall(i int) (context.Context, int64) {
	fake.clientUnblockWithErrorMutex.RLock()
	defer fake.clientUnblockWithErrorMutex.RUnlock()
	argsForCall := fake.clientUnblockWithErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ClientUnblockWithErrorReturns(result1 *redisa.IntCmd) {
	fake.clientUnblockWithErrorMutex.Lock()
	defer fake.clientUnblockWithErrorMutex.Unlock()
	fake.ClientUnblockWithErrorStub = nil
	fake.clientUnblockWithErrorReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClientUnblockWithErrorReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.clientUnblockWithErrorMutex.Lock()
	defer fake.clientUnblockWithErrorMutex.Unlock()
	fake.ClientUnblockWithErrorStub = nil
	if fake.clientUnblockWithErrorReturnsOnCall == nil {
		fake.clientUnblockWithErrorReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.clientUnblockWithErrorReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClientUnpause(arg1 context.Context) *redisa.BoolCmd {
	fake.clientUnpauseMutex.Lock()
	ret, specificReturn := fake.clientUnpauseReturnsOnCall[len(fake.clientUnpauseArgsForCall)]
	fake.clientUnpauseArgsForCall = append(fake.clientUnpauseArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClientUnpauseStub
	fakeReturns := fake.clientUnpauseReturns
	fake.recordInvocation("ClientUnpause", []interface{}{arg1})
	fake.clientUnpauseMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClientUnpauseCallCount() int {
	fake.clientUnpauseMutex.RLock()
	defer fake.clientUnpauseMutex.RUnlock()
	return len(fake.clientUnpauseArgsForCall)
}

func (fake *FakeClient) ClientUnpauseCalls(stub func(context.Context) *redisa.BoolCmd) {
	fake.clientUnpauseMutex.Lock()
	defer fake.clientUnpauseMutex.Unlock()
	fake.ClientUnpauseStub = stub
}

func (fake *FakeClient) ClientUnpauseArgsForCall(i int) context.Context {
	fake.clientUnpauseMutex.RLock()
	defer fake.clientUnpauseMutex.RUnlock()
	argsForCall := fake.clientUnpauseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClientUnpauseReturns(result1 *redisa.BoolCmd) {
	fake.clientUnpauseMutex.Lock()
	defer fake.clientUnpauseMutex.Unlock()
	fake.ClientUnpauseStub = nil
	fake.clientUnpauseReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ClientUnpauseReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.clientUnpauseMutex.Lock()
	defer fake.clientUnpauseMutex.Unlock()
	fake.ClientUnpauseStub = nil
	if fake.clientUnpauseReturnsOnCall == nil {
		fake.clientUnpauseReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.clientUnpauseReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeClient) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeClient) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ClusterAddSlots(arg1 context.Context, arg2 ...int) *redisa.StatusCmd {
	fake.clusterAddSlotsMutex.Lock()
	ret, specificReturn := fake.clusterAddSlotsReturnsOnCall[len(fake.clusterAddSlotsArgsForCall)]
	fake.clusterAddSlotsArgsForCall = append(fake.clusterAddSlotsArgsForCall, struct {
		arg1 context.Context
		arg2 []int
	}{arg1, arg2})
	stub := fake.ClusterAddSlotsStub
	fakeReturns := fake.clusterAddSlotsReturns
	fake.recordInvocation("ClusterAddSlots", []interface{}{arg1, arg2})
	fake.clusterAddSlotsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterAddSlotsCallCount() int {
	fake.clusterAddSlotsMutex.RLock()
	defer fake.clusterAddSlotsMutex.RUnlock()
	return len(fake.clusterAddSlotsArgsForCall)
}

func (fake *FakeClient) ClusterAddSlotsCalls(stub func(context.Context, ...int) *redisa.StatusCmd) {
	fake.clusterAddSlotsMutex.Lock()
	defer fake.clusterAddSlotsMutex.Unlock()
	fake.ClusterAddSlotsStub = stub
}

func (fake *FakeClient) ClusterAddSlotsArgsForCall(i int) (context.Context, []int) {
	fake.clusterAddSlotsMutex.RLock()
	defer fake.clusterAddSlotsMutex.RUnlock()
	argsForCall := fake.clusterAddSlotsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ClusterAddSlotsReturns(result1 *redisa.StatusCmd) {
	fake.clusterAddSlotsMutex.Lock()
	defer fake.clusterAddSlotsMutex.Unlock()
	fake.ClusterAddSlotsStub = nil
	fake.clusterAddSlotsReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterAddSlotsReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.clusterAddSlotsMutex.Lock()
	defer fake.clusterAddSlotsMutex.Unlock()
	fake.ClusterAddSlotsStub = nil
	if fake.clusterAddSlotsReturnsOnCall == nil {
		fake.clusterAddSlotsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.clusterAddSlotsReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterAddSlotsRange(arg1 context.Context, arg2 int, arg3 int) *redisa.StatusCmd {
	fake.clusterAddSlotsRangeMutex.Lock()
	ret, specificReturn := fake.clusterAddSlotsRangeReturnsOnCall[len(fake.clusterAddSlotsRangeArgsForCall)]
	fake.clusterAddSlotsRangeArgsForCall = append(fake.clusterAddSlotsRangeArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ClusterAddSlotsRangeStub
	fakeReturns := fake.clusterAddSlotsRangeReturns
	fake.recordInvocation("ClusterAddSlotsRange", []interface{}{arg1, arg2, arg3})
	fake.clusterAddSlotsRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterAddSlotsRangeCallCount() int {
	fake.clusterAddSlotsRangeMutex.RLock()
	defer fake.clusterAddSlotsRangeMutex.RUnlock()
	return len(fake.clusterAddSlotsRangeArgsForCall)
}

func (fake *FakeClient) ClusterAddSlotsRangeCalls(stub func(context.Context, int, int) *redisa.StatusCmd) {
	fake.clusterAddSlotsRangeMutex.Lock()
	defer fake.clusterAddSlotsRangeMutex.Unlock()
	fake.ClusterAddSlotsRangeStub = stub
}

func (fake *FakeClient) ClusterAddSlotsRangeArgsForCall(i int) (context.Context, int, int) {
	fake.clusterAddSlotsRangeMutex.RLock()
	defer fake.clusterAddSlotsRangeMutex.RUnlock()
	argsForCall := fake.clusterAddSlotsRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ClusterAddSlotsRangeReturns(result1 *redisa.StatusCmd) {
	fake.clusterAddSlotsRangeMutex.Lock()
	defer fake.clusterAddSlotsRangeMutex.Unlock()
	fake.ClusterAddSlotsRangeStub = nil
	fake.clusterAddSlotsRangeReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterAddSlotsRangeReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.clusterAddSlotsRangeMutex.Lock()
	defer fake.clusterAddSlotsRangeMutex.Unlock()
	fake.ClusterAddSlotsRangeStub = nil
	if fake.clusterAddSlotsRangeReturnsOnCall == nil {
		fake.clusterAddSlotsRangeReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.clusterAddSlotsRangeReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterCountFailureReports(arg1 context.Context, arg2 string) *redisa.IntCmd {
	fake.clusterCountFailureReportsMutex.Lock()
	ret, specificReturn := fake.clusterCountFailureReportsReturnsOnCall[len(fake.clusterCountFailureReportsArgsForCall)]
	fake.clusterCountFailureReportsArgsForCall = append(fake.clusterCountFailureReportsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ClusterCountFailureReportsStub
	fakeReturns := fake.clusterCountFailureReportsReturns
	fake.recordInvocation("ClusterCountFailureReports", []interface{}{arg1, arg2})
	fake.clusterCountFailureReportsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterCountFailureReportsCallCount() int {
	fake.clusterCountFailureReportsMutex.RLock()
	defer fake.clusterCountFailureReportsMutex.RUnlock()
	return len(fake.clusterCountFailureReportsArgsForCall)
}

func (fake *FakeClient) ClusterCountFailureReportsCalls(stub func(context.Context, string) *redisa.IntCmd) {
	fake.clusterCountFailureReportsMutex.Lock()
	defer fake.clusterCountFailureReportsMutex.Unlock()
	fake.ClusterCountFailureReportsStub = stub
}

func (fake *FakeClient) ClusterCountFailureReportsArgsForCall(i int) (context.Context, string) {
	fake.clusterCountFailureReportsMutex.RLock()
	defer fake.clusterCountFailureReportsMutex.RUnlock()
	argsForCall := fake.clusterCountFailureReportsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ClusterCountFailureReportsReturns(result1 *redisa.IntCmd) {
	fake.clusterCountFailureReportsMutex.Lock()
	defer fake.clusterCountFailureReportsMutex.Unlock()
	fake.ClusterCountFailureReportsStub = nil
	fake.clusterCountFailureReportsReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClusterCountFailureReportsReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.clusterCountFailureReportsMutex.Lock()
	defer fake.clusterCountFailureReportsMutex.Unlock()
	fake.ClusterCountFailureReportsStub = nil
	if fake.clusterCountFailureReportsReturnsOnCall == nil {
		fake.clusterCountFailureReportsReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.clusterCountFailureReportsReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClusterCountKeysInSlot(arg1 context.Context, arg2 int) *redisa.IntCmd {
	fake.clusterCountKeysInSlotMutex.Lock()
	ret, specificReturn := fake.clusterCountKeysInSlotReturnsOnCall[len(fake.clusterCountKeysInSlotArgsForCall)]
	fake.clusterCountKeysInSlotArgsForCall = append(fake.clusterCountKeysInSlotArgsForCall, struct {
		arg1 context.Context
		arg2 int
	}{arg1, arg2})
	stub := fake.ClusterCountKeysInSlotStub
	fakeReturns := fake.clusterCountKeysInSlotReturns
	fake.recordInvocation("ClusterCountKeysInSlot", []interface{}{arg1, arg2})
	fake.clusterCountKeysInSlotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterCountKeysInSlotCallCount() int {
	fake.clusterCountKeysInSlotMutex.RLock()
	defer fake.clusterCountKeysInSlotMutex.RUnlock()
	return len(fake.clusterCountKeysInSlotArgsForCall)
}

func (fake *FakeClient) ClusterCountKeysInSlotCalls(stub func(context.Context, int) *redisa.IntCmd) {
	fake.clusterCountKeysInSlotMutex.Lock()
	defer fake.clusterCountKeysInSlotMutex.Unlock()
	fake.ClusterCountKeysInSlotStub = stub
}

func (fake *FakeClient) ClusterCountKeysInSlotArgsForCall(i int) (context.Context, int) {
	fake.clusterCountKeysInSlotMutex.RLock()
	defer fake.clusterCountKeysInSlotMutex.RUnlock()
	argsForCall := fake.clusterCountKeysInSlotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ClusterCountKeysInSlotReturns(result1 *redisa.IntCmd) {
	fake.clusterCountKeysInSlotMutex.Lock()
	defer fake.clusterCountKeysInSlotMutex.Unlock()
	fake.ClusterCountKeysInSlotStub = nil
	fake.clusterCountKeysInSlotReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClusterCountKeysInSlotReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.clusterCountKeysInSlotMutex.Lock()
	defer fake.clusterCountKeysInSlotMutex.Unlock()
	fake.ClusterCountKeysInSlotStub = nil
	if fake.clusterCountKeysInSlotReturnsOnCall == nil {
		fake.clusterCountKeysInSlotReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.clusterCountKeysInSlotReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClusterDelSlots(arg1 context.Context, arg2 ...int) *redisa.StatusCmd {
	fake.clusterDelSlotsMutex.Lock()
	ret, specificReturn := fake.clusterDelSlotsReturnsOnCall[len(fake.clusterDelSlotsArgsForCall)]
	fake.clusterDelSlotsArgsForCall = append(fake.clusterDelSlotsArgsForCall, struct {
		arg1 context.Context
		arg2 []int
	}{arg1, arg2})
	stub := fake.ClusterDelSlotsStub
	fakeReturns := fake.clusterDelSlotsReturns
	fake.recordInvocation("ClusterDelSlots", []interface{}{arg1, arg2})
	fake.clusterDelSlotsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterDelSlotsCallCount() int {
	fake.clusterDelSlotsMutex.RLock()
	defer fake.clusterDelSlotsMutex.RUnlock()
	return len(fake.clusterDelSlotsArgsForCall)
}

func (fake *FakeClient) ClusterDelSlotsCalls(stub func(context.Context, ...int) *redisa.StatusCmd) {
	fake.clusterDelSlotsMutex.Lock()
	defer fake.clusterDelSlotsMutex.Unlock()
	fake.ClusterDelSlotsStub = stub
}

func (fake *FakeClient) ClusterDelSlotsArgsForCall(i int) (context.Context, []int) {
	fake.clusterDelSlotsMutex.RLock()
	defer fake.clusterDelSlotsMutex.RUnlock()
	argsForCall := fake.clusterDelSlotsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ClusterDelSlotsReturns(result1 *redisa.StatusCmd) {
	fake.clusterDelSlotsMutex.Lock()
	defer fake.clusterDelSlotsMutex.Unlock()
	fake.ClusterDelSlotsStub = nil
	fake.clusterDelSlotsReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterDelSlotsReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.clusterDelSlotsMutex.Lock()
	defer fake.clusterDelSlotsMutex.Unlock()
	fake.ClusterDelSlotsStub = nil
	if fake.clusterDelSlotsReturnsOnCall == nil {
		fake.clusterDelSlotsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.clusterDelSlotsReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterDelSlotsRange(arg1 context.Context, arg2 int, arg3 int) *redisa.StatusCmd {
	fake.clusterDelSlotsRangeMutex.Lock()
	ret, specificReturn := fake.clusterDelSlotsRangeReturnsOnCall[len(fake.clusterDelSlotsRangeArgsForCall)]
	fake.clusterDelSlotsRangeArgsForCall = append(fake.clusterDelSlotsRangeArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ClusterDelSlotsRangeStub
	fakeReturns := fake.clusterDelSlotsRangeReturns
	fake.recordInvocation("ClusterDelSlotsRange", []interface{}{arg1, arg2, arg3})
	fake.clusterDelSlotsRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterDelSlotsRangeCallCount() int {
	fake.clusterDelSlotsRangeMutex.RLock()
	defer fake.clusterDelSlotsRangeMutex.RUnlock()
	return len(fake.clusterDelSlotsRangeArgsForCall)
}

func (fake *FakeClient) ClusterDelSlotsRangeCalls(stub func(context.Context, int, int) *redisa.StatusCmd) {
	fake.clusterDelSlotsRangeMutex.Lock()
	defer fake.clusterDelSlotsRangeMutex.Unlock()
	fake.ClusterDelSlotsRangeStub = stub
}

func (fake *FakeClient) ClusterDelSlotsRangeArgsForCall(i int) (context.Context, int, int) {
	fake.clusterDelSlotsRangeMutex.RLock()
	defer fake.clusterDelSlotsRangeMutex.RUnlock()
	argsForCall := fake.clusterDelSlotsRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ClusterDelSlotsRangeReturns(result1 *redisa.StatusCmd) {
	fake.clusterDelSlotsRangeMutex.Lock()
	defer fake.clusterDelSlotsRangeMutex.Unlock()
	fake.ClusterDelSlotsRangeStub = nil
	fake.clusterDelSlotsRangeReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterDelSlotsRangeReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.clusterDelSlotsRangeMutex.Lock()
	defer fake.clusterDelSlotsRangeMutex.Unlock()
	fake.ClusterDelSlotsRangeStub = nil
	if fake.clusterDelSlotsRangeReturnsOnCall == nil {
		fake.clusterDelSlotsRangeReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.clusterDelSlotsRangeReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterFailover(arg1 context.Context) *redisa.StatusCmd {
	fake.clusterFailoverMutex.Lock()
	ret, specificReturn := fake.clusterFailoverReturnsOnCall[len(fake.clusterFailoverArgsForCall)]
	fake.clusterFailoverArgsForCall = append(fake.clusterFailoverArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClusterFailoverStub
	fakeReturns := fake.clusterFailoverReturns
	fake.recordInvocation("ClusterFailover", []interface{}{arg1})
	fake.clusterFailoverMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterFailoverCallCount() int {
	fake.clusterFailoverMutex.RLock()
	defer fake.clusterFailoverMutex.RUnlock()
	return len(fake.clusterFailoverArgsForCall)
}

func (fake *FakeClient) ClusterFailoverCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.clusterFailoverMutex.Lock()
	defer fake.clusterFailoverMutex.Unlock()
	fake.ClusterFailoverStub = stub
}

func (fake *FakeClient) ClusterFailoverArgsForCall(i int) context.Context {
	fake.clusterFailoverMutex.RLock()
	defer fake.clusterFailoverMutex.RUnlock()
	argsForCall := fake.clusterFailoverArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClusterFailoverReturns(result1 *redisa.StatusCmd) {
	fake.clusterFailoverMutex.Lock()
	defer fake.clusterFailoverMutex.Unlock()
	fake.ClusterFailoverStub = nil
	fake.clusterFailoverReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterFailoverReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.clusterFailoverMutex.Lock()
	defer fake.clusterFailoverMutex.Unlock()
	fake.ClusterFailoverStub = nil
	if fake.clusterFailoverReturnsOnCall == nil {
		fake.clusterFailoverReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.clusterFailoverReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterForget(arg1 context.Context, arg2 string) *redisa.StatusCmd {
	fake.clusterForgetMutex.Lock()
	ret, specificReturn := fake.clusterForgetReturnsOnCall[len(fake.clusterForgetArgsForCall)]
	fake.clusterForgetArgsForCall = append(fake.clusterForgetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ClusterForgetStub
	fakeReturns := fake.clusterForgetReturns
	fake.recordInvocation("ClusterForget", []interface{}{arg1, arg2})
	fake.clusterForgetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterForgetCallCount() int {
	fake.clusterForgetMutex.RLock()
	defer fake.clusterForgetMutex.RUnlock()
	return len(fake.clusterForgetArgsForCall)
}

func (fake *FakeClient) ClusterForgetCalls(stub func(context.Context, string) *redisa.StatusCmd) {
	fake.clusterForgetMutex.Lock()
	defer fake.clusterForgetMutex.Unlock()
	fake.ClusterForgetStub = stub
}

func (fake *FakeClient) ClusterForgetArgsForCall(i int) (context.Context, string) {
	fake.clusterForgetMutex.RLock()
	defer fake.clusterForgetMutex.RUnlock()
	argsForCall := fake.clusterForgetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ClusterForgetReturns(result1 *redisa.StatusCmd) {
	fake.clusterForgetMutex.Lock()
	defer fake.clusterForgetMutex.Unlock()
	fake.ClusterForgetStub = nil
	fake.clusterForgetReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterForgetReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.clusterForgetMutex.Lock()
	defer fake.clusterForgetMutex.Unlock()
	fake.ClusterForgetStub = nil
	if fake.clusterForgetReturnsOnCall == nil {
		fake.clusterForgetReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.clusterForgetReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterGetKeysInSlot(arg1 context.Context, arg2 int, arg3 int) *redisa.StringSliceCmd {
	fake.clusterGetKeysInSlotMutex.Lock()
	ret, specificReturn := fake.clusterGetKeysInSlotReturnsOnCall[len(fake.clusterGetKeysInSlotArgsForCall)]
	fake.clusterGetKeysInSlotArgsForCall = append(fake.clusterGetKeysInSlotArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ClusterGetKeysInSlotStub
	fakeReturns := fake.clusterGetKeysInSlotReturns
	fake.recordInvocation("ClusterGetKeysInSlot", []interface{}{arg1, arg2, arg3})
	fake.clusterGetKeysInSlotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterGetKeysInSlotCallCount() int {
	fake.clusterGetKeysInSlotMutex.RLock()
	defer fake.clusterGetKeysInSlotMutex.RUnlock()
	return len(fake.clusterGetKeysInSlotArgsForCall)
}

func (fake *FakeClient) ClusterGetKeysInSlotCalls(stub func(context.Context, int, int) *redisa.StringSliceCmd) {
	fake.clusterGetKeysInSlotMutex.Lock()
	defer fake.clusterGetKeysInSlotMutex.Unlock()
	fake.ClusterGetKeysInSlotStub = stub
}

func (fake *FakeClient) ClusterGetKeysInSlotArgsForCall(i int) (context.Context, int, int) {
	fake.clusterGetKeysInSlotMutex.RLock()
	defer fake.clusterGetKeysInSlotMutex.RUnlock()
	argsForCall := fake.clusterGetKeysInSlotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ClusterGetKeysInSlotReturns(result1 *redisa.StringSliceCmd) {
	fake.clusterGetKeysInSlotMutex.Lock()
	defer fake.clusterGetKeysInSlotMutex.Unlock()
	fake.ClusterGetKeysInSlotStub = nil
	fake.clusterGetKeysInSlotReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ClusterGetKeysInSlotReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.clusterGetKeysInSlotMutex.Lock()
	defer fake.clusterGetKeysInSlotMutex.Unlock()
	fake.ClusterGetKeysInSlotStub = nil
	if fake.clusterGetKeysInSlotReturnsOnCall == nil {
		fake.clusterGetKeysInSlotReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.clusterGetKeysInSlotReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ClusterInfo(arg1 context.Context) *redisa.StringCmd {
	fake.clusterInfoMutex.Lock()
	ret, specificReturn := fake.clusterInfoReturnsOnCall[len(fake.clusterInfoArgsForCall)]
	fake.clusterInfoArgsForCall = append(fake.clusterInfoArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClusterInfoStub
	fakeReturns := fake.clusterInfoReturns
	fake.recordInvocation("ClusterInfo", []interface{}{arg1})
	fake.clusterInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterInfoCallCount() int {
	fake.clusterInfoMutex.RLock()
	defer fake.clusterInfoMutex.RUnlock()
	return len(fake.clusterInfoArgsForCall)
}

func (fake *FakeClient) ClusterInfoCalls(stub func(context.Context) *redisa.StringCmd) {
	fake.clusterInfoMutex.Lock()
	defer fake.clusterInfoMutex.Unlock()
	fake.ClusterInfoStub = stub
}

func (fake *FakeClient) ClusterInfoArgsForCall(i int) context.Context {
	fake.clusterInfoMutex.RLock()
	defer fake.clusterInfoMutex.RUnlock()
	argsForCall := fake.clusterInfoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClusterInfoReturns(result1 *redisa.StringCmd) {
	fake.clusterInfoMutex.Lock()
	defer fake.clusterInfoMutex.Unlock()
	fake.ClusterInfoStub = nil
	fake.clusterInfoReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ClusterInfoReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.clusterInfoMutex.Lock()
	defer fake.clusterInfoMutex.Unlock()
	fake.ClusterInfoStub = nil
	if fake.clusterInfoReturnsOnCall == nil {
		fake.clusterInfoReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.clusterInfoReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ClusterKeySlot(arg1 context.Context, arg2 string) *redisa.IntCmd {
	fake.clusterKeySlotMutex.Lock()
	ret, specificReturn := fake.clusterKeySlotReturnsOnCall[len(fake.clusterKeySlotArgsForCall)]
	fake.clusterKeySlotArgsForCall = append(fake.clusterKeySlotArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ClusterKeySlotStub
	fakeReturns := fake.clusterKeySlotReturns
	fake.recordInvocation("ClusterKeySlot", []interface{}{arg1, arg2})
	fake.clusterKeySlotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterKeySlotCallCount() int {
	fake.clusterKeySlotMutex.RLock()
	defer fake.clusterKeySlotMutex.RUnlock()
	return len(fake.clusterKeySlotArgsForCall)
}

func (fake *FakeClient) ClusterKeySlotCalls(stub func(context.Context, string) *redisa.IntCmd) {
	fake.clusterKeySlotMutex.Lock()
	defer fake.clusterKeySlotMutex.Unlock()
	fake.ClusterKeySlotStub = stub
}

func (fake *FakeClient) ClusterKeySlotArgsForCall(i int) (context.Context, string) {
	fake.clusterKeySlotMutex.RLock()
	defer fake.clusterKeySlotMutex.RUnlock()
	argsForCall := fake.clusterKeySlotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ClusterKeySlotReturns(result1 *redisa.IntCmd) {
	fake.clusterKeySlotMutex.Lock()
	defer fake.clusterKeySlotMutex.Unlock()
	fake.ClusterKeySlotStub = nil
	fake.clusterKeySlotReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClusterKeySlotReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.clusterKeySlotMutex.Lock()
	defer fake.clusterKeySlotMutex.Unlock()
	fake.ClusterKeySlotStub = nil
	if fake.clusterKeySlotReturnsOnCall == nil {
		fake.clusterKeySlotReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.clusterKeySlotReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ClusterLinks(arg1 context.Context) *redisa.ClusterLinksCmd {
	fake.clusterLinksMutex.Lock()
	ret, specificReturn := fake.clusterLinksReturnsOnCall[len(fake.clusterLinksArgsForCall)]
	fake.clusterLinksArgsForCall = append(fake.clusterLinksArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClusterLinksStub
	fakeReturns := fake.clusterLinksReturns
	fake.recordInvocation("ClusterLinks", []interface{}{arg1})
	fake.clusterLinksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterLinksCallCount() int {
	fake.clusterLinksMutex.RLock()
	defer fake.clusterLinksMutex.RUnlock()
	return len(fake.clusterLinksArgsForCall)
}

func (fake *FakeClient) ClusterLinksCalls(stub func(context.Context) *redisa.ClusterLinksCmd) {
	fake.clusterLinksMutex.Lock()
	defer fake.clusterLinksMutex.Unlock()
	fake.ClusterLinksStub = stub
}

func (fake *FakeClient) ClusterLinksArgsForCall(i int) context.Context {
	fake.clusterLinksMutex.RLock()
	defer fake.clusterLinksMutex.RUnlock()
	argsForCall := fake.clusterLinksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClusterLinksReturns(result1 *redisa.ClusterLinksCmd) {
	fake.clusterLinksMutex.Lock()
	defer fake.clusterLinksMutex.Unlock()
	fake.ClusterLinksStub = nil
	fake.clusterLinksReturns = struct {
		result1 *redisa.ClusterLinksCmd
	}{result1}
}

func (fake *FakeClient) ClusterLinksReturnsOnCall(i int, result1 *redisa.ClusterLinksCmd) {
	fake.clusterLinksMutex.Lock()
	defer fake.clusterLinksMutex.Unlock()
	fake.ClusterLinksStub = nil
	if fake.clusterLinksReturnsOnCall == nil {
		fake.clusterLinksReturnsOnCall = make(map[int]struct {
			result1 *redisa.ClusterLinksCmd
		})
	}
	fake.clusterLinksReturnsOnCall[i] = struct {
		result1 *redisa.ClusterLinksCmd
	}{result1}
}

func (fake *FakeClient) ClusterMeet(arg1 context.Context, arg2 string, arg3 string) *redisa.StatusCmd {
	fake.clusterMeetMutex.Lock()
	ret, specificReturn := fake.clusterMeetReturnsOnCall[len(fake.clusterMeetArgsForCall)]
	fake.clusterMeetArgsForCall = append(fake.clusterMeetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ClusterMeetStub
	fakeReturns := fake.clusterMeetReturns
	fake.recordInvocation("ClusterMeet", []interface{}{arg1, arg2, arg3})
	fake.clusterMeetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterMeetCallCount() int {
	fake.clusterMeetMutex.RLock()
	defer fake.clusterMeetMutex.RUnlock()
	return len(fake.clusterMeetArgsForCall)
}

func (fake *FakeClient) ClusterMeetCalls(stub func(context.Context, string, string) *redisa.StatusCmd) {
	fake.clusterMeetMutex.Lock()
	defer fake.clusterMeetMutex.Unlock()
	fake.ClusterMeetStub = stub
}

func (fake *FakeClient) ClusterMeetArgsForCall(i int) (context.Context, string, string) {
	fake.clusterMeetMutex.RLock()
	defer fake.clusterMeetMutex.RUnlock()
	argsForCall := fake.clusterMeetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ClusterMeetReturns(result1 *redisa.StatusCmd) {
	fake.clusterMeetMutex.Lock()
	defer fake.clusterMeetMutex.Unlock()
	fake.ClusterMeetStub = nil
	fake.clusterMeetReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterMeetReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.clusterMeetMutex.Lock()
	defer fake.clusterMeetMutex.Unlock()
	fake.ClusterMeetStub = nil
	if fake.clusterMeetReturnsOnCall == nil {
		fake.clusterMeetReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.clusterMeetReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterMyShardID(arg1 context.Context) *redisa.StringCmd {
	fake.clusterMyShardIDMutex.Lock()
	ret, specificReturn := fake.clusterMyShardIDReturnsOnCall[len(fake.clusterMyShardIDArgsForCall)]
	fake.clusterMyShardIDArgsForCall = append(fake.clusterMyShardIDArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClusterMyShardIDStub
	fakeReturns := fake.clusterMyShardIDReturns
	fake.recordInvocation("ClusterMyShardID", []interface{}{arg1})
	fake.clusterMyShardIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterMyShardIDCallCount() int {
	fake.clusterMyShardIDMutex.RLock()
	defer fake.clusterMyShardIDMutex.RUnlock()
	return len(fake.clusterMyShardIDArgsForCall)
}

func (fake *FakeClient) ClusterMyShardIDCalls(stub func(context.Context) *redisa.StringCmd) {
	fake.clusterMyShardIDMutex.Lock()
	defer fake.clusterMyShardIDMutex.Unlock()
	fake.ClusterMyShardIDStub = stub
}

func (fake *FakeClient) ClusterMyShardIDArgsForCall(i int) context.Context {
	fake.clusterMyShardIDMutex.RLock()
	defer fake.clusterMyShardIDMutex.RUnlock()
	argsForCall := fake.clusterMyShardIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClusterMyShardIDReturns(result1 *redisa.StringCmd) {
	fake.clusterMyShardIDMutex.Lock()
	defer fake.clusterMyShardIDMutex.Unlock()
	fake.ClusterMyShardIDStub = nil
	fake.clusterMyShardIDReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ClusterMyShardIDReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.clusterMyShardIDMutex.Lock()
	defer fake.clusterMyShardIDMutex.Unlock()
	fake.ClusterMyShardIDStub = nil
	if fake.clusterMyShardIDReturnsOnCall == nil {
		fake.clusterMyShardIDReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.clusterMyShardIDReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ClusterNodes(arg1 context.Context) *redisa.StringCmd {
	fake.clusterNodesMutex.Lock()
	ret, specificReturn := fake.clusterNodesReturnsOnCall[len(fake.clusterNodesArgsForCall)]
	fake.clusterNodesArgsForCall = append(fake.clusterNodesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClusterNodesStub
	fakeReturns := fake.clusterNodesReturns
	fake.recordInvocation("ClusterNodes", []interface{}{arg1})
	fake.clusterNodesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterNodesCallCount() int {
	fake.clusterNodesMutex.RLock()
	defer fake.clusterNodesMutex.RUnlock()
	return len(fake.clusterNodesArgsForCall)
}

func (fake *FakeClient) ClusterNodesCalls(stub func(context.Context) *redisa.StringCmd) {
	fake.clusterNodesMutex.Lock()
	defer fake.clusterNodesMutex.Unlock()
	fake.ClusterNodesStub = stub
}

func (fake *FakeClient) ClusterNodesArgsForCall(i int) context.Context {
	fake.clusterNodesMutex.RLock()
	defer fake.clusterNodesMutex.RUnlock()
	argsForCall := fake.clusterNodesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClusterNodesReturns(result1 *redisa.StringCmd) {
	fake.clusterNodesMutex.Lock()
	defer fake.clusterNodesMutex.Unlock()
	fake.ClusterNodesStub = nil
	fake.clusterNodesReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ClusterNodesReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.clusterNodesMutex.Lock()
	defer fake.clusterNodesMutex.Unlock()
	fake.ClusterNodesStub = nil
	if fake.clusterNodesReturnsOnCall == nil {
		fake.clusterNodesReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.clusterNodesReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ClusterReplicate(arg1 context.Context, arg2 string) *redisa.StatusCmd {
	fake.clusterReplicateMutex.Lock()
	ret, specificReturn := fake.clusterReplicateReturnsOnCall[len(fake.clusterReplicateArgsForCall)]
	fake.clusterReplicateArgsForCall = append(fake.clusterReplicateArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ClusterReplicateStub
	fakeReturns := fake.clusterReplicateReturns
	fake.recordInvocation("ClusterReplicate", []interface{}{arg1, arg2})
	fake.clusterReplicateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterReplicateCallCount() int {
	fake.clusterReplicateMutex.RLock()
	defer fake.clusterReplicateMutex.RUnlock()
	return len(fake.clusterReplicateArgsForCall)
}

func (fake *FakeClient) ClusterReplicateCalls(stub func(context.Context, string) *redisa.StatusCmd) {
	fake.clusterReplicateMutex.Lock()
	defer fake.clusterReplicateMutex.Unlock()
	fake.ClusterReplicateStub = stub
}

func (fake *FakeClient) ClusterReplicateArgsForCall(i int) (context.Context, string) {
	fake.clusterReplicateMutex.RLock()
	defer fake.clusterReplicateMutex.RUnlock()
	argsForCall := fake.clusterReplicateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ClusterReplicateReturns(result1 *redisa.StatusCmd) {
	fake.clusterReplicateMutex.Lock()
	defer fake.clusterReplicateMutex.Unlock()
	fake.ClusterReplicateStub = nil
	fake.clusterReplicateReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterReplicateReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.clusterReplicateMutex.Lock()
	defer fake.clusterReplicateMutex.Unlock()
	fake.ClusterReplicateStub = nil
	if fake.clusterReplicateReturnsOnCall == nil {
		fake.clusterReplicateReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.clusterReplicateReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterResetHard(arg1 context.Context) *redisa.StatusCmd {
	fake.clusterResetHardMutex.Lock()
	ret, specificReturn := fake.clusterResetHardReturnsOnCall[len(fake.clusterResetHardArgsForCall)]
	fake.clusterResetHardArgsForCall = append(fake.clusterResetHardArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClusterResetHardStub
	fakeReturns := fake.clusterResetHardReturns
	fake.recordInvocation("ClusterResetHard", []interface{}{arg1})
	fake.clusterResetHardMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterResetHardCallCount() int {
	fake.clusterResetHardMutex.RLock()
	defer fake.clusterResetHardMutex.RUnlock()
	return len(fake.clusterResetHardArgsForCall)
}

func (fake *FakeClient) ClusterResetHardCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.clusterResetHardMutex.Lock()
	defer fake.clusterResetHardMutex.Unlock()
	fake.ClusterResetHardStub = stub
}

func (fake *FakeClient) ClusterResetHardArgsForCall(i int) context.Context {
	fake.clusterResetHardMutex.RLock()
	defer fake.clusterResetHardMutex.RUnlock()
	argsForCall := fake.clusterResetHardArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClusterResetHardReturns(result1 *redisa.StatusCmd) {
	fake.clusterResetHardMutex.Lock()
	defer fake.clusterResetHardMutex.Unlock()
	fake.ClusterResetHardStub = nil
	fake.clusterResetHardReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterResetHardReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.clusterResetHardMutex.Lock()
	defer fake.clusterResetHardMutex.Unlock()
	fake.ClusterResetHardStub = nil
	if fake.clusterResetHardReturnsOnCall == nil {
		fake.clusterResetHardReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.clusterResetHardReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterResetSoft(arg1 context.Context) *redisa.StatusCmd {
	fake.clusterResetSoftMutex.Lock()
	ret, specificReturn := fake.clusterResetSoftReturnsOnCall[len(fake.clusterResetSoftArgsForCall)]
	fake.clusterResetSoftArgsForCall = append(fake.clusterResetSoftArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClusterResetSoftStub
	fakeReturns := fake.clusterResetSoftReturns
	fake.recordInvocation("ClusterResetSoft", []interface{}{arg1})
	fake.clusterResetSoftMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterResetSoftCallCount() int {
	fake.clusterResetSoftMutex.RLock()
	defer fake.clusterResetSoftMutex.RUnlock()
	return len(fake.clusterResetSoftArgsForCall)
}

func (fake *FakeClient) ClusterResetSoftCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.clusterResetSoftMutex.Lock()
	defer fake.clusterResetSoftMutex.Unlock()
	fake.ClusterResetSoftStub = stub
}

func (fake *FakeClient) ClusterResetSoftArgsForCall(i int) context.Context {
	fake.clusterResetSoftMutex.RLock()
	defer fake.clusterResetSoftMutex.RUnlock()
	argsForCall := fake.clusterResetSoftArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClusterResetSoftReturns(result1 *redisa.StatusCmd) {
	fake.clusterResetSoftMutex.Lock()
	defer fake.clusterResetSoftMutex.Unlock()
	fake.ClusterResetSoftStub = nil
	fake.clusterResetSoftReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterResetSoftReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.clusterResetSoftMutex.Lock()
	defer fake.clusterResetSoftMutex.Unlock()
	fake.ClusterResetSoftStub = nil
	if fake.clusterResetSoftReturnsOnCall == nil {
		fake.clusterResetSoftReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.clusterResetSoftReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterSaveConfig(arg1 context.Context) *redisa.StatusCmd {
	fake.clusterSaveConfigMutex.Lock()
	ret, specificReturn := fake.clusterSaveConfigReturnsOnCall[len(fake.clusterSaveConfigArgsForCall)]
	fake.clusterSaveConfigArgsForCall = append(fake.clusterSaveConfigArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClusterSaveConfigStub
	fakeReturns := fake.clusterSaveConfigReturns
	fake.recordInvocation("ClusterSaveConfig", []interface{}{arg1})
	fake.clusterSaveConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterSaveConfigCallCount() int {
	fake.clusterSaveConfigMutex.RLock()
	defer fake.clusterSaveConfigMutex.RUnlock()
	return len(fake.clusterSaveConfigArgsForCall)
}

func (fake *FakeClient) ClusterSaveConfigCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.clusterSaveConfigMutex.Lock()
	defer fake.clusterSaveConfigMutex.Unlock()
	fake.ClusterSaveConfigStub = stub
}

func (fake *FakeClient) ClusterSaveConfigArgsForCall(i int) context.Context {
	fake.clusterSaveConfigMutex.RLock()
	defer fake.clusterSaveConfigMutex.RUnlock()
	argsForCall := fake.clusterSaveConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClusterSaveConfigReturns(result1 *redisa.StatusCmd) {
	fake.clusterSaveConfigMutex.Lock()
	defer fake.clusterSaveConfigMutex.Unlock()
	fake.ClusterSaveConfigStub = nil
	fake.clusterSaveConfigReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterSaveConfigReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.clusterSaveConfigMutex.Lock()
	defer fake.clusterSaveConfigMutex.Unlock()
	fake.ClusterSaveConfigStub = nil
	if fake.clusterSaveConfigReturnsOnCall == nil {
		fake.clusterSaveConfigReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.clusterSaveConfigReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ClusterShards(arg1 context.Context) *redisa.ClusterShardsCmd {
	fake.clusterShardsMutex.Lock()
	ret, specificReturn := fake.clusterShardsReturnsOnCall[len(fake.clusterShardsArgsForCall)]
	fake.clusterShardsArgsForCall = append(fake.clusterShardsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClusterShardsStub
	fakeReturns := fake.clusterShardsReturns
	fake.recordInvocation("ClusterShards", []interface{}{arg1})
	fake.clusterShardsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterShardsCallCount() int {
	fake.clusterShardsMutex.RLock()
	defer fake.clusterShardsMutex.RUnlock()
	return len(fake.clusterShardsArgsForCall)
}

func (fake *FakeClient) ClusterShardsCalls(stub func(context.Context) *redisa.ClusterShardsCmd) {
	fake.clusterShardsMutex.Lock()
	defer fake.clusterShardsMutex.Unlock()
	fake.ClusterShardsStub = stub
}

func (fake *FakeClient) ClusterShardsArgsForCall(i int) context.Context {
	fake.clusterShardsMutex.RLock()
	defer fake.clusterShardsMutex.RUnlock()
	argsForCall := fake.clusterShardsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClusterShardsReturns(result1 *redisa.ClusterShardsCmd) {
	fake.clusterShardsMutex.Lock()
	defer fake.clusterShardsMutex.Unlock()
	fake.ClusterShardsStub = nil
	fake.clusterShardsReturns = struct {
		result1 *redisa.ClusterShardsCmd
	}{result1}
}

func (fake *FakeClient) ClusterShardsReturnsOnCall(i int, result1 *redisa.ClusterShardsCmd) {
	fake.clusterShardsMutex.Lock()
	defer fake.clusterShardsMutex.Unlock()
	fake.ClusterShardsStub = nil
	if fake.clusterShardsReturnsOnCall == nil {
		fake.clusterShardsReturnsOnCall = make(map[int]struct {
			result1 *redisa.ClusterShardsCmd
		})
	}
	fake.clusterShardsReturnsOnCall[i] = struct {
		result1 *redisa.ClusterShardsCmd
	}{result1}
}

func (fake *FakeClient) ClusterSlaves(arg1 context.Context, arg2 string) *redisa.StringSliceCmd {
	fake.clusterSlavesMutex.Lock()
	ret, specificReturn := fake.clusterSlavesReturnsOnCall[len(fake.clusterSlavesArgsForCall)]
	fake.clusterSlavesArgsForCall = append(fake.clusterSlavesArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ClusterSlavesStub
	fakeReturns := fake.clusterSlavesReturns
	fake.recordInvocation("ClusterSlaves", []interface{}{arg1, arg2})
	fake.clusterSlavesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterSlavesCallCount() int {
	fake.clusterSlavesMutex.RLock()
	defer fake.clusterSlavesMutex.RUnlock()
	return len(fake.clusterSlavesArgsForCall)
}

func (fake *FakeClient) ClusterSlavesCalls(stub func(context.Context, string) *redisa.StringSliceCmd) {
	fake.clusterSlavesMutex.Lock()
	defer fake.clusterSlavesMutex.Unlock()
	fake.ClusterSlavesStub = stub
}

func (fake *FakeClient) ClusterSlavesArgsForCall(i int) (context.Context, string) {
	fake.clusterSlavesMutex.RLock()
	defer fake.clusterSlavesMutex.RUnlock()
	argsForCall := fake.clusterSlavesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ClusterSlavesReturns(result1 *redisa.StringSliceCmd) {
	fake.clusterSlavesMutex.Lock()
	defer fake.clusterSlavesMutex.Unlock()
	fake.ClusterSlavesStub = nil
	fake.clusterSlavesReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ClusterSlavesReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.clusterSlavesMutex.Lock()
	defer fake.clusterSlavesMutex.Unlock()
	fake.ClusterSlavesStub = nil
	if fake.clusterSlavesReturnsOnCall == nil {
		fake.clusterSlavesReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.clusterSlavesReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ClusterSlots(arg1 context.Context) *redisa.ClusterSlotsCmd {
	fake.clusterSlotsMutex.Lock()
	ret, specificReturn := fake.clusterSlotsReturnsOnCall[len(fake.clusterSlotsArgsForCall)]
	fake.clusterSlotsArgsForCall = append(fake.clusterSlotsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClusterSlotsStub
	fakeReturns := fake.clusterSlotsReturns
	fake.recordInvocation("ClusterSlots", []interface{}{arg1})
	fake.clusterSlotsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ClusterSlotsCallCount() int {
	fake.clusterSlotsMutex.RLock()
	defer fake.clusterSlotsMutex.RUnlock()
	return len(fake.clusterSlotsArgsForCall)
}

func (fake *FakeClient) ClusterSlotsCalls(stub func(context.Context) *redisa.ClusterSlotsCmd) {
	fake.clusterSlotsMutex.Lock()
	defer fake.clusterSlotsMutex.Unlock()
	fake.ClusterSlotsStub = stub
}

func (fake *FakeClient) ClusterSlotsArgsForCall(i int) context.Context {
	fake.clusterSlotsMutex.RLock()
	defer fake.clusterSlotsMutex.RUnlock()
	argsForCall := fake.clusterSlotsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ClusterSlotsReturns(result1 *redisa.ClusterSlotsCmd) {
	fake.clusterSlotsMutex.Lock()
	defer fake.clusterSlotsMutex.Unlock()
	fake.ClusterSlotsStub = nil
	fake.clusterSlotsReturns = struct {
		result1 *redisa.ClusterSlotsCmd
	}{result1}
}

func (fake *FakeClient) ClusterSlotsReturnsOnCall(i int, result1 *redisa.ClusterSlotsCmd) {
	fake.clusterSlotsMutex.Lock()
	defer fake.clusterSlotsMutex.Unlock()
	fake.ClusterSlotsStub = nil
	if fake.clusterSlotsReturnsOnCall == nil {
		fake.clusterSlotsReturnsOnCall = make(map[int]struct {
			result1 *redisa.ClusterSlotsCmd
		})
	}
	fake.clusterSlotsReturnsOnCall[i] = struct {
		result1 *redisa.ClusterSlotsCmd
	}{result1}
}

func (fake *FakeClient) Command(arg1 context.Context) *redisa.CommandsInfoCmd {
	fake.commandMutex.Lock()
	ret, specificReturn := fake.commandReturnsOnCall[len(fake.commandArgsForCall)]
	fake.commandArgsForCall = append(fake.commandArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CommandStub
	fakeReturns := fake.commandReturns
	fake.recordInvocation("Command", []interface{}{arg1})
	fake.commandMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CommandCallCount() int {
	fake.commandMutex.RLock()
	defer fake.commandMutex.RUnlock()
	return len(fake.commandArgsForCall)
}

func (fake *FakeClient) CommandCalls(stub func(context.Context) *redisa.CommandsInfoCmd) {
	fake.commandMutex.Lock()
	defer fake.commandMutex.Unlock()
	fake.CommandStub = stub
}

func (fake *FakeClient) CommandArgsForCall(i int) context.Context {
	fake.commandMutex.RLock()
	defer fake.commandMutex.RUnlock()
	argsForCall := fake.commandArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CommandReturns(result1 *redisa.CommandsInfoCmd) {
	fake.commandMutex.Lock()
	defer fake.commandMutex.Unlock()
	fake.CommandStub = nil
	fake.commandReturns = struct {
		result1 *redisa.CommandsInfoCmd
	}{result1}
}

func (fake *FakeClient) CommandReturnsOnCall(i int, result1 *redisa.CommandsInfoCmd) {
	fake.commandMutex.Lock()
	defer fake.commandMutex.Unlock()
	fake.CommandStub = nil
	if fake.commandReturnsOnCall == nil {
		fake.commandReturnsOnCall = make(map[int]struct {
			result1 *redisa.CommandsInfoCmd
		})
	}
	fake.commandReturnsOnCall[i] = struct {
		result1 *redisa.CommandsInfoCmd
	}{result1}
}

func (fake *FakeClient) CommandGetKeys(arg1 context.Context, arg2 ...interface{}) *redisa.StringSliceCmd {
	fake.commandGetKeysMutex.Lock()
	ret, specificReturn := fake.commandGetKeysReturnsOnCall[len(fake.commandGetKeysArgsForCall)]
	fake.commandGetKeysArgsForCall = append(fake.commandGetKeysArgsForCall, struct {
		arg1 context.Context
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.CommandGetKeysStub
	fakeReturns := fake.commandGetKeysReturns
	fake.recordInvocation("CommandGetKeys", []interface{}{arg1, arg2})
	fake.commandGetKeysMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CommandGetKeysCallCount() int {
	fake.commandGetKeysMutex.RLock()
	defer fake.commandGetKeysMutex.RUnlock()
	return len(fake.commandGetKeysArgsForCall)
}

func (fake *FakeClient) CommandGetKeysCalls(stub func(context.Context, ...interface{}) *redisa.StringSliceCmd) {
	fake.commandGetKeysMutex.Lock()
	defer fake.commandGetKeysMutex.Unlock()
	fake.CommandGetKeysStub = stub
}

func (fake *FakeClient) CommandGetKeysArgsForCall(i int) (context.Context, []interface{}) {
	fake.commandGetKeysMutex.RLock()
	defer fake.commandGetKeysMutex.RUnlock()
	argsForCall := fake.commandGetKeysArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) CommandGetKeysReturns(result1 *redisa.StringSliceCmd) {
	fake.commandGetKeysMutex.Lock()
	defer fake.commandGetKeysMutex.Unlock()
	fake.CommandGetKeysStub = nil
	fake.commandGetKeysReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) CommandGetKeysReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.commandGetKeysMutex.Lock()
	defer fake.commandGetKeysMutex.Unlock()
	fake.CommandGetKeysStub = nil
	if fake.commandGetKeysReturnsOnCall == nil {
		fake.commandGetKeysReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.commandGetKeysReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) CommandGetKeysAndFlags(arg1 context.Context, arg2 ...interface{}) *redisa.KeyFlagsCmd {
	fake.commandGetKeysAndFlagsMutex.Lock()
	ret, specificReturn := fake.commandGetKeysAndFlagsReturnsOnCall[len(fake.commandGetKeysAndFlagsArgsForCall)]
	fake.commandGetKeysAndFlagsArgsForCall = append(fake.commandGetKeysAndFlagsArgsForCall, struct {
		arg1 context.Context
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.CommandGetKeysAndFlagsStub
	fakeReturns := fake.commandGetKeysAndFlagsReturns
	fake.recordInvocation("CommandGetKeysAndFlags", []interface{}{arg1, arg2})
	fake.commandGetKeysAndFlagsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CommandGetKeysAndFlagsCallCount() int {
	fake.commandGetKeysAndFlagsMutex.RLock()
	defer fake.commandGetKeysAndFlagsMutex.RUnlock()
	return len(fake.commandGetKeysAndFlagsArgsForCall)
}

func (fake *FakeClient) CommandGetKeysAndFlagsCalls(stub func(context.Context, ...interface{}) *redisa.KeyFlagsCmd) {
	fake.commandGetKeysAndFlagsMutex.Lock()
	defer fake.commandGetKeysAndFlagsMutex.Unlock()
	fake.CommandGetKeysAndFlagsStub = stub
}

func (fake *FakeClient) CommandGetKeysAndFlagsArgsForCall(i int) (context.Context, []interface{}) {
	fake.commandGetKeysAndFlagsMutex.RLock()
	defer fake.commandGetKeysAndFlagsMutex.RUnlock()
	argsForCall := fake.commandGetKeysAndFlagsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) CommandGetKeysAndFlagsReturns(result1 *redisa.KeyFlagsCmd) {
	fake.commandGetKeysAndFlagsMutex.Lock()
	defer fake.commandGetKeysAndFlagsMutex.Unlock()
	fake.CommandGetKeysAndFlagsStub = nil
	fake.commandGetKeysAndFlagsReturns = struct {
		result1 *redisa.KeyFlagsCmd
	}{result1}
}

func (fake *FakeClient) CommandGetKeysAndFlagsReturnsOnCall(i int, result1 *redisa.KeyFlagsCmd) {
	fake.commandGetKeysAndFlagsMutex.Lock()
	defer fake.commandGetKeysAndFlagsMutex.Unlock()
	fake.CommandGetKeysAndFlagsStub = nil
	if fake.commandGetKeysAndFlagsReturnsOnCall == nil {
		fake.commandGetKeysAndFlagsReturnsOnCall = make(map[int]struct {
			result1 *redisa.KeyFlagsCmd
		})
	}
	fake.commandGetKeysAndFlagsReturnsOnCall[i] = struct {
		result1 *redisa.KeyFlagsCmd
	}{result1}
}

func (fake *FakeClient) CommandList(arg1 context.Context, arg2 *redisa.FilterBy) *redisa.StringSliceCmd {
	fake.commandListMutex.Lock()
	ret, specificReturn := fake.commandListReturnsOnCall[len(fake.commandListArgsForCall)]
	fake.commandListArgsForCall = append(fake.commandListArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.FilterBy
	}{arg1, arg2})
	stub := fake.CommandListStub
	fakeReturns := fake.commandListReturns
	fake.recordInvocation("CommandList", []interface{}{arg1, arg2})
	fake.commandListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CommandListCallCount() int {
	fake.commandListMutex.RLock()
	defer fake.commandListMutex.RUnlock()
	return len(fake.commandListArgsForCall)
}

func (fake *FakeClient) CommandListCalls(stub func(context.Context, *redisa.FilterBy) *redisa.StringSliceCmd) {
	fake.commandListMutex.Lock()
	defer fake.commandListMutex.Unlock()
	fake.CommandListStub = stub
}

func (fake *FakeClient) CommandListArgsForCall(i int) (context.Context, *redisa.FilterBy) {
	fake.commandListMutex.RLock()
	defer fake.commandListMutex.RUnlock()
	argsForCall := fake.commandListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) CommandListReturns(result1 *redisa.StringSliceCmd) {
	fake.commandListMutex.Lock()
	defer fake.commandListMutex.Unlock()
	fake.CommandListStub = nil
	fake.commandListReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) CommandListReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.commandListMutex.Lock()
	defer fake.commandListMutex.Unlock()
	fake.CommandListStub = nil
	if fake.commandListReturnsOnCall == nil {
		fake.commandListReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.commandListReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ConfigGet(arg1 context.Context, arg2 string) *redisa.MapStringStringCmd {
	fake.configGetMutex.Lock()
	ret, specificReturn := fake.configGetReturnsOnCall[len(fake.configGetArgsForCall)]
	fake.configGetArgsForCall = append(fake.configGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ConfigGetStub
	fakeReturns := fake.configGetReturns
	fake.recordInvocation("ConfigGet", []interface{}{arg1, arg2})
	fake.configGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ConfigGetCallCount() int {
	fake.configGetMutex.RLock()
	defer fake.configGetMutex.RUnlock()
	return len(fake.configGetArgsForCall)
}

func (fake *FakeClient) ConfigGetCalls(stub func(context.Context, string) *redisa.MapStringStringCmd) {
	fake.configGetMutex.Lock()
	defer fake.configGetMutex.Unlock()
	fake.ConfigGetStub = stub
}

func (fake *FakeClient) ConfigGetArgsForCall(i int) (context.Context, string) {
	fake.configGetMutex.RLock()
	defer fake.configGetMutex.RUnlock()
	argsForCall := fake.configGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ConfigGetReturns(result1 *redisa.MapStringStringCmd) {
	fake.configGetMutex.Lock()
	defer fake.configGetMutex.Unlock()
	fake.ConfigGetStub = nil
	fake.configGetReturns = struct {
		result1 *redisa.MapStringStringCmd
	}{result1}
}

func (fake *FakeClient) ConfigGetReturnsOnCall(i int, result1 *redisa.MapStringStringCmd) {
	fake.configGetMutex.Lock()
	defer fake.configGetMutex.Unlock()
	fake.ConfigGetStub = nil
	if fake.configGetReturnsOnCall == nil {
		fake.configGetReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringStringCmd
		})
	}
	fake.configGetReturnsOnCall[i] = struct {
		result1 *redisa.MapStringStringCmd
	}{result1}
}

func (fake *FakeClient) ConfigResetStat(arg1 context.Context) *redisa.StatusCmd {
	fake.configResetStatMutex.Lock()
	ret, specificReturn := fake.configResetStatReturnsOnCall[len(fake.configResetStatArgsForCall)]
	fake.configResetStatArgsForCall = append(fake.configResetStatArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ConfigResetStatStub
	fakeReturns := fake.configResetStatReturns
	fake.recordInvocation("ConfigResetStat", []interface{}{arg1})
	fake.configResetStatMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ConfigResetStatCallCount() int {
	fake.configResetStatMutex.RLock()
	defer fake.configResetStatMutex.RUnlock()
	return len(fake.configResetStatArgsForCall)
}

func (fake *FakeClient) ConfigResetStatCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.configResetStatMutex.Lock()
	defer fake.configResetStatMutex.Unlock()
	fake.ConfigResetStatStub = stub
}

func (fake *FakeClient) ConfigResetStatArgsForCall(i int) context.Context {
	fake.configResetStatMutex.RLock()
	defer fake.configResetStatMutex.RUnlock()
	argsForCall := fake.configResetStatArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ConfigResetStatReturns(result1 *redisa.StatusCmd) {
	fake.configResetStatMutex.Lock()
	defer fake.configResetStatMutex.Unlock()
	fake.ConfigResetStatStub = nil
	fake.configResetStatReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ConfigResetStatReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.configResetStatMutex.Lock()
	defer fake.configResetStatMutex.Unlock()
	fake.ConfigResetStatStub = nil
	if fake.configResetStatReturnsOnCall == nil {
		fake.configResetStatReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.configResetStatReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ConfigRewrite(arg1 context.Context) *redisa.StatusCmd {
	fake.configRewriteMutex.Lock()
	ret, specificReturn := fake.configRewriteReturnsOnCall[len(fake.configRewriteArgsForCall)]
	fake.configRewriteArgsForCall = append(fake.configRewriteArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ConfigRewriteStub
	fakeReturns := fake.configRewriteReturns
	fake.recordInvocation("ConfigRewrite", []interface{}{arg1})
	fake.configRewriteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ConfigRewriteCallCount() int {
	fake.configRewriteMutex.RLock()
	defer fake.configRewriteMutex.RUnlock()
	return len(fake.configRewriteArgsForCall)
}

func (fake *FakeClient) ConfigRewriteCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.configRewriteMutex.Lock()
	defer fake.configRewriteMutex.Unlock()
	fake.ConfigRewriteStub = stub
}

func (fake *FakeClient) ConfigRewriteArgsForCall(i int) context.Context {
	fake.configRewriteMutex.RLock()
	defer fake.configRewriteMutex.RUnlock()
	argsForCall := fake.configRewriteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ConfigRewriteReturns(result1 *redisa.StatusCmd) {
	fake.configRewriteMutex.Lock()
	defer fake.configRewriteMutex.Unlock()
	fake.ConfigRewriteStub = nil
	fake.configRewriteReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ConfigRewriteReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.configRewriteMutex.Lock()
	defer fake.configRewriteMutex.Unlock()
	fake.ConfigRewriteStub = nil
	if fake.configRewriteReturnsOnCall == nil {
		fake.configRewriteReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.configRewriteReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ConfigSet(arg1 context.Context, arg2 string, arg3 string) *redisa.StatusCmd {
	fake.configSetMutex.Lock()
	ret, specificReturn := fake.configSetReturnsOnCall[len(fake.configSetArgsForCall)]
	fake.configSetArgsForCall = append(fake.configSetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ConfigSetStub
	fakeReturns := fake.configSetReturns
	fake.recordInvocation("ConfigSet", []interface{}{arg1, arg2, arg3})
	fake.configSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ConfigSetCallCount() int {
	fake.configSetMutex.RLock()
	defer fake.configSetMutex.RUnlock()
	return len(fake.configSetArgsForCall)
}

func (fake *FakeClient) ConfigSetCalls(stub func(context.Context, string, string) *redisa.StatusCmd) {
	fake.configSetMutex.Lock()
	defer fake.configSetMutex.Unlock()
	fake.ConfigSetStub = stub
}

func (fake *FakeClient) ConfigSetArgsForCall(i int) (context.Context, string, string) {
	fake.configSetMutex.RLock()
	defer fake.configSetMutex.RUnlock()
	argsForCall := fake.configSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ConfigSetReturns(result1 *redisa.StatusCmd) {
	fake.configSetMutex.Lock()
	defer fake.configSetMutex.Unlock()
	fake.ConfigSetStub = nil
	fake.configSetReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ConfigSetReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.configSetMutex.Lock()
	defer fake.configSetMutex.Unlock()
	fake.ConfigSetStub = nil
	if fake.configSetReturnsOnCall == nil {
		fake.configSetReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.configSetReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) Copy(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 bool) *redisa.IntCmd {
	fake.copyMutex.Lock()
	ret, specificReturn := fake.copyReturnsOnCall[len(fake.copyArgsForCall)]
	fake.copyArgsForCall = append(fake.copyArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.CopyStub
	fakeReturns := fake.copyReturns
	fake.recordInvocation("Copy", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.copyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CopyCallCount() int {
	fake.copyMutex.RLock()
	defer fake.copyMutex.RUnlock()
	return len(fake.copyArgsForCall)
}

func (fake *FakeClient) CopyCalls(stub func(context.Context, string, string, int, bool) *redisa.IntCmd) {
	fake.copyMutex.Lock()
	defer fake.copyMutex.Unlock()
	fake.CopyStub = stub
}

func (fake *FakeClient) CopyArgsForCall(i int) (context.Context, string, string, int, bool) {
	fake.copyMutex.RLock()
	defer fake.copyMutex.RUnlock()
	argsForCall := fake.copyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) CopyReturns(result1 *redisa.IntCmd) {
	fake.copyMutex.Lock()
	defer fake.copyMutex.Unlock()
	fake.CopyStub = nil
	fake.copyReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) CopyReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.copyMutex.Lock()
	defer fake.copyMutex.Unlock()
	fake.CopyStub = nil
	if fake.copyReturnsOnCall == nil {
		fake.copyReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.copyReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) DBSize(arg1 context.Context) *redisa.IntCmd {
	fake.dBSizeMutex.Lock()
	ret, specificReturn := fake.dBSizeReturnsOnCall[len(fake.dBSizeArgsForCall)]
	fake.dBSizeArgsForCall = append(fake.dBSizeArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.DBSizeStub
	fakeReturns := fake.dBSizeReturns
	fake.recordInvocation("DBSize", []interface{}{arg1})
	fake.dBSizeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DBSizeCallCount() int {
	fake.dBSizeMutex.RLock()
	defer fake.dBSizeMutex.RUnlock()
	return len(fake.dBSizeArgsForCall)
}

func (fake *FakeClient) DBSizeCalls(stub func(context.Context) *redisa.IntCmd) {
	fake.dBSizeMutex.Lock()
	defer fake.dBSizeMutex.Unlock()
	fake.DBSizeStub = stub
}

func (fake *FakeClient) DBSizeArgsForCall(i int) context.Context {
	fake.dBSizeMutex.RLock()
	defer fake.dBSizeMutex.RUnlock()
	argsForCall := fake.dBSizeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DBSizeReturns(result1 *redisa.IntCmd) {
	fake.dBSizeMutex.Lock()
	defer fake.dBSizeMutex.Unlock()
	fake.DBSizeStub = nil
	fake.dBSizeReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) DBSizeReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.dBSizeMutex.Lock()
	defer fake.dBSizeMutex.Unlock()
	fake.DBSizeStub = nil
	if fake.dBSizeReturnsOnCall == nil {
		fake.dBSizeReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.dBSizeReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) DebugObject(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.debugObjectMutex.Lock()
	ret, specificReturn := fake.debugObjectReturnsOnCall[len(fake.debugObjectArgsForCall)]
	fake.debugObjectArgsForCall = append(fake.debugObjectArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DebugObjectStub
	fakeReturns := fake.debugObjectReturns
	fake.recordInvocation("DebugObject", []interface{}{arg1, arg2})
	fake.debugObjectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DebugObjectCallCount() int {
	fake.debugObjectMutex.RLock()
	defer fake.debugObjectMutex.RUnlock()
	return len(fake.debugObjectArgsForCall)
}

func (fake *FakeClient) DebugObjectCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.debugObjectMutex.Lock()
	defer fake.debugObjectMutex.Unlock()
	fake.DebugObjectStub = stub
}

func (fake *FakeClient) DebugObjectArgsForCall(i int) (context.Context, string) {
	fake.debugObjectMutex.RLock()
	defer fake.debugObjectMutex.RUnlock()
	argsForCall := fake.debugObjectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DebugObjectReturns(result1 *redisa.StringCmd) {
	fake.debugObjectMutex.Lock()
	defer fake.debugObjectMutex.Unlock()
	fake.DebugObjectStub = nil
	fake.debugObjectReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) DebugObjectReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.debugObjectMutex.Lock()
	defer fake.debugObjectMutex.Unlock()
	fake.DebugObjectStub = nil
	if fake.debugObjectReturnsOnCall == nil {
		fake.debugObjectReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.debugObjectReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) Decr(arg1 context.Context, arg2 string) *redisa.IntCmd {
	fake.decrMutex.Lock()
	ret, specificReturn := fake.decrReturnsOnCall[len(fake.decrArgsForCall)]
	fake.decrArgsForCall = append(fake.decrArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DecrStub
	fakeReturns := fake.decrReturns
	fake.recordInvocation("Decr", []interface{}{arg1, arg2})
	fake.decrMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DecrCallCount() int {
	fake.decrMutex.RLock()
	defer fake.decrMutex.RUnlock()
	return len(fake.decrArgsForCall)
}

func (fake *FakeClient) DecrCalls(stub func(context.Context, string) *redisa.IntCmd) {
	fake.decrMutex.Lock()
	defer fake.decrMutex.Unlock()
	fake.DecrStub = stub
}

func (fake *FakeClient) DecrArgsForCall(i int) (context.Context, string) {
	fake.decrMutex.RLock()
	defer fake.decrMutex.RUnlock()
	argsForCall := fake.decrArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DecrReturns(result1 *redisa.IntCmd) {
	fake.decrMutex.Lock()
	defer fake.decrMutex.Unlock()
	fake.DecrStub = nil
	fake.decrReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) DecrReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.decrMutex.Lock()
	defer fake.decrMutex.Unlock()
	fake.DecrStub = nil
	if fake.decrReturnsOnCall == nil {
		fake.decrReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.decrReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) DecrBy(arg1 context.Context, arg2 string, arg3 int64) *redisa.IntCmd {
	fake.decrByMutex.Lock()
	ret, specificReturn := fake.decrByReturnsOnCall[len(fake.decrByArgsForCall)]
	fake.decrByArgsForCall = append(fake.decrByArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.DecrByStub
	fakeReturns := fake.decrByReturns
	fake.recordInvocation("DecrBy", []interface{}{arg1, arg2, arg3})
	fake.decrByMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DecrByCallCount() int {
	fake.decrByMutex.RLock()
	defer fake.decrByMutex.RUnlock()
	return len(fake.decrByArgsForCall)
}

func (fake *FakeClient) DecrByCalls(stub func(context.Context, string, int64) *redisa.IntCmd) {
	fake.decrByMutex.Lock()
	defer fake.decrByMutex.Unlock()
	fake.DecrByStub = stub
}

func (fake *FakeClient) DecrByArgsForCall(i int) (context.Context, string, int64) {
	fake.decrByMutex.RLock()
	defer fake.decrByMutex.RUnlock()
	argsForCall := fake.decrByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) DecrByReturns(result1 *redisa.IntCmd) {
	fake.decrByMutex.Lock()
	defer fake.decrByMutex.Unlock()
	fake.DecrByStub = nil
	fake.decrByReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) DecrByReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.decrByMutex.Lock()
	defer fake.decrByMutex.Unlock()
	fake.DecrByStub = nil
	if fake.decrByReturnsOnCall == nil {
		fake.decrByReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.decrByReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) Del(arg1 context.Context, arg2 ...string) *redisa.IntCmd {
	fake.delMutex.Lock()
	ret, specificReturn := fake.delReturnsOnCall[len(fake.delArgsForCall)]
	fake.delArgsForCall = append(fake.delArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.DelStub
	fakeReturns := fake.delReturns
	fake.recordInvocation("Del", []interface{}{arg1, arg2})
	fake.delMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DelCallCount() int {
	fake.delMutex.RLock()
	defer fake.delMutex.RUnlock()
	return len(fake.delArgsForCall)
}

func (fake *FakeClient) DelCalls(stub func(context.Context, ...string) *redisa.IntCmd) {
	fake.delMutex.Lock()
	defer fake.delMutex.Unlock()
	fake.DelStub = stub
}

func (fake *FakeClient) DelArgsForCall(i int) (context.Context, []string) {
	fake.delMutex.RLock()
	defer fake.delMutex.RUnlock()
	argsForCall := fake.delArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DelReturns(result1 *redisa.IntCmd) {
	fake.delMutex.Lock()
	defer fake.delMutex.Unlock()
	fake.DelStub = nil
	fake.delReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) DelReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.delMutex.Lock()
	defer fake.delMutex.Unlock()
	fake.DelStub = nil
	if fake.delReturnsOnCall == nil {
		fake.delReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.delReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) Dump(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.dumpMutex.Lock()
	ret, specificReturn := fake.dumpReturnsOnCall[len(fake.dumpArgsForCall)]
	fake.dumpArgsForCall = append(fake.dumpArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DumpStub
	fakeReturns := fake.dumpReturns
	fake.recordInvocation("Dump", []interface{}{arg1, arg2})
	fake.dumpMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DumpCallCount() int {
	fake.dumpMutex.RLock()
	defer fake.dumpMutex.RUnlock()
	return len(fake.dumpArgsForCall)
}

func (fake *FakeClient) DumpCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.dumpMutex.Lock()
	defer fake.dumpMutex.Unlock()
	fake.DumpStub = stub
}

func (fake *FakeClient) DumpArgsForCall(i int) (context.Context, string) {
	fake.dumpMutex.RLock()
	defer fake.dumpMutex.RUnlock()
	argsForCall := fake.dumpArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DumpReturns(result1 *redisa.StringCmd) {
	fake.dumpMutex.Lock()
	defer fake.dumpMutex.Unlock()
	fake.DumpStub = nil
	fake.dumpReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) DumpReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.dumpMutex.Lock()
	defer fake.dumpMutex.Unlock()
	fake.DumpStub = nil
	if fake.dumpReturnsOnCall == nil {
		fake.dumpReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.dumpReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) Echo(arg1 context.Context, arg2 interface{}) *redisa.StringCmd {
	fake.echoMutex.Lock()
	ret, specificReturn := fake.echoReturnsOnCall[len(fake.echoArgsForCall)]
	fake.echoArgsForCall = append(fake.echoArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.EchoStub
	fakeReturns := fake.echoReturns
	fake.recordInvocation("Echo", []interface{}{arg1, arg2})
	fake.echoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) EchoCallCount() int {
	fake.echoMutex.RLock()
	defer fake.echoMutex.RUnlock()
	return len(fake.echoArgsForCall)
}

func (fake *FakeClient) EchoCalls(stub func(context.Context, interface{}) *redisa.StringCmd) {
	fake.echoMutex.Lock()
	defer fake.echoMutex.Unlock()
	fake.EchoStub = stub
}

func (fake *FakeClient) EchoArgsForCall(i int) (context.Context, interface{}) {
	fake.echoMutex.RLock()
	defer fake.echoMutex.RUnlock()
	argsForCall := fake.echoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) EchoReturns(result1 *redisa.StringCmd) {
	fake.echoMutex.Lock()
	defer fake.echoMutex.Unlock()
	fake.EchoStub = nil
	fake.echoReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) EchoReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.echoMutex.Lock()
	defer fake.echoMutex.Unlock()
	fake.EchoStub = nil
	if fake.echoReturnsOnCall == nil {
		fake.echoReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.echoReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) Eval(arg1 context.Context, arg2 string, arg3 []string, arg4 ...interface{}) *redisa.Cmd {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.evalMutex.Lock()
	ret, specificReturn := fake.evalReturnsOnCall[len(fake.evalArgsForCall)]
	fake.evalArgsForCall = append(fake.evalArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.EvalStub
	fakeReturns := fake.evalReturns
	fake.recordInvocation("Eval", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.evalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) EvalCallCount() int {
	fake.evalMutex.RLock()
	defer fake.evalMutex.RUnlock()
	return len(fake.evalArgsForCall)
}

func (fake *FakeClient) EvalCalls(stub func(context.Context, string, []string, ...interface{}) *redisa.Cmd) {
	fake.evalMutex.Lock()
	defer fake.evalMutex.Unlock()
	fake.EvalStub = stub
}

func (fake *FakeClient) EvalArgsForCall(i int) (context.Context, string, []string, []interface{}) {
	fake.evalMutex.RLock()
	defer fake.evalMutex.RUnlock()
	argsForCall := fake.evalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) EvalReturns(result1 *redisa.Cmd) {
	fake.evalMutex.Lock()
	defer fake.evalMutex.Unlock()
	fake.EvalStub = nil
	fake.evalReturns = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) EvalReturnsOnCall(i int, result1 *redisa.Cmd) {
	fake.evalMutex.Lock()
	defer fake.evalMutex.Unlock()
	fake.EvalStub = nil
	if fake.evalReturnsOnCall == nil {
		fake.evalReturnsOnCall = make(map[int]struct {
			result1 *redisa.Cmd
		})
	}
	fake.evalReturnsOnCall[i] = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) EvalRO(arg1 context.Context, arg2 string, arg3 []string, arg4 ...interface{}) *redisa.Cmd {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.evalROMutex.Lock()
	ret, specificReturn := fake.evalROReturnsOnCall[len(fake.evalROArgsForCall)]
	fake.evalROArgsForCall = append(fake.evalROArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.EvalROStub
	fakeReturns := fake.evalROReturns
	fake.recordInvocation("EvalRO", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.evalROMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) EvalROCallCount() int {
	fake.evalROMutex.RLock()
	defer fake.evalROMutex.RUnlock()
	return len(fake.evalROArgsForCall)
}

func (fake *FakeClient) EvalROCalls(stub func(context.Context, string, []string, ...interface{}) *redisa.Cmd) {
	fake.evalROMutex.Lock()
	defer fake.evalROMutex.Unlock()
	fake.EvalROStub = stub
}

func (fake *FakeClient) EvalROArgsForCall(i int) (context.Context, string, []string, []interface{}) {
	fake.evalROMutex.RLock()
	defer fake.evalROMutex.RUnlock()
	argsForCall := fake.evalROArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) EvalROReturns(result1 *redisa.Cmd) {
	fake.evalROMutex.Lock()
	defer fake.evalROMutex.Unlock()
	fake.EvalROStub = nil
	fake.evalROReturns = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) EvalROReturnsOnCall(i int, result1 *redisa.Cmd) {
	fake.evalROMutex.Lock()
	defer fake.evalROMutex.Unlock()
	fake.EvalROStub = nil
	if fake.evalROReturnsOnCall == nil {
		fake.evalROReturnsOnCall = make(map[int]struct {
			result1 *redisa.Cmd
		})
	}
	fake.evalROReturnsOnCall[i] = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) EvalSha(arg1 context.Context, arg2 string, arg3 []string, arg4 ...interface{}) *redisa.Cmd {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.evalShaMutex.Lock()
	ret, specificReturn := fake.evalShaReturnsOnCall[len(fake.evalShaArgsForCall)]
	fake.evalShaArgsForCall = append(fake.evalShaArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.EvalShaStub
	fakeReturns := fake.evalShaReturns
	fake.recordInvocation("EvalSha", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.evalShaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) EvalShaCallCount() int {
	fake.evalShaMutex.RLock()
	defer fake.evalShaMutex.RUnlock()
	return len(fake.evalShaArgsForCall)
}

func (fake *FakeClient) EvalShaCalls(stub func(context.Context, string, []string, ...interface{}) *redisa.Cmd) {
	fake.evalShaMutex.Lock()
	defer fake.evalShaMutex.Unlock()
	fake.EvalShaStub = stub
}

func (fake *FakeClient) EvalShaArgsForCall(i int) (context.Context, string, []string, []interface{}) {
	fake.evalShaMutex.RLock()
	defer fake.evalShaMutex.RUnlock()
	argsForCall := fake.evalShaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) EvalShaReturns(result1 *redisa.Cmd) {
	fake.evalShaMutex.Lock()
	defer fake.evalShaMutex.Unlock()
	fake.EvalShaStub = nil
	fake.evalShaReturns = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) EvalShaReturnsOnCall(i int, result1 *redisa.Cmd) {
	fake.evalShaMutex.Lock()
	defer fake.evalShaMutex.Unlock()
	fake.EvalShaStub = nil
	if fake.evalShaReturnsOnCall == nil {
		fake.evalShaReturnsOnCall = make(map[int]struct {
			result1 *redisa.Cmd
		})
	}
	fake.evalShaReturnsOnCall[i] = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) EvalShaRO(arg1 context.Context, arg2 string, arg3 []string, arg4 ...interface{}) *redisa.Cmd {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.evalShaROMutex.Lock()
	ret, specificReturn := fake.evalShaROReturnsOnCall[len(fake.evalShaROArgsForCall)]
	fake.evalShaROArgsForCall = append(fake.evalShaROArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.EvalShaROStub
	fakeReturns := fake.evalShaROReturns
	fake.recordInvocation("EvalShaRO", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.evalShaROMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) EvalShaROCallCount() int {
	fake.evalShaROMutex.RLock()
	defer fake.evalShaROMutex.RUnlock()
	return len(fake.evalShaROArgsForCall)
}

func (fake *FakeClient) EvalShaROCalls(stub func(context.Context, string, []string, ...interface{}) *redisa.Cmd) {
	fake.evalShaROMutex.Lock()
	defer fake.evalShaROMutex.Unlock()
	fake.EvalShaROStub = stub
}

func (fake *FakeClient) EvalShaROArgsForCall(i int) (context.Context, string, []string, []interface{}) {
	fake.evalShaROMutex.RLock()
	defer fake.evalShaROMutex.RUnlock()
	argsForCall := fake.evalShaROArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) EvalShaROReturns(result1 *redisa.Cmd) {
	fake.evalShaROMutex.Lock()
	defer fake.evalShaROMutex.Unlock()
	fake.EvalShaROStub = nil
	fake.evalShaROReturns = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) EvalShaROReturnsOnCall(i int, result1 *redisa.Cmd) {
	fake.evalShaROMutex.Lock()
	defer fake.evalShaROMutex.Unlock()
	fake.EvalShaROStub = nil
	if fake.evalShaROReturnsOnCall == nil {
		fake.evalShaROReturnsOnCall = make(map[int]struct {
			result1 *redisa.Cmd
		})
	}
	fake.evalShaROReturnsOnCall[i] = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) Exists(arg1 context.Context, arg2 ...string) *redisa.IntCmd {
	fake.existsMutex.Lock()
	ret, specificReturn := fake.existsReturnsOnCall[len(fake.existsArgsForCall)]
	fake.existsArgsForCall = append(fake.existsArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.ExistsStub
	fakeReturns := fake.existsReturns
	fake.recordInvocation("Exists", []interface{}{arg1, arg2})
	fake.existsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ExistsCallCount() int {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return len(fake.existsArgsForCall)
}

func (fake *FakeClient) ExistsCalls(stub func(context.Context, ...string) *redisa.IntCmd) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = stub
}

func (fake *FakeClient) ExistsArgsForCall(i int) (context.Context, []string) {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	argsForCall := fake.existsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ExistsReturns(result1 *redisa.IntCmd) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	fake.existsReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ExistsReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	if fake.existsReturnsOnCall == nil {
		fake.existsReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.existsReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) Expire(arg1 context.Context, arg2 string, arg3 time.Duration) *redisa.BoolCmd {
	fake.expireMutex.Lock()
	ret, specificReturn := fake.expireReturnsOnCall[len(fake.expireArgsForCall)]
	fake.expireArgsForCall = append(fake.expireArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}{arg1, arg2, arg3})
	stub := fake.ExpireStub
	fakeReturns := fake.expireReturns
	fake.recordInvocation("Expire", []interface{}{arg1, arg2, arg3})
	fake.expireMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ExpireCallCount() int {
	fake.expireMutex.RLock()
	defer fake.expireMutex.RUnlock()
	return len(fake.expireArgsForCall)
}

func (fake *FakeClient) ExpireCalls(stub func(context.Context, string, time.Duration) *redisa.BoolCmd) {
	fake.expireMutex.Lock()
	defer fake.expireMutex.Unlock()
	fake.ExpireStub = stub
}

func (fake *FakeClient) ExpireArgsForCall(i int) (context.Context, string, time.Duration) {
	fake.expireMutex.RLock()
	defer fake.expireMutex.RUnlock()
	argsForCall := fake.expireArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ExpireReturns(result1 *redisa.BoolCmd) {
	fake.expireMutex.Lock()
	defer fake.expireMutex.Unlock()
	fake.ExpireStub = nil
	fake.expireReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ExpireReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.expireMutex.Lock()
	defer fake.expireMutex.Unlock()
	fake.ExpireStub = nil
	if fake.expireReturnsOnCall == nil {
		fake.expireReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.expireReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ExpireAt(arg1 context.Context, arg2 string, arg3 time.Time) *redisa.BoolCmd {
	fake.expireAtMutex.Lock()
	ret, specificReturn := fake.expireAtReturnsOnCall[len(fake.expireAtArgsForCall)]
	fake.expireAtArgsForCall = append(fake.expireAtArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Time
	}{arg1, arg2, arg3})
	stub := fake.ExpireAtStub
	fakeReturns := fake.expireAtReturns
	fake.recordInvocation("ExpireAt", []interface{}{arg1, arg2, arg3})
	fake.expireAtMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ExpireAtCallCount() int {
	fake.expireAtMutex.RLock()
	defer fake.expireAtMutex.RUnlock()
	return len(fake.expireAtArgsForCall)
}

func (fake *FakeClient) ExpireAtCalls(stub func(context.Context, string, time.Time) *redisa.BoolCmd) {
	fake.expireAtMutex.Lock()
	defer fake.expireAtMutex.Unlock()
	fake.ExpireAtStub = stub
}

func (fake *FakeClient) ExpireAtArgsForCall(i int) (context.Context, string, time.Time) {
	fake.expireAtMutex.RLock()
	defer fake.expireAtMutex.RUnlock()
	argsForCall := fake.expireAtArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ExpireAtReturns(result1 *redisa.BoolCmd) {
	fake.expireAtMutex.Lock()
	defer fake.expireAtMutex.Unlock()
	fake.ExpireAtStub = nil
	fake.expireAtReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ExpireAtReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.expireAtMutex.Lock()
	defer fake.expireAtMutex.Unlock()
	fake.ExpireAtStub = nil
	if fake.expireAtReturnsOnCall == nil {
		fake.expireAtReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.expireAtReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ExpireGT(arg1 context.Context, arg2 string, arg3 time.Duration) *redisa.BoolCmd {
	fake.expireGTMutex.Lock()
	ret, specificReturn := fake.expireGTReturnsOnCall[len(fake.expireGTArgsForCall)]
	fake.expireGTArgsForCall = append(fake.expireGTArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}{arg1, arg2, arg3})
	stub := fake.ExpireGTStub
	fakeReturns := fake.expireGTReturns
	fake.recordInvocation("ExpireGT", []interface{}{arg1, arg2, arg3})
	fake.expireGTMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ExpireGTCallCount() int {
	fake.expireGTMutex.RLock()
	defer fake.expireGTMutex.RUnlock()
	return len(fake.expireGTArgsForCall)
}

func (fake *FakeClient) ExpireGTCalls(stub func(context.Context, string, time.Duration) *redisa.BoolCmd) {
	fake.expireGTMutex.Lock()
	defer fake.expireGTMutex.Unlock()
	fake.ExpireGTStub = stub
}

func (fake *FakeClient) ExpireGTArgsForCall(i int) (context.Context, string, time.Duration) {
	fake.expireGTMutex.RLock()
	defer fake.expireGTMutex.RUnlock()
	argsForCall := fake.expireGTArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ExpireGTReturns(result1 *redisa.BoolCmd) {
	fake.expireGTMutex.Lock()
	defer fake.expireGTMutex.Unlock()
	fake.ExpireGTStub = nil
	fake.expireGTReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ExpireGTReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.expireGTMutex.Lock()
	defer fake.expireGTMutex.Unlock()
	fake.ExpireGTStub = nil
	if fake.expireGTReturnsOnCall == nil {
		fake.expireGTReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.expireGTReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ExpireLT(arg1 context.Context, arg2 string, arg3 time.Duration) *redisa.BoolCmd {
	fake.expireLTMutex.Lock()
	ret, specificReturn := fake.expireLTReturnsOnCall[len(fake.expireLTArgsForCall)]
	fake.expireLTArgsForCall = append(fake.expireLTArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}{arg1, arg2, arg3})
	stub := fake.ExpireLTStub
	fakeReturns := fake.expireLTReturns
	fake.recordInvocation("ExpireLT", []interface{}{arg1, arg2, arg3})
	fake.expireLTMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ExpireLTCallCount() int {
	fake.expireLTMutex.RLock()
	defer fake.expireLTMutex.RUnlock()
	return len(fake.expireLTArgsForCall)
}

func (fake *FakeClient) ExpireLTCalls(stub func(context.Context, string, time.Duration) *redisa.BoolCmd) {
	fake.expireLTMutex.Lock()
	defer fake.expireLTMutex.Unlock()
	fake.ExpireLTStub = stub
}

func (fake *FakeClient) ExpireLTArgsForCall(i int) (context.Context, string, time.Duration) {
	fake.expireLTMutex.RLock()
	defer fake.expireLTMutex.RUnlock()
	argsForCall := fake.expireLTArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ExpireLTReturns(result1 *redisa.BoolCmd) {
	fake.expireLTMutex.Lock()
	defer fake.expireLTMutex.Unlock()
	fake.ExpireLTStub = nil
	fake.expireLTReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ExpireLTReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.expireLTMutex.Lock()
	defer fake.expireLTMutex.Unlock()
	fake.ExpireLTStub = nil
	if fake.expireLTReturnsOnCall == nil {
		fake.expireLTReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.expireLTReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ExpireNX(arg1 context.Context, arg2 string, arg3 time.Duration) *redisa.BoolCmd {
	fake.expireNXMutex.Lock()
	ret, specificReturn := fake.expireNXReturnsOnCall[len(fake.expireNXArgsForCall)]
	fake.expireNXArgsForCall = append(fake.expireNXArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}{arg1, arg2, arg3})
	stub := fake.ExpireNXStub
	fakeReturns := fake.expireNXReturns
	fake.recordInvocation("ExpireNX", []interface{}{arg1, arg2, arg3})
	fake.expireNXMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ExpireNXCallCount() int {
	fake.expireNXMutex.RLock()
	defer fake.expireNXMutex.RUnlock()
	return len(fake.expireNXArgsForCall)
}

func (fake *FakeClient) ExpireNXCalls(stub func(context.Context, string, time.Duration) *redisa.BoolCmd) {
	fake.expireNXMutex.Lock()
	defer fake.expireNXMutex.Unlock()
	fake.ExpireNXStub = stub
}

func (fake *FakeClient) ExpireNXArgsForCall(i int) (context.Context, string, time.Duration) {
	fake.expireNXMutex.RLock()
	defer fake.expireNXMutex.RUnlock()
	argsForCall := fake.expireNXArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ExpireNXReturns(result1 *redisa.BoolCmd) {
	fake.expireNXMutex.Lock()
	defer fake.expireNXMutex.Unlock()
	fake.ExpireNXStub = nil
	fake.expireNXReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ExpireNXReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.expireNXMutex.Lock()
	defer fake.expireNXMutex.Unlock()
	fake.ExpireNXStub = nil
	if fake.expireNXReturnsOnCall == nil {
		fake.expireNXReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.expireNXReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ExpireTime(arg1 context.Context, arg2 string) *redisa.DurationCmd {
	fake.expireTimeMutex.Lock()
	ret, specificReturn := fake.expireTimeReturnsOnCall[len(fake.expireTimeArgsForCall)]
	fake.expireTimeArgsForCall = append(fake.expireTimeArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ExpireTimeStub
	fakeReturns := fake.expireTimeReturns
	fake.recordInvocation("ExpireTime", []interface{}{arg1, arg2})
	fake.expireTimeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ExpireTimeCallCount() int {
	fake.expireTimeMutex.RLock()
	defer fake.expireTimeMutex.RUnlock()
	return len(fake.expireTimeArgsForCall)
}

func (fake *FakeClient) ExpireTimeCalls(stub func(context.Context, string) *redisa.DurationCmd) {
	fake.expireTimeMutex.Lock()
	defer fake.expireTimeMutex.Unlock()
	fake.ExpireTimeStub = stub
}

func (fake *FakeClient) ExpireTimeArgsForCall(i int) (context.Context, string) {
	fake.expireTimeMutex.RLock()
	defer fake.expireTimeMutex.RUnlock()
	argsForCall := fake.expireTimeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ExpireTimeReturns(result1 *redisa.DurationCmd) {
	fake.expireTimeMutex.Lock()
	defer fake.expireTimeMutex.Unlock()
	fake.ExpireTimeStub = nil
	fake.expireTimeReturns = struct {
		result1 *redisa.DurationCmd
	}{result1}
}

func (fake *FakeClient) ExpireTimeReturnsOnCall(i int, result1 *redisa.DurationCmd) {
	fake.expireTimeMutex.Lock()
	defer fake.expireTimeMutex.Unlock()
	fake.ExpireTimeStub = nil
	if fake.expireTimeReturnsOnCall == nil {
		fake.expireTimeReturnsOnCall = make(map[int]struct {
			result1 *redisa.DurationCmd
		})
	}
	fake.expireTimeReturnsOnCall[i] = struct {
		result1 *redisa.DurationCmd
	}{result1}
}

func (fake *FakeClient) ExpireXX(arg1 context.Context, arg2 string, arg3 time.Duration) *redisa.BoolCmd {
	fake.expireXXMutex.Lock()
	ret, specificReturn := fake.expireXXReturnsOnCall[len(fake.expireXXArgsForCall)]
	fake.expireXXArgsForCall = append(fake.expireXXArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}{arg1, arg2, arg3})
	stub := fake.ExpireXXStub
	fakeReturns := fake.expireXXReturns
	fake.recordInvocation("ExpireXX", []interface{}{arg1, arg2, arg3})
	fake.expireXXMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ExpireXXCallCount() int {
	fake.expireXXMutex.RLock()
	defer fake.expireXXMutex.RUnlock()
	return len(fake.expireXXArgsForCall)
}

func (fake *FakeClient) ExpireXXCalls(stub func(context.Context, string, time.Duration) *redisa.BoolCmd) {
	fake.expireXXMutex.Lock()
	defer fake.expireXXMutex.Unlock()
	fake.ExpireXXStub = stub
}

func (fake *FakeClient) ExpireXXArgsForCall(i int) (context.Context, string, time.Duration) {
	fake.expireXXMutex.RLock()
	defer fake.expireXXMutex.RUnlock()
	argsForCall := fake.expireXXArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ExpireXXReturns(result1 *redisa.BoolCmd) {
	fake.expireXXMutex.Lock()
	defer fake.expireXXMutex.Unlock()
	fake.ExpireXXStub = nil
	fake.expireXXReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ExpireXXReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.expireXXMutex.Lock()
	defer fake.expireXXMutex.Unlock()
	fake.ExpireXXStub = nil
	if fake.expireXXReturnsOnCall == nil {
		fake.expireXXReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.expireXXReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) FCall(arg1 context.Context, arg2 string, arg3 []string, arg4 ...interface{}) *redisa.Cmd {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.fCallMutex.Lock()
	ret, specificReturn := fake.fCallReturnsOnCall[len(fake.fCallArgsForCall)]
	fake.fCallArgsForCall = append(fake.fCallArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.FCallStub
	fakeReturns := fake.fCallReturns
	fake.recordInvocation("FCall", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.fCallMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FCallCallCount() int {
	fake.fCallMutex.RLock()
	defer fake.fCallMutex.RUnlock()
	return len(fake.fCallArgsForCall)
}

func (fake *FakeClient) FCallCalls(stub func(context.Context, string, []string, ...interface{}) *redisa.Cmd) {
	fake.fCallMutex.Lock()
	defer fake.fCallMutex.Unlock()
	fake.FCallStub = stub
}

func (fake *FakeClient) FCallArgsForCall(i int) (context.Context, string, []string, []interface{}) {
	fake.fCallMutex.RLock()
	defer fake.fCallMutex.RUnlock()
	argsForCall := fake.fCallArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) FCallReturns(result1 *redisa.Cmd) {
	fake.fCallMutex.Lock()
	defer fake.fCallMutex.Unlock()
	fake.FCallStub = nil
	fake.fCallReturns = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) FCallReturnsOnCall(i int, result1 *redisa.Cmd) {
	fake.fCallMutex.Lock()
	defer fake.fCallMutex.Unlock()
	fake.FCallStub = nil
	if fake.fCallReturnsOnCall == nil {
		fake.fCallReturnsOnCall = make(map[int]struct {
			result1 *redisa.Cmd
		})
	}
	fake.fCallReturnsOnCall[i] = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) FCallRO(arg1 context.Context, arg2 string, arg3 []string, arg4 ...interface{}) *redisa.Cmd {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.fCallROMutex.Lock()
	ret, specificReturn := fake.fCallROReturnsOnCall[len(fake.fCallROArgsForCall)]
	fake.fCallROArgsForCall = append(fake.fCallROArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.FCallROStub
	fakeReturns := fake.fCallROReturns
	fake.recordInvocation("FCallRO", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.fCallROMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FCallROCallCount() int {
	fake.fCallROMutex.RLock()
	defer fake.fCallROMutex.RUnlock()
	return len(fake.fCallROArgsForCall)
}

func (fake *FakeClient) FCallROCalls(stub func(context.Context, string, []string, ...interface{}) *redisa.Cmd) {
	fake.fCallROMutex.Lock()
	defer fake.fCallROMutex.Unlock()
	fake.FCallROStub = stub
}

func (fake *FakeClient) FCallROArgsForCall(i int) (context.Context, string, []string, []interface{}) {
	fake.fCallROMutex.RLock()
	defer fake.fCallROMutex.RUnlock()
	argsForCall := fake.fCallROArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) FCallROReturns(result1 *redisa.Cmd) {
	fake.fCallROMutex.Lock()
	defer fake.fCallROMutex.Unlock()
	fake.FCallROStub = nil
	fake.fCallROReturns = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) FCallROReturnsOnCall(i int, result1 *redisa.Cmd) {
	fake.fCallROMutex.Lock()
	defer fake.fCallROMutex.Unlock()
	fake.FCallROStub = nil
	if fake.fCallROReturnsOnCall == nil {
		fake.fCallROReturnsOnCall = make(map[int]struct {
			result1 *redisa.Cmd
		})
	}
	fake.fCallROReturnsOnCall[i] = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) FCallRo(arg1 context.Context, arg2 string, arg3 []string, arg4 ...interface{}) *redisa.Cmd {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.fCallRoMutex.Lock()
	ret, specificReturn := fake.fCallRoReturnsOnCall[len(fake.fCallRoArgsForCall)]
	fake.fCallRoArgsForCall = append(fake.fCallRoArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 []interface{}
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.FCallRoStub
	fakeReturns := fake.fCallRoReturns
	fake.recordInvocation("FCallRo", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.fCallRoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FCallRoCallCount() int {
	fake.fCallRoMutex.RLock()
	defer fake.fCallRoMutex.RUnlock()
	return len(fake.fCallRoArgsForCall)
}

func (fake *FakeClient) FCallRoCalls(stub func(context.Context, string, []string, ...interface{}) *redisa.Cmd) {
	fake.fCallRoMutex.Lock()
	defer fake.fCallRoMutex.Unlock()
	fake.FCallRoStub = stub
}

func (fake *FakeClient) FCallRoArgsForCall(i int) (context.Context, string, []string, []interface{}) {
	fake.fCallRoMutex.RLock()
	defer fake.fCallRoMutex.RUnlock()
	argsForCall := fake.fCallRoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) FCallRoReturns(result1 *redisa.Cmd) {
	fake.fCallRoMutex.Lock()
	defer fake.fCallRoMutex.Unlock()
	fake.FCallRoStub = nil
	fake.fCallRoReturns = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) FCallRoReturnsOnCall(i int, result1 *redisa.Cmd) {
	fake.fCallRoMutex.Lock()
	defer fake.fCallRoMutex.Unlock()
	fake.FCallRoStub = nil
	if fake.fCallRoReturnsOnCall == nil {
		fake.fCallRoReturnsOnCall = make(map[int]struct {
			result1 *redisa.Cmd
		})
	}
	fake.fCallRoReturnsOnCall[i] = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) FTAggregate(arg1 context.Context, arg2 string, arg3 string) *redisa.MapStringInterfaceCmd {
	fake.fTAggregateMutex.Lock()
	ret, specificReturn := fake.fTAggregateReturnsOnCall[len(fake.fTAggregateArgsForCall)]
	fake.fTAggregateArgsForCall = append(fake.fTAggregateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FTAggregateStub
	fakeReturns := fake.fTAggregateReturns
	fake.recordInvocation("FTAggregate", []interface{}{arg1, arg2, arg3})
	fake.fTAggregateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTAggregateCallCount() int {
	fake.fTAggregateMutex.RLock()
	defer fake.fTAggregateMutex.RUnlock()
	return len(fake.fTAggregateArgsForCall)
}

func (fake *FakeClient) FTAggregateCalls(stub func(context.Context, string, string) *redisa.MapStringInterfaceCmd) {
	fake.fTAggregateMutex.Lock()
	defer fake.fTAggregateMutex.Unlock()
	fake.FTAggregateStub = stub
}

func (fake *FakeClient) FTAggregateArgsForCall(i int) (context.Context, string, string) {
	fake.fTAggregateMutex.RLock()
	defer fake.fTAggregateMutex.RUnlock()
	argsForCall := fake.fTAggregateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) FTAggregateReturns(result1 *redisa.MapStringInterfaceCmd) {
	fake.fTAggregateMutex.Lock()
	defer fake.fTAggregateMutex.Unlock()
	fake.FTAggregateStub = nil
	fake.fTAggregateReturns = struct {
		result1 *redisa.MapStringInterfaceCmd
	}{result1}
}

func (fake *FakeClient) FTAggregateReturnsOnCall(i int, result1 *redisa.MapStringInterfaceCmd) {
	fake.fTAggregateMutex.Lock()
	defer fake.fTAggregateMutex.Unlock()
	fake.FTAggregateStub = nil
	if fake.fTAggregateReturnsOnCall == nil {
		fake.fTAggregateReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringInterfaceCmd
		})
	}
	fake.fTAggregateReturnsOnCall[i] = struct {
		result1 *redisa.MapStringInterfaceCmd
	}{result1}
}

func (fake *FakeClient) FTAggregateWithArgs(arg1 context.Context, arg2 string, arg3 string, arg4 *redisa.FTAggregateOptions) *redisa.AggregateCmd {
	fake.fTAggregateWithArgsMutex.Lock()
	ret, specificReturn := fake.fTAggregateWithArgsReturnsOnCall[len(fake.fTAggregateWithArgsArgsForCall)]
	fake.fTAggregateWithArgsArgsForCall = append(fake.fTAggregateWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.FTAggregateOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.FTAggregateWithArgsStub
	fakeReturns := fake.fTAggregateWithArgsReturns
	fake.recordInvocation("FTAggregateWithArgs", []interface{}{arg1, arg2, arg3, arg4})
	fake.fTAggregateWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTAggregateWithArgsCallCount() int {
	fake.fTAggregateWithArgsMutex.RLock()
	defer fake.fTAggregateWithArgsMutex.RUnlock()
	return len(fake.fTAggregateWithArgsArgsForCall)
}

func (fake *FakeClient) FTAggregateWithArgsCalls(stub func(context.Context, string, string, *redisa.FTAggregateOptions) *redisa.AggregateCmd) {
	fake.fTAggregateWithArgsMutex.Lock()
	defer fake.fTAggregateWithArgsMutex.Unlock()
	fake.FTAggregateWithArgsStub = stub
}

func (fake *FakeClient) FTAggregateWithArgsArgsForCall(i int) (context.Context, string, string, *redisa.FTAggregateOptions) {
	fake.fTAggregateWithArgsMutex.RLock()
	defer fake.fTAggregateWithArgsMutex.RUnlock()
	argsForCall := fake.fTAggregateWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) FTAggregateWithArgsReturns(result1 *redisa.AggregateCmd) {
	fake.fTAggregateWithArgsMutex.Lock()
	defer fake.fTAggregateWithArgsMutex.Unlock()
	fake.FTAggregateWithArgsStub = nil
	fake.fTAggregateWithArgsReturns = struct {
		result1 *redisa.AggregateCmd
	}{result1}
}

func (fake *FakeClient) FTAggregateWithArgsReturnsOnCall(i int, result1 *redisa.AggregateCmd) {
	fake.fTAggregateWithArgsMutex.Lock()
	defer fake.fTAggregateWithArgsMutex.Unlock()
	fake.FTAggregateWithArgsStub = nil
	if fake.fTAggregateWithArgsReturnsOnCall == nil {
		fake.fTAggregateWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.AggregateCmd
		})
	}
	fake.fTAggregateWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.AggregateCmd
	}{result1}
}

func (fake *FakeClient) FTAliasAdd(arg1 context.Context, arg2 string, arg3 string) *redisa.StatusCmd {
	fake.fTAliasAddMutex.Lock()
	ret, specificReturn := fake.fTAliasAddReturnsOnCall[len(fake.fTAliasAddArgsForCall)]
	fake.fTAliasAddArgsForCall = append(fake.fTAliasAddArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FTAliasAddStub
	fakeReturns := fake.fTAliasAddReturns
	fake.recordInvocation("FTAliasAdd", []interface{}{arg1, arg2, arg3})
	fake.fTAliasAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTAliasAddCallCount() int {
	fake.fTAliasAddMutex.RLock()
	defer fake.fTAliasAddMutex.RUnlock()
	return len(fake.fTAliasAddArgsForCall)
}

func (fake *FakeClient) FTAliasAddCalls(stub func(context.Context, string, string) *redisa.StatusCmd) {
	fake.fTAliasAddMutex.Lock()
	defer fake.fTAliasAddMutex.Unlock()
	fake.FTAliasAddStub = stub
}

func (fake *FakeClient) FTAliasAddArgsForCall(i int) (context.Context, string, string) {
	fake.fTAliasAddMutex.RLock()
	defer fake.fTAliasAddMutex.RUnlock()
	argsForCall := fake.fTAliasAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) FTAliasAddReturns(result1 *redisa.StatusCmd) {
	fake.fTAliasAddMutex.Lock()
	defer fake.fTAliasAddMutex.Unlock()
	fake.FTAliasAddStub = nil
	fake.fTAliasAddReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTAliasAddReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.fTAliasAddMutex.Lock()
	defer fake.fTAliasAddMutex.Unlock()
	fake.FTAliasAddStub = nil
	if fake.fTAliasAddReturnsOnCall == nil {
		fake.fTAliasAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.fTAliasAddReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTAliasDel(arg1 context.Context, arg2 string) *redisa.StatusCmd {
	fake.fTAliasDelMutex.Lock()
	ret, specificReturn := fake.fTAliasDelReturnsOnCall[len(fake.fTAliasDelArgsForCall)]
	fake.fTAliasDelArgsForCall = append(fake.fTAliasDelArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FTAliasDelStub
	fakeReturns := fake.fTAliasDelReturns
	fake.recordInvocation("FTAliasDel", []interface{}{arg1, arg2})
	fake.fTAliasDelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTAliasDelCallCount() int {
	fake.fTAliasDelMutex.RLock()
	defer fake.fTAliasDelMutex.RUnlock()
	return len(fake.fTAliasDelArgsForCall)
}

func (fake *FakeClient) FTAliasDelCalls(stub func(context.Context, string) *redisa.StatusCmd) {
	fake.fTAliasDelMutex.Lock()
	defer fake.fTAliasDelMutex.Unlock()
	fake.FTAliasDelStub = stub
}

func (fake *FakeClient) FTAliasDelArgsForCall(i int) (context.Context, string) {
	fake.fTAliasDelMutex.RLock()
	defer fake.fTAliasDelMutex.RUnlock()
	argsForCall := fake.fTAliasDelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) FTAliasDelReturns(result1 *redisa.StatusCmd) {
	fake.fTAliasDelMutex.Lock()
	defer fake.fTAliasDelMutex.Unlock()
	fake.FTAliasDelStub = nil
	fake.fTAliasDelReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTAliasDelReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.fTAliasDelMutex.Lock()
	defer fake.fTAliasDelMutex.Unlock()
	fake.FTAliasDelStub = nil
	if fake.fTAliasDelReturnsOnCall == nil {
		fake.fTAliasDelReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.fTAliasDelReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTAliasUpdate(arg1 context.Context, arg2 string, arg3 string) *redisa.StatusCmd {
	fake.fTAliasUpdateMutex.Lock()
	ret, specificReturn := fake.fTAliasUpdateReturnsOnCall[len(fake.fTAliasUpdateArgsForCall)]
	fake.fTAliasUpdateArgsForCall = append(fake.fTAliasUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FTAliasUpdateStub
	fakeReturns := fake.fTAliasUpdateReturns
	fake.recordInvocation("FTAliasUpdate", []interface{}{arg1, arg2, arg3})
	fake.fTAliasUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTAliasUpdateCallCount() int {
	fake.fTAliasUpdateMutex.RLock()
	defer fake.fTAliasUpdateMutex.RUnlock()
	return len(fake.fTAliasUpdateArgsForCall)
}

func (fake *FakeClient) FTAliasUpdateCalls(stub func(context.Context, string, string) *redisa.StatusCmd) {
	fake.fTAliasUpdateMutex.Lock()
	defer fake.fTAliasUpdateMutex.Unlock()
	fake.FTAliasUpdateStub = stub
}

func (fake *FakeClient) FTAliasUpdateArgsForCall(i int) (context.Context, string, string) {
	fake.fTAliasUpdateMutex.RLock()
	defer fake.fTAliasUpdateMutex.RUnlock()
	argsForCall := fake.fTAliasUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) FTAliasUpdateReturns(result1 *redisa.StatusCmd) {
	fake.fTAliasUpdateMutex.Lock()
	defer fake.fTAliasUpdateMutex.Unlock()
	fake.FTAliasUpdateStub = nil
	fake.fTAliasUpdateReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTAliasUpdateReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.fTAliasUpdateMutex.Lock()
	defer fake.fTAliasUpdateMutex.Unlock()
	fake.FTAliasUpdateStub = nil
	if fake.fTAliasUpdateReturnsOnCall == nil {
		fake.fTAliasUpdateReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.fTAliasUpdateReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTAlter(arg1 context.Context, arg2 string, arg3 bool, arg4 []interface{}) *redisa.StatusCmd {
	var arg4Copy []interface{}
	if arg4 != nil {
		arg4Copy = make([]interface{}, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.fTAlterMutex.Lock()
	ret, specificReturn := fake.fTAlterReturnsOnCall[len(fake.fTAlterArgsForCall)]
	fake.fTAlterArgsForCall = append(fake.fTAlterArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 bool
		arg4 []interface{}
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.FTAlterStub
	fakeReturns := fake.fTAlterReturns
	fake.recordInvocation("FTAlter", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.fTAlterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTAlterCallCount() int {
	fake.fTAlterMutex.RLock()
	defer fake.fTAlterMutex.RUnlock()
	return len(fake.fTAlterArgsForCall)
}

func (fake *FakeClient) FTAlterCalls(stub func(context.Context, string, bool, []interface{}) *redisa.StatusCmd) {
	fake.fTAlterMutex.Lock()
	defer fake.fTAlterMutex.Unlock()
	fake.FTAlterStub = stub
}

func (fake *FakeClient) FTAlterArgsForCall(i int) (context.Context, string, bool, []interface{}) {
	fake.fTAlterMutex.RLock()
	defer fake.fTAlterMutex.RUnlock()
	argsForCall := fake.fTAlterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) FTAlterReturns(result1 *redisa.StatusCmd) {
	fake.fTAlterMutex.Lock()
	defer fake.fTAlterMutex.Unlock()
	fake.FTAlterStub = nil
	fake.fTAlterReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTAlterReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.fTAlterMutex.Lock()
	defer fake.fTAlterMutex.Unlock()
	fake.FTAlterStub = nil
	if fake.fTAlterReturnsOnCall == nil {
		fake.fTAlterReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.fTAlterReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTConfigGet(arg1 context.Context, arg2 string) *redisa.MapMapStringInterfaceCmd {
	fake.fTConfigGetMutex.Lock()
	ret, specificReturn := fake.fTConfigGetReturnsOnCall[len(fake.fTConfigGetArgsForCall)]
	fake.fTConfigGetArgsForCall = append(fake.fTConfigGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FTConfigGetStub
	fakeReturns := fake.fTConfigGetReturns
	fake.recordInvocation("FTConfigGet", []interface{}{arg1, arg2})
	fake.fTConfigGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTConfigGetCallCount() int {
	fake.fTConfigGetMutex.RLock()
	defer fake.fTConfigGetMutex.RUnlock()
	return len(fake.fTConfigGetArgsForCall)
}

func (fake *FakeClient) FTConfigGetCalls(stub func(context.Context, string) *redisa.MapMapStringInterfaceCmd) {
	fake.fTConfigGetMutex.Lock()
	defer fake.fTConfigGetMutex.Unlock()
	fake.FTConfigGetStub = stub
}

func (fake *FakeClient) FTConfigGetArgsForCall(i int) (context.Context, string) {
	fake.fTConfigGetMutex.RLock()
	defer fake.fTConfigGetMutex.RUnlock()
	argsForCall := fake.fTConfigGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) FTConfigGetReturns(result1 *redisa.MapMapStringInterfaceCmd) {
	fake.fTConfigGetMutex.Lock()
	defer fake.fTConfigGetMutex.Unlock()
	fake.FTConfigGetStub = nil
	fake.fTConfigGetReturns = struct {
		result1 *redisa.MapMapStringInterfaceCmd
	}{result1}
}

func (fake *FakeClient) FTConfigGetReturnsOnCall(i int, result1 *redisa.MapMapStringInterfaceCmd) {
	fake.fTConfigGetMutex.Lock()
	defer fake.fTConfigGetMutex.Unlock()
	fake.FTConfigGetStub = nil
	if fake.fTConfigGetReturnsOnCall == nil {
		fake.fTConfigGetReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapMapStringInterfaceCmd
		})
	}
	fake.fTConfigGetReturnsOnCall[i] = struct {
		result1 *redisa.MapMapStringInterfaceCmd
	}{result1}
}

func (fake *FakeClient) FTConfigSet(arg1 context.Context, arg2 string, arg3 interface{}) *redisa.StatusCmd {
	fake.fTConfigSetMutex.Lock()
	ret, specificReturn := fake.fTConfigSetReturnsOnCall[len(fake.fTConfigSetArgsForCall)]
	fake.fTConfigSetArgsForCall = append(fake.fTConfigSetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.FTConfigSetStub
	fakeReturns := fake.fTConfigSetReturns
	fake.recordInvocation("FTConfigSet", []interface{}{arg1, arg2, arg3})
	fake.fTConfigSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTConfigSetCallCount() int {
	fake.fTConfigSetMutex.RLock()
	defer fake.fTConfigSetMutex.RUnlock()
	return len(fake.fTConfigSetArgsForCall)
}

func (fake *FakeClient) FTConfigSetCalls(stub func(context.Context, string, interface{}) *redisa.StatusCmd) {
	fake.fTConfigSetMutex.Lock()
	defer fake.fTConfigSetMutex.Unlock()
	fake.FTConfigSetStub = stub
}

func (fake *FakeClient) FTConfigSetArgsForCall(i int) (context.Context, string, interface{}) {
	fake.fTConfigSetMutex.RLock()
	defer fake.fTConfigSetMutex.RUnlock()
	argsForCall := fake.fTConfigSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) FTConfigSetReturns(result1 *redisa.StatusCmd) {
	fake.fTConfigSetMutex.Lock()
	defer fake.fTConfigSetMutex.Unlock()
	fake.FTConfigSetStub = nil
	fake.fTConfigSetReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTConfigSetReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.fTConfigSetMutex.Lock()
	defer fake.fTConfigSetMutex.Unlock()
	fake.FTConfigSetStub = nil
	if fake.fTConfigSetReturnsOnCall == nil {
		fake.fTConfigSetReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.fTConfigSetReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTCreate(arg1 context.Context, arg2 string, arg3 *redisa.FTCreateOptions, arg4 ...*redisa.FieldSchema) *redisa.StatusCmd {
	fake.fTCreateMutex.Lock()
	ret, specificReturn := fake.fTCreateReturnsOnCall[len(fake.fTCreateArgsForCall)]
	fake.fTCreateArgsForCall = append(fake.fTCreateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.FTCreateOptions
		arg4 []*redisa.FieldSchema
	}{arg1, arg2, arg3, arg4})
	stub := fake.FTCreateStub
	fakeReturns := fake.fTCreateReturns
	fake.recordInvocation("FTCreate", []interface{}{arg1, arg2, arg3, arg4})
	fake.fTCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTCreateCallCount() int {
	fake.fTCreateMutex.RLock()
	defer fake.fTCreateMutex.RUnlock()
	return len(fake.fTCreateArgsForCall)
}

func (fake *FakeClient) FTCreateCalls(stub func(context.Context, string, *redisa.FTCreateOptions, ...*redisa.FieldSchema) *redisa.StatusCmd) {
	fake.fTCreateMutex.Lock()
	defer fake.fTCreateMutex.Unlock()
	fake.FTCreateStub = stub
}

func (fake *FakeClient) FTCreateArgsForCall(i int) (context.Context, string, *redisa.FTCreateOptions, []*redisa.FieldSchema) {
	fake.fTCreateMutex.RLock()
	defer fake.fTCreateMutex.RUnlock()
	argsForCall := fake.fTCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) FTCreateReturns(result1 *redisa.StatusCmd) {
	fake.fTCreateMutex.Lock()
	defer fake.fTCreateMutex.Unlock()
	fake.FTCreateStub = nil
	fake.fTCreateReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTCreateReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.fTCreateMutex.Lock()
	defer fake.fTCreateMutex.Unlock()
	fake.FTCreateStub = nil
	if fake.fTCreateReturnsOnCall == nil {
		fake.fTCreateReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.fTCreateReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTCursorDel(arg1 context.Context, arg2 string, arg3 int) *redisa.StatusCmd {
	fake.fTCursorDelMutex.Lock()
	ret, specificReturn := fake.fTCursorDelReturnsOnCall[len(fake.fTCursorDelArgsForCall)]
	fake.fTCursorDelArgsForCall = append(fake.fTCursorDelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.FTCursorDelStub
	fakeReturns := fake.fTCursorDelReturns
	fake.recordInvocation("FTCursorDel", []interface{}{arg1, arg2, arg3})
	fake.fTCursorDelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTCursorDelCallCount() int {
	fake.fTCursorDelMutex.RLock()
	defer fake.fTCursorDelMutex.RUnlock()
	return len(fake.fTCursorDelArgsForCall)
}

func (fake *FakeClient) FTCursorDelCalls(stub func(context.Context, string, int) *redisa.StatusCmd) {
	fake.fTCursorDelMutex.Lock()
	defer fake.fTCursorDelMutex.Unlock()
	fake.FTCursorDelStub = stub
}

func (fake *FakeClient) FTCursorDelArgsForCall(i int) (context.Context, string, int) {
	fake.fTCursorDelMutex.RLock()
	defer fake.fTCursorDelMutex.RUnlock()
	argsForCall := fake.fTCursorDelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) FTCursorDelReturns(result1 *redisa.StatusCmd) {
	fake.fTCursorDelMutex.Lock()
	defer fake.fTCursorDelMutex.Unlock()
	fake.FTCursorDelStub = nil
	fake.fTCursorDelReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTCursorDelReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.fTCursorDelMutex.Lock()
	defer fake.fTCursorDelMutex.Unlock()
	fake.FTCursorDelStub = nil
	if fake.fTCursorDelReturnsOnCall == nil {
		fake.fTCursorDelReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.fTCursorDelReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTCursorRead(arg1 context.Context, arg2 string, arg3 int, arg4 int) *redisa.MapStringInterfaceCmd {
	fake.fTCursorReadMutex.Lock()
	ret, specificReturn := fake.fTCursorReadReturnsOnCall[len(fake.fTCursorReadArgsForCall)]
	fake.fTCursorReadArgsForCall = append(fake.fTCursorReadArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.FTCursorReadStub
	fakeReturns := fake.fTCursorReadReturns
	fake.recordInvocation("FTCursorRead", []interface{}{arg1, arg2, arg3, arg4})
	fake.fTCursorReadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTCursorReadCallCount() int {
	fake.fTCursorReadMutex.RLock()
	defer fake.fTCursorReadMutex.RUnlock()
	return len(fake.fTCursorReadArgsForCall)
}

func (fake *FakeClient) FTCursorReadCalls(stub func(context.Context, string, int, int) *redisa.MapStringInterfaceCmd) {
	fake.fTCursorReadMutex.Lock()
	defer fake.fTCursorReadMutex.Unlock()
	fake.FTCursorReadStub = stub
}

func (fake *FakeClient) FTCursorReadArgsForCall(i int) (context.Context, string, int, int) {
	fake.fTCursorReadMutex.RLock()
	defer fake.fTCursorReadMutex.RUnlock()
	argsForCall := fake.fTCursorReadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) FTCursorReadReturns(result1 *redisa.MapStringInterfaceCmd) {
	fake.fTCursorReadMutex.Lock()
	defer fake.fTCursorReadMutex.Unlock()
	fake.FTCursorReadStub = nil
	fake.fTCursorReadReturns = struct {
		result1 *redisa.MapStringInterfaceCmd
	}{result1}
}

func (fake *FakeClient) FTCursorReadReturnsOnCall(i int, result1 *redisa.MapStringInterfaceCmd) {
	fake.fTCursorReadMutex.Lock()
	defer fake.fTCursorReadMutex.Unlock()
	fake.FTCursorReadStub = nil
	if fake.fTCursorReadReturnsOnCall == nil {
		fake.fTCursorReadReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringInterfaceCmd
		})
	}
	fake.fTCursorReadReturnsOnCall[i] = struct {
		result1 *redisa.MapStringInterfaceCmd
	}{result1}
}

func (fake *FakeClient) FTDictAdd(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntCmd {
	fake.fTDictAddMutex.Lock()
	ret, specificReturn := fake.fTDictAddReturnsOnCall[len(fake.fTDictAddArgsForCall)]
	fake.fTDictAddArgsForCall = append(fake.fTDictAddArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.FTDictAddStub
	fakeReturns := fake.fTDictAddReturns
	fake.recordInvocation("FTDictAdd", []interface{}{arg1, arg2, arg3})
	fake.fTDictAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTDictAddCallCount() int {
	fake.fTDictAddMutex.RLock()
	defer fake.fTDictAddMutex.RUnlock()
	return len(fake.fTDictAddArgsForCall)
}

func (fake *FakeClient) FTDictAddCalls(stub func(context.Context, string, ...interface{}) *redisa.IntCmd) {
	fake.fTDictAddMutex.Lock()
	defer fake.fTDictAddMutex.Unlock()
	fake.FTDictAddStub = stub
}

func (fake *FakeClient) FTDictAddArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.fTDictAddMutex.RLock()
	defer fake.fTDictAddMutex.RUnlock()
	argsForCall := fake.fTDictAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) FTDictAddReturns(result1 *redisa.IntCmd) {
	fake.fTDictAddMutex.Lock()
	defer fake.fTDictAddMutex.Unlock()
	fake.FTDictAddStub = nil
	fake.fTDictAddReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) FTDictAddReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.fTDictAddMutex.Lock()
	defer fake.fTDictAddMutex.Unlock()
	fake.FTDictAddStub = nil
	if fake.fTDictAddReturnsOnCall == nil {
		fake.fTDictAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.fTDictAddReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) FTDictDel(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntCmd {
	fake.fTDictDelMutex.Lock()
	ret, specificReturn := fake.fTDictDelReturnsOnCall[len(fake.fTDictDelArgsForCall)]
	fake.fTDictDelArgsForCall = append(fake.fTDictDelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.FTDictDelStub
	fakeReturns := fake.fTDictDelReturns
	fake.recordInvocation("FTDictDel", []interface{}{arg1, arg2, arg3})
	fake.fTDictDelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTDictDelCallCount() int {
	fake.fTDictDelMutex.RLock()
	defer fake.fTDictDelMutex.RUnlock()
	return len(fake.fTDictDelArgsForCall)
}

func (fake *FakeClient) FTDictDelCalls(stub func(context.Context, string, ...interface{}) *redisa.IntCmd) {
	fake.fTDictDelMutex.Lock()
	defer fake.fTDictDelMutex.Unlock()
	fake.FTDictDelStub = stub
}

func (fake *FakeClient) FTDictDelArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.fTDictDelMutex.RLock()
	defer fake.fTDictDelMutex.RUnlock()
	argsForCall := fake.fTDictDelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) FTDictDelReturns(result1 *redisa.IntCmd) {
	fake.fTDictDelMutex.Lock()
	defer fake.fTDictDelMutex.Unlock()
	fake.FTDictDelStub = nil
	fake.fTDictDelReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) FTDictDelReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.fTDictDelMutex.Lock()
	defer fake.fTDictDelMutex.Unlock()
	fake.FTDictDelStub = nil
	if fake.fTDictDelReturnsOnCall == nil {
		fake.fTDictDelReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.fTDictDelReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) FTDictDump(arg1 context.Context, arg2 string) *redisa.StringSliceCmd {
	fake.fTDictDumpMutex.Lock()
	ret, specificReturn := fake.fTDictDumpReturnsOnCall[len(fake.fTDictDumpArgsForCall)]
	fake.fTDictDumpArgsForCall = append(fake.fTDictDumpArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FTDictDumpStub
	fakeReturns := fake.fTDictDumpReturns
	fake.recordInvocation("FTDictDump", []interface{}{arg1, arg2})
	fake.fTDictDumpMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTDictDumpCallCount() int {
	fake.fTDictDumpMutex.RLock()
	defer fake.fTDictDumpMutex.RUnlock()
	return len(fake.fTDictDumpArgsForCall)
}

func (fake *FakeClient) FTDictDumpCalls(stub func(context.Context, string) *redisa.StringSliceCmd) {
	fake.fTDictDumpMutex.Lock()
	defer fake.fTDictDumpMutex.Unlock()
	fake.FTDictDumpStub = stub
}

func (fake *FakeClient) FTDictDumpArgsForCall(i int) (context.Context, string) {
	fake.fTDictDumpMutex.RLock()
	defer fake.fTDictDumpMutex.RUnlock()
	argsForCall := fake.fTDictDumpArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) FTDictDumpReturns(result1 *redisa.StringSliceCmd) {
	fake.fTDictDumpMutex.Lock()
	defer fake.fTDictDumpMutex.Unlock()
	fake.FTDictDumpStub = nil
	fake.fTDictDumpReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) FTDictDumpReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.fTDictDumpMutex.Lock()
	defer fake.fTDictDumpMutex.Unlock()
	fake.FTDictDumpStub = nil
	if fake.fTDictDumpReturnsOnCall == nil {
		fake.fTDictDumpReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.fTDictDumpReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) FTDropIndex(arg1 context.Context, arg2 string) *redisa.StatusCmd {
	fake.fTDropIndexMutex.Lock()
	ret, specificReturn := fake.fTDropIndexReturnsOnCall[len(fake.fTDropIndexArgsForCall)]
	fake.fTDropIndexArgsForCall = append(fake.fTDropIndexArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FTDropIndexStub
	fakeReturns := fake.fTDropIndexReturns
	fake.recordInvocation("FTDropIndex", []interface{}{arg1, arg2})
	fake.fTDropIndexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTDropIndexCallCount() int {
	fake.fTDropIndexMutex.RLock()
	defer fake.fTDropIndexMutex.RUnlock()
	return len(fake.fTDropIndexArgsForCall)
}

func (fake *FakeClient) FTDropIndexCalls(stub func(context.Context, string) *redisa.StatusCmd) {
	fake.fTDropIndexMutex.Lock()
	defer fake.fTDropIndexMutex.Unlock()
	fake.FTDropIndexStub = stub
}

func (fake *FakeClient) FTDropIndexArgsForCall(i int) (context.Context, string) {
	fake.fTDropIndexMutex.RLock()
	defer fake.fTDropIndexMutex.RUnlock()
	argsForCall := fake.fTDropIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) FTDropIndexReturns(result1 *redisa.StatusCmd) {
	fake.fTDropIndexMutex.Lock()
	defer fake.fTDropIndexMutex.Unlock()
	fake.FTDropIndexStub = nil
	fake.fTDropIndexReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTDropIndexReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.fTDropIndexMutex.Lock()
	defer fake.fTDropIndexMutex.Unlock()
	fake.FTDropIndexStub = nil
	if fake.fTDropIndexReturnsOnCall == nil {
		fake.fTDropIndexReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.fTDropIndexReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTDropIndexWithArgs(arg1 context.Context, arg2 string, arg3 *redisa.FTDropIndexOptions) *redisa.StatusCmd {
	fake.fTDropIndexWithArgsMutex.Lock()
	ret, specificReturn := fake.fTDropIndexWithArgsReturnsOnCall[len(fake.fTDropIndexWithArgsArgsForCall)]
	fake.fTDropIndexWithArgsArgsForCall = append(fake.fTDropIndexWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.FTDropIndexOptions
	}{arg1, arg2, arg3})
	stub := fake.FTDropIndexWithArgsStub
	fakeReturns := fake.fTDropIndexWithArgsReturns
	fake.recordInvocation("FTDropIndexWithArgs", []interface{}{arg1, arg2, arg3})
	fake.fTDropIndexWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTDropIndexWithArgsCallCount() int {
	fake.fTDropIndexWithArgsMutex.RLock()
	defer fake.fTDropIndexWithArgsMutex.RUnlock()
	return len(fake.fTDropIndexWithArgsArgsForCall)
}

func (fake *FakeClient) FTDropIndexWithArgsCalls(stub func(context.Context, string, *redisa.FTDropIndexOptions) *redisa.StatusCmd) {
	fake.fTDropIndexWithArgsMutex.Lock()
	defer fake.fTDropIndexWithArgsMutex.Unlock()
	fake.FTDropIndexWithArgsStub = stub
}

func (fake *FakeClient) FTDropIndexWithArgsArgsForCall(i int) (context.Context, string, *redisa.FTDropIndexOptions) {
	fake.fTDropIndexWithArgsMutex.RLock()
	defer fake.fTDropIndexWithArgsMutex.RUnlock()
	argsForCall := fake.fTDropIndexWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) FTDropIndexWithArgsReturns(result1 *redisa.StatusCmd) {
	fake.fTDropIndexWithArgsMutex.Lock()
	defer fake.fTDropIndexWithArgsMutex.Unlock()
	fake.FTDropIndexWithArgsStub = nil
	fake.fTDropIndexWithArgsReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTDropIndexWithArgsReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.fTDropIndexWithArgsMutex.Lock()
	defer fake.fTDropIndexWithArgsMutex.Unlock()
	fake.FTDropIndexWithArgsStub = nil
	if fake.fTDropIndexWithArgsReturnsOnCall == nil {
		fake.fTDropIndexWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.fTDropIndexWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTExplain(arg1 context.Context, arg2 string, arg3 string) *redisa.StringCmd {
	fake.fTExplainMutex.Lock()
	ret, specificReturn := fake.fTExplainReturnsOnCall[len(fake.fTExplainArgsForCall)]
	fake.fTExplainArgsForCall = append(fake.fTExplainArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FTExplainStub
	fakeReturns := fake.fTExplainReturns
	fake.recordInvocation("FTExplain", []interface{}{arg1, arg2, arg3})
	fake.fTExplainMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTExplainCallCount() int {
	fake.fTExplainMutex.RLock()
	defer fake.fTExplainMutex.RUnlock()
	return len(fake.fTExplainArgsForCall)
}

func (fake *FakeClient) FTExplainCalls(stub func(context.Context, string, string) *redisa.StringCmd) {
	fake.fTExplainMutex.Lock()
	defer fake.fTExplainMutex.Unlock()
	fake.FTExplainStub = stub
}

func (fake *FakeClient) FTExplainArgsForCall(i int) (context.Context, string, string) {
	fake.fTExplainMutex.RLock()
	defer fake.fTExplainMutex.RUnlock()
	argsForCall := fake.fTExplainArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) FTExplainReturns(result1 *redisa.StringCmd) {
	fake.fTExplainMutex.Lock()
	defer fake.fTExplainMutex.Unlock()
	fake.FTExplainStub = nil
	fake.fTExplainReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FTExplainReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.fTExplainMutex.Lock()
	defer fake.fTExplainMutex.Unlock()
	fake.FTExplainStub = nil
	if fake.fTExplainReturnsOnCall == nil {
		fake.fTExplainReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.fTExplainReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FTExplainWithArgs(arg1 context.Context, arg2 string, arg3 string, arg4 *redisa.FTExplainOptions) *redisa.StringCmd {
	fake.fTExplainWithArgsMutex.Lock()
	ret, specificReturn := fake.fTExplainWithArgsReturnsOnCall[len(fake.fTExplainWithArgsArgsForCall)]
	fake.fTExplainWithArgsArgsForCall = append(fake.fTExplainWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.FTExplainOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.FTExplainWithArgsStub
	fakeReturns := fake.fTExplainWithArgsReturns
	fake.recordInvocation("FTExplainWithArgs", []interface{}{arg1, arg2, arg3, arg4})
	fake.fTExplainWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTExplainWithArgsCallCount() int {
	fake.fTExplainWithArgsMutex.RLock()
	defer fake.fTExplainWithArgsMutex.RUnlock()
	return len(fake.fTExplainWithArgsArgsForCall)
}

func (fake *FakeClient) FTExplainWithArgsCalls(stub func(context.Context, string, string, *redisa.FTExplainOptions) *redisa.StringCmd) {
	fake.fTExplainWithArgsMutex.Lock()
	defer fake.fTExplainWithArgsMutex.Unlock()
	fake.FTExplainWithArgsStub = stub
}

func (fake *FakeClient) FTExplainWithArgsArgsForCall(i int) (context.Context, string, string, *redisa.FTExplainOptions) {
	fake.fTExplainWithArgsMutex.RLock()
	defer fake.fTExplainWithArgsMutex.RUnlock()
	argsForCall := fake.fTExplainWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) FTExplainWithArgsReturns(result1 *redisa.StringCmd) {
	fake.fTExplainWithArgsMutex.Lock()
	defer fake.fTExplainWithArgsMutex.Unlock()
	fake.FTExplainWithArgsStub = nil
	fake.fTExplainWithArgsReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FTExplainWithArgsReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.fTExplainWithArgsMutex.Lock()
	defer fake.fTExplainWithArgsMutex.Unlock()
	fake.FTExplainWithArgsStub = nil
	if fake.fTExplainWithArgsReturnsOnCall == nil {
		fake.fTExplainWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.fTExplainWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FTInfo(arg1 context.Context, arg2 string) *redisa.FTInfoCmd {
	fake.fTInfoMutex.Lock()
	ret, specificReturn := fake.fTInfoReturnsOnCall[len(fake.fTInfoArgsForCall)]
	fake.fTInfoArgsForCall = append(fake.fTInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FTInfoStub
	fakeReturns := fake.fTInfoReturns
	fake.recordInvocation("FTInfo", []interface{}{arg1, arg2})
	fake.fTInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTInfoCallCount() int {
	fake.fTInfoMutex.RLock()
	defer fake.fTInfoMutex.RUnlock()
	return len(fake.fTInfoArgsForCall)
}

func (fake *FakeClient) FTInfoCalls(stub func(context.Context, string) *redisa.FTInfoCmd) {
	fake.fTInfoMutex.Lock()
	defer fake.fTInfoMutex.Unlock()
	fake.FTInfoStub = stub
}

func (fake *FakeClient) FTInfoArgsForCall(i int) (context.Context, string) {
	fake.fTInfoMutex.RLock()
	defer fake.fTInfoMutex.RUnlock()
	argsForCall := fake.fTInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) FTInfoReturns(result1 *redisa.FTInfoCmd) {
	fake.fTInfoMutex.Lock()
	defer fake.fTInfoMutex.Unlock()
	fake.FTInfoStub = nil
	fake.fTInfoReturns = struct {
		result1 *redisa.FTInfoCmd
	}{result1}
}

func (fake *FakeClient) FTInfoReturnsOnCall(i int, result1 *redisa.FTInfoCmd) {
	fake.fTInfoMutex.Lock()
	defer fake.fTInfoMutex.Unlock()
	fake.FTInfoStub = nil
	if fake.fTInfoReturnsOnCall == nil {
		fake.fTInfoReturnsOnCall = make(map[int]struct {
			result1 *redisa.FTInfoCmd
		})
	}
	fake.fTInfoReturnsOnCall[i] = struct {
		result1 *redisa.FTInfoCmd
	}{result1}
}

func (fake *FakeClient) FTSearch(arg1 context.Context, arg2 string, arg3 string) *redisa.FTSearchCmd {
	fake.fTSearchMutex.Lock()
	ret, specificReturn := fake.fTSearchReturnsOnCall[len(fake.fTSearchArgsForCall)]
	fake.fTSearchArgsForCall = append(fake.fTSearchArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FTSearchStub
	fakeReturns := fake.fTSearchReturns
	fake.recordInvocation("FTSearch", []interface{}{arg1, arg2, arg3})
	fake.fTSearchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTSearchCallCount() int {
	fake.fTSearchMutex.RLock()
	defer fake.fTSearchMutex.RUnlock()
	return len(fake.fTSearchArgsForCall)
}

func (fake *FakeClient) FTSearchCalls(stub func(context.Context, string, string) *redisa.FTSearchCmd) {
	fake.fTSearchMutex.Lock()
	defer fake.fTSearchMutex.Unlock()
	fake.FTSearchStub = stub
}

func (fake *FakeClient) FTSearchArgsForCall(i int) (context.Context, string, string) {
	fake.fTSearchMutex.RLock()
	defer fake.fTSearchMutex.RUnlock()
	argsForCall := fake.fTSearchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) FTSearchReturns(result1 *redisa.FTSearchCmd) {
	fake.fTSearchMutex.Lock()
	defer fake.fTSearchMutex.Unlock()
	fake.FTSearchStub = nil
	fake.fTSearchReturns = struct {
		result1 *redisa.FTSearchCmd
	}{result1}
}

func (fake *FakeClient) FTSearchReturnsOnCall(i int, result1 *redisa.FTSearchCmd) {
	fake.fTSearchMutex.Lock()
	defer fake.fTSearchMutex.Unlock()
	fake.FTSearchStub = nil
	if fake.fTSearchReturnsOnCall == nil {
		fake.fTSearchReturnsOnCall = make(map[int]struct {
			result1 *redisa.FTSearchCmd
		})
	}
	fake.fTSearchReturnsOnCall[i] = struct {
		result1 *redisa.FTSearchCmd
	}{result1}
}

func (fake *FakeClient) FTSearchWithArgs(arg1 context.Context, arg2 string, arg3 string, arg4 *redisa.FTSearchOptions) *redisa.FTSearchCmd {
	fake.fTSearchWithArgsMutex.Lock()
	ret, specificReturn := fake.fTSearchWithArgsReturnsOnCall[len(fake.fTSearchWithArgsArgsForCall)]
	fake.fTSearchWithArgsArgsForCall = append(fake.fTSearchWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.FTSearchOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.FTSearchWithArgsStub
	fakeReturns := fake.fTSearchWithArgsReturns
	fake.recordInvocation("FTSearchWithArgs", []interface{}{arg1, arg2, arg3, arg4})
	fake.fTSearchWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTSearchWithArgsCallCount() int {
	fake.fTSearchWithArgsMutex.RLock()
	defer fake.fTSearchWithArgsMutex.RUnlock()
	return len(fake.fTSearchWithArgsArgsForCall)
}

func (fake *FakeClient) FTSearchWithArgsCalls(stub func(context.Context, string, string, *redisa.FTSearchOptions) *redisa.FTSearchCmd) {
	fake.fTSearchWithArgsMutex.Lock()
	defer fake.fTSearchWithArgsMutex.Unlock()
	fake.FTSearchWithArgsStub = stub
}

func (fake *FakeClient) FTSearchWithArgsArgsForCall(i int) (context.Context, string, string, *redisa.FTSearchOptions) {
	fake.fTSearchWithArgsMutex.RLock()
	defer fake.fTSearchWithArgsMutex.RUnlock()
	argsForCall := fake.fTSearchWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) FTSearchWithArgsReturns(result1 *redisa.FTSearchCmd) {
	fake.fTSearchWithArgsMutex.Lock()
	defer fake.fTSearchWithArgsMutex.Unlock()
	fake.FTSearchWithArgsStub = nil
	fake.fTSearchWithArgsReturns = struct {
		result1 *redisa.FTSearchCmd
	}{result1}
}

func (fake *FakeClient) FTSearchWithArgsReturnsOnCall(i int, result1 *redisa.FTSearchCmd) {
	fake.fTSearchWithArgsMutex.Lock()
	defer fake.fTSearchWithArgsMutex.Unlock()
	fake.FTSearchWithArgsStub = nil
	if fake.fTSearchWithArgsReturnsOnCall == nil {
		fake.fTSearchWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.FTSearchCmd
		})
	}
	fake.fTSearchWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.FTSearchCmd
	}{result1}
}

func (fake *FakeClient) FTSpellCheck(arg1 context.Context, arg2 string, arg3 string) *redisa.FTSpellCheckCmd {
	fake.fTSpellCheckMutex.Lock()
	ret, specificReturn := fake.fTSpellCheckReturnsOnCall[len(fake.fTSpellCheckArgsForCall)]
	fake.fTSpellCheckArgsForCall = append(fake.fTSpellCheckArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FTSpellCheckStub
	fakeReturns := fake.fTSpellCheckReturns
	fake.recordInvocation("FTSpellCheck", []interface{}{arg1, arg2, arg3})
	fake.fTSpellCheckMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTSpellCheckCallCount() int {
	fake.fTSpellCheckMutex.RLock()
	defer fake.fTSpellCheckMutex.RUnlock()
	return len(fake.fTSpellCheckArgsForCall)
}

func (fake *FakeClient) FTSpellCheckCalls(stub func(context.Context, string, string) *redisa.FTSpellCheckCmd) {
	fake.fTSpellCheckMutex.Lock()
	defer fake.fTSpellCheckMutex.Unlock()
	fake.FTSpellCheckStub = stub
}

func (fake *FakeClient) FTSpellCheckArgsForCall(i int) (context.Context, string, string) {
	fake.fTSpellCheckMutex.RLock()
	defer fake.fTSpellCheckMutex.RUnlock()
	argsForCall := fake.fTSpellCheckArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) FTSpellCheckReturns(result1 *redisa.FTSpellCheckCmd) {
	fake.fTSpellCheckMutex.Lock()
	defer fake.fTSpellCheckMutex.Unlock()
	fake.FTSpellCheckStub = nil
	fake.fTSpellCheckReturns = struct {
		result1 *redisa.FTSpellCheckCmd
	}{result1}
}

func (fake *FakeClient) FTSpellCheckReturnsOnCall(i int, result1 *redisa.FTSpellCheckCmd) {
	fake.fTSpellCheckMutex.Lock()
	defer fake.fTSpellCheckMutex.Unlock()
	fake.FTSpellCheckStub = nil
	if fake.fTSpellCheckReturnsOnCall == nil {
		fake.fTSpellCheckReturnsOnCall = make(map[int]struct {
			result1 *redisa.FTSpellCheckCmd
		})
	}
	fake.fTSpellCheckReturnsOnCall[i] = struct {
		result1 *redisa.FTSpellCheckCmd
	}{result1}
}

func (fake *FakeClient) FTSpellCheckWithArgs(arg1 context.Context, arg2 string, arg3 string, arg4 *redisa.FTSpellCheckOptions) *redisa.FTSpellCheckCmd {
	fake.fTSpellCheckWithArgsMutex.Lock()
	ret, specificReturn := fake.fTSpellCheckWithArgsReturnsOnCall[len(fake.fTSpellCheckWithArgsArgsForCall)]
	fake.fTSpellCheckWithArgsArgsForCall = append(fake.fTSpellCheckWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.FTSpellCheckOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.FTSpellCheckWithArgsStub
	fakeReturns := fake.fTSpellCheckWithArgsReturns
	fake.recordInvocation("FTSpellCheckWithArgs", []interface{}{arg1, arg2, arg3, arg4})
	fake.fTSpellCheckWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTSpellCheckWithArgsCallCount() int {
	fake.fTSpellCheckWithArgsMutex.RLock()
	defer fake.fTSpellCheckWithArgsMutex.RUnlock()
	return len(fake.fTSpellCheckWithArgsArgsForCall)
}

func (fake *FakeClient) FTSpellCheckWithArgsCalls(stub func(context.Context, string, string, *redisa.FTSpellCheckOptions) *redisa.FTSpellCheckCmd) {
	fake.fTSpellCheckWithArgsMutex.Lock()
	defer fake.fTSpellCheckWithArgsMutex.Unlock()
	fake.FTSpellCheckWithArgsStub = stub
}

func (fake *FakeClient) FTSpellCheckWithArgsArgsForCall(i int) (context.Context, string, string, *redisa.FTSpellCheckOptions) {
	fake.fTSpellCheckWithArgsMutex.RLock()
	defer fake.fTSpellCheckWithArgsMutex.RUnlock()
	argsForCall := fake.fTSpellCheckWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) FTSpellCheckWithArgsReturns(result1 *redisa.FTSpellCheckCmd) {
	fake.fTSpellCheckWithArgsMutex.Lock()
	defer fake.fTSpellCheckWithArgsMutex.Unlock()
	fake.FTSpellCheckWithArgsStub = nil
	fake.fTSpellCheckWithArgsReturns = struct {
		result1 *redisa.FTSpellCheckCmd
	}{result1}
}

func (fake *FakeClient) FTSpellCheckWithArgsReturnsOnCall(i int, result1 *redisa.FTSpellCheckCmd) {
	fake.fTSpellCheckWithArgsMutex.Lock()
	defer fake.fTSpellCheckWithArgsMutex.Unlock()
	fake.FTSpellCheckWithArgsStub = nil
	if fake.fTSpellCheckWithArgsReturnsOnCall == nil {
		fake.fTSpellCheckWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.FTSpellCheckCmd
		})
	}
	fake.fTSpellCheckWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.FTSpellCheckCmd
	}{result1}
}

func (fake *FakeClient) FTSynDump(arg1 context.Context, arg2 string) *redisa.FTSynDumpCmd {
	fake.fTSynDumpMutex.Lock()
	ret, specificReturn := fake.fTSynDumpReturnsOnCall[len(fake.fTSynDumpArgsForCall)]
	fake.fTSynDumpArgsForCall = append(fake.fTSynDumpArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FTSynDumpStub
	fakeReturns := fake.fTSynDumpReturns
	fake.recordInvocation("FTSynDump", []interface{}{arg1, arg2})
	fake.fTSynDumpMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTSynDumpCallCount() int {
	fake.fTSynDumpMutex.RLock()
	defer fake.fTSynDumpMutex.RUnlock()
	return len(fake.fTSynDumpArgsForCall)
}

func (fake *FakeClient) FTSynDumpCalls(stub func(context.Context, string) *redisa.FTSynDumpCmd) {
	fake.fTSynDumpMutex.Lock()
	defer fake.fTSynDumpMutex.Unlock()
	fake.FTSynDumpStub = stub
}

func (fake *FakeClient) FTSynDumpArgsForCall(i int) (context.Context, string) {
	fake.fTSynDumpMutex.RLock()
	defer fake.fTSynDumpMutex.RUnlock()
	argsForCall := fake.fTSynDumpArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) FTSynDumpReturns(result1 *redisa.FTSynDumpCmd) {
	fake.fTSynDumpMutex.Lock()
	defer fake.fTSynDumpMutex.Unlock()
	fake.FTSynDumpStub = nil
	fake.fTSynDumpReturns = struct {
		result1 *redisa.FTSynDumpCmd
	}{result1}
}

func (fake *FakeClient) FTSynDumpReturnsOnCall(i int, result1 *redisa.FTSynDumpCmd) {
	fake.fTSynDumpMutex.Lock()
	defer fake.fTSynDumpMutex.Unlock()
	fake.FTSynDumpStub = nil
	if fake.fTSynDumpReturnsOnCall == nil {
		fake.fTSynDumpReturnsOnCall = make(map[int]struct {
			result1 *redisa.FTSynDumpCmd
		})
	}
	fake.fTSynDumpReturnsOnCall[i] = struct {
		result1 *redisa.FTSynDumpCmd
	}{result1}
}

func (fake *FakeClient) FTSynUpdate(arg1 context.Context, arg2 string, arg3 interface{}, arg4 []interface{}) *redisa.StatusCmd {
	var arg4Copy []interface{}
	if arg4 != nil {
		arg4Copy = make([]interface{}, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.fTSynUpdateMutex.Lock()
	ret, specificReturn := fake.fTSynUpdateReturnsOnCall[len(fake.fTSynUpdateArgsForCall)]
	fake.fTSynUpdateArgsForCall = append(fake.fTSynUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 []interface{}
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.FTSynUpdateStub
	fakeReturns := fake.fTSynUpdateReturns
	fake.recordInvocation("FTSynUpdate", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.fTSynUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTSynUpdateCallCount() int {
	fake.fTSynUpdateMutex.RLock()
	defer fake.fTSynUpdateMutex.RUnlock()
	return len(fake.fTSynUpdateArgsForCall)
}

func (fake *FakeClient) FTSynUpdateCalls(stub func(context.Context, string, interface{}, []interface{}) *redisa.StatusCmd) {
	fake.fTSynUpdateMutex.Lock()
	defer fake.fTSynUpdateMutex.Unlock()
	fake.FTSynUpdateStub = stub
}

func (fake *FakeClient) FTSynUpdateArgsForCall(i int) (context.Context, string, interface{}, []interface{}) {
	fake.fTSynUpdateMutex.RLock()
	defer fake.fTSynUpdateMutex.RUnlock()
	argsForCall := fake.fTSynUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) FTSynUpdateReturns(result1 *redisa.StatusCmd) {
	fake.fTSynUpdateMutex.Lock()
	defer fake.fTSynUpdateMutex.Unlock()
	fake.FTSynUpdateStub = nil
	fake.fTSynUpdateReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTSynUpdateReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.fTSynUpdateMutex.Lock()
	defer fake.fTSynUpdateMutex.Unlock()
	fake.FTSynUpdateStub = nil
	if fake.fTSynUpdateReturnsOnCall == nil {
		fake.fTSynUpdateReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.fTSynUpdateReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTSynUpdateWithArgs(arg1 context.Context, arg2 string, arg3 interface{}, arg4 *redisa.FTSynUpdateOptions, arg5 []interface{}) *redisa.StatusCmd {
	var arg5Copy []interface{}
	if arg5 != nil {
		arg5Copy = make([]interface{}, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.fTSynUpdateWithArgsMutex.Lock()
	ret, specificReturn := fake.fTSynUpdateWithArgsReturnsOnCall[len(fake.fTSynUpdateWithArgsArgsForCall)]
	fake.fTSynUpdateWithArgsArgsForCall = append(fake.fTSynUpdateWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 *redisa.FTSynUpdateOptions
		arg5 []interface{}
	}{arg1, arg2, arg3, arg4, arg5Copy})
	stub := fake.FTSynUpdateWithArgsStub
	fakeReturns := fake.fTSynUpdateWithArgsReturns
	fake.recordInvocation("FTSynUpdateWithArgs", []interface{}{arg1, arg2, arg3, arg4, arg5Copy})
	fake.fTSynUpdateWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTSynUpdateWithArgsCallCount() int {
	fake.fTSynUpdateWithArgsMutex.RLock()
	defer fake.fTSynUpdateWithArgsMutex.RUnlock()
	return len(fake.fTSynUpdateWithArgsArgsForCall)
}

func (fake *FakeClient) FTSynUpdateWithArgsCalls(stub func(context.Context, string, interface{}, *redisa.FTSynUpdateOptions, []interface{}) *redisa.StatusCmd) {
	fake.fTSynUpdateWithArgsMutex.Lock()
	defer fake.fTSynUpdateWithArgsMutex.Unlock()
	fake.FTSynUpdateWithArgsStub = stub
}

func (fake *FakeClient) FTSynUpdateWithArgsArgsForCall(i int) (context.Context, string, interface{}, *redisa.FTSynUpdateOptions, []interface{}) {
	fake.fTSynUpdateWithArgsMutex.RLock()
	defer fake.fTSynUpdateWithArgsMutex.RUnlock()
	argsForCall := fake.fTSynUpdateWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) FTSynUpdateWithArgsReturns(result1 *redisa.StatusCmd) {
	fake.fTSynUpdateWithArgsMutex.Lock()
	defer fake.fTSynUpdateWithArgsMutex.Unlock()
	fake.FTSynUpdateWithArgsStub = nil
	fake.fTSynUpdateWithArgsReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTSynUpdateWithArgsReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.fTSynUpdateWithArgsMutex.Lock()
	defer fake.fTSynUpdateWithArgsMutex.Unlock()
	fake.FTSynUpdateWithArgsStub = nil
	if fake.fTSynUpdateWithArgsReturnsOnCall == nil {
		fake.fTSynUpdateWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.fTSynUpdateWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FTTagVals(arg1 context.Context, arg2 string, arg3 string) *redisa.StringSliceCmd {
	fake.fTTagValsMutex.Lock()
	ret, specificReturn := fake.fTTagValsReturnsOnCall[len(fake.fTTagValsArgsForCall)]
	fake.fTTagValsArgsForCall = append(fake.fTTagValsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FTTagValsStub
	fakeReturns := fake.fTTagValsReturns
	fake.recordInvocation("FTTagVals", []interface{}{arg1, arg2, arg3})
	fake.fTTagValsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FTTagValsCallCount() int {
	fake.fTTagValsMutex.RLock()
	defer fake.fTTagValsMutex.RUnlock()
	return len(fake.fTTagValsArgsForCall)
}

func (fake *FakeClient) FTTagValsCalls(stub func(context.Context, string, string) *redisa.StringSliceCmd) {
	fake.fTTagValsMutex.Lock()
	defer fake.fTTagValsMutex.Unlock()
	fake.FTTagValsStub = stub
}

func (fake *FakeClient) FTTagValsArgsForCall(i int) (context.Context, string, string) {
	fake.fTTagValsMutex.RLock()
	defer fake.fTTagValsMutex.RUnlock()
	argsForCall := fake.fTTagValsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) FTTagValsReturns(result1 *redisa.StringSliceCmd) {
	fake.fTTagValsMutex.Lock()
	defer fake.fTTagValsMutex.Unlock()
	fake.FTTagValsStub = nil
	fake.fTTagValsReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) FTTagValsReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.fTTagValsMutex.Lock()
	defer fake.fTTagValsMutex.Unlock()
	fake.FTTagValsStub = nil
	if fake.fTTagValsReturnsOnCall == nil {
		fake.fTTagValsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.fTTagValsReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) FT_List(arg1 context.Context) *redisa.StringSliceCmd {
	fake.fT_ListMutex.Lock()
	ret, specificReturn := fake.fT_ListReturnsOnCall[len(fake.fT_ListArgsForCall)]
	fake.fT_ListArgsForCall = append(fake.fT_ListArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.FT_ListStub
	fakeReturns := fake.fT_ListReturns
	fake.recordInvocation("FT_List", []interface{}{arg1})
	fake.fT_ListMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FT_ListCallCount() int {
	fake.fT_ListMutex.RLock()
	defer fake.fT_ListMutex.RUnlock()
	return len(fake.fT_ListArgsForCall)
}

func (fake *FakeClient) FT_ListCalls(stub func(context.Context) *redisa.StringSliceCmd) {
	fake.fT_ListMutex.Lock()
	defer fake.fT_ListMutex.Unlock()
	fake.FT_ListStub = stub
}

func (fake *FakeClient) FT_ListArgsForCall(i int) context.Context {
	fake.fT_ListMutex.RLock()
	defer fake.fT_ListMutex.RUnlock()
	argsForCall := fake.fT_ListArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) FT_ListReturns(result1 *redisa.StringSliceCmd) {
	fake.fT_ListMutex.Lock()
	defer fake.fT_ListMutex.Unlock()
	fake.FT_ListStub = nil
	fake.fT_ListReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) FT_ListReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.fT_ListMutex.Lock()
	defer fake.fT_ListMutex.Unlock()
	fake.FT_ListStub = nil
	if fake.fT_ListReturnsOnCall == nil {
		fake.fT_ListReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.fT_ListReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) FlushAll(arg1 context.Context) *redisa.StatusCmd {
	fake.flushAllMutex.Lock()
	ret, specificReturn := fake.flushAllReturnsOnCall[len(fake.flushAllArgsForCall)]
	fake.flushAllArgsForCall = append(fake.flushAllArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.FlushAllStub
	fakeReturns := fake.flushAllReturns
	fake.recordInvocation("FlushAll", []interface{}{arg1})
	fake.flushAllMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FlushAllCallCount() int {
	fake.flushAllMutex.RLock()
	defer fake.flushAllMutex.RUnlock()
	return len(fake.flushAllArgsForCall)
}

func (fake *FakeClient) FlushAllCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.flushAllMutex.Lock()
	defer fake.flushAllMutex.Unlock()
	fake.FlushAllStub = stub
}

func (fake *FakeClient) FlushAllArgsForCall(i int) context.Context {
	fake.flushAllMutex.RLock()
	defer fake.flushAllMutex.RUnlock()
	argsForCall := fake.flushAllArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) FlushAllReturns(result1 *redisa.StatusCmd) {
	fake.flushAllMutex.Lock()
	defer fake.flushAllMutex.Unlock()
	fake.FlushAllStub = nil
	fake.flushAllReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FlushAllReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.flushAllMutex.Lock()
	defer fake.flushAllMutex.Unlock()
	fake.FlushAllStub = nil
	if fake.flushAllReturnsOnCall == nil {
		fake.flushAllReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.flushAllReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FlushAllAsync(arg1 context.Context) *redisa.StatusCmd {
	fake.flushAllAsyncMutex.Lock()
	ret, specificReturn := fake.flushAllAsyncReturnsOnCall[len(fake.flushAllAsyncArgsForCall)]
	fake.flushAllAsyncArgsForCall = append(fake.flushAllAsyncArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.FlushAllAsyncStub
	fakeReturns := fake.flushAllAsyncReturns
	fake.recordInvocation("FlushAllAsync", []interface{}{arg1})
	fake.flushAllAsyncMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FlushAllAsyncCallCount() int {
	fake.flushAllAsyncMutex.RLock()
	defer fake.flushAllAsyncMutex.RUnlock()
	return len(fake.flushAllAsyncArgsForCall)
}

func (fake *FakeClient) FlushAllAsyncCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.flushAllAsyncMutex.Lock()
	defer fake.flushAllAsyncMutex.Unlock()
	fake.FlushAllAsyncStub = stub
}

func (fake *FakeClient) FlushAllAsyncArgsForCall(i int) context.Context {
	fake.flushAllAsyncMutex.RLock()
	defer fake.flushAllAsyncMutex.RUnlock()
	argsForCall := fake.flushAllAsyncArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) FlushAllAsyncReturns(result1 *redisa.StatusCmd) {
	fake.flushAllAsyncMutex.Lock()
	defer fake.flushAllAsyncMutex.Unlock()
	fake.FlushAllAsyncStub = nil
	fake.flushAllAsyncReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FlushAllAsyncReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.flushAllAsyncMutex.Lock()
	defer fake.flushAllAsyncMutex.Unlock()
	fake.FlushAllAsyncStub = nil
	if fake.flushAllAsyncReturnsOnCall == nil {
		fake.flushAllAsyncReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.flushAllAsyncReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FlushDB(arg1 context.Context) *redisa.StatusCmd {
	fake.flushDBMutex.Lock()
	ret, specificReturn := fake.flushDBReturnsOnCall[len(fake.flushDBArgsForCall)]
	fake.flushDBArgsForCall = append(fake.flushDBArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.FlushDBStub
	fakeReturns := fake.flushDBReturns
	fake.recordInvocation("FlushDB", []interface{}{arg1})
	fake.flushDBMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FlushDBCallCount() int {
	fake.flushDBMutex.RLock()
	defer fake.flushDBMutex.RUnlock()
	return len(fake.flushDBArgsForCall)
}

func (fake *FakeClient) FlushDBCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.flushDBMutex.Lock()
	defer fake.flushDBMutex.Unlock()
	fake.FlushDBStub = stub
}

func (fake *FakeClient) FlushDBArgsForCall(i int) context.Context {
	fake.flushDBMutex.RLock()
	defer fake.flushDBMutex.RUnlock()
	argsForCall := fake.flushDBArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) FlushDBReturns(result1 *redisa.StatusCmd) {
	fake.flushDBMutex.Lock()
	defer fake.flushDBMutex.Unlock()
	fake.FlushDBStub = nil
	fake.flushDBReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FlushDBReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.flushDBMutex.Lock()
	defer fake.flushDBMutex.Unlock()
	fake.FlushDBStub = nil
	if fake.flushDBReturnsOnCall == nil {
		fake.flushDBReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.flushDBReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FlushDBAsync(arg1 context.Context) *redisa.StatusCmd {
	fake.flushDBAsyncMutex.Lock()
	ret, specificReturn := fake.flushDBAsyncReturnsOnCall[len(fake.flushDBAsyncArgsForCall)]
	fake.flushDBAsyncArgsForCall = append(fake.flushDBAsyncArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.FlushDBAsyncStub
	fakeReturns := fake.flushDBAsyncReturns
	fake.recordInvocation("FlushDBAsync", []interface{}{arg1})
	fake.flushDBAsyncMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FlushDBAsyncCallCount() int {
	fake.flushDBAsyncMutex.RLock()
	defer fake.flushDBAsyncMutex.RUnlock()
	return len(fake.flushDBAsyncArgsForCall)
}

func (fake *FakeClient) FlushDBAsyncCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.flushDBAsyncMutex.Lock()
	defer fake.flushDBAsyncMutex.Unlock()
	fake.FlushDBAsyncStub = stub
}

func (fake *FakeClient) FlushDBAsyncArgsForCall(i int) context.Context {
	fake.flushDBAsyncMutex.RLock()
	defer fake.flushDBAsyncMutex.RUnlock()
	argsForCall := fake.flushDBAsyncArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) FlushDBAsyncReturns(result1 *redisa.StatusCmd) {
	fake.flushDBAsyncMutex.Lock()
	defer fake.flushDBAsyncMutex.Unlock()
	fake.FlushDBAsyncStub = nil
	fake.flushDBAsyncReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FlushDBAsyncReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.flushDBAsyncMutex.Lock()
	defer fake.flushDBAsyncMutex.Unlock()
	fake.FlushDBAsyncStub = nil
	if fake.flushDBAsyncReturnsOnCall == nil {
		fake.flushDBAsyncReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.flushDBAsyncReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) FunctionDelete(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.functionDeleteMutex.Lock()
	ret, specificReturn := fake.functionDeleteReturnsOnCall[len(fake.functionDeleteArgsForCall)]
	fake.functionDeleteArgsForCall = append(fake.functionDeleteArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FunctionDeleteStub
	fakeReturns := fake.functionDeleteReturns
	fake.recordInvocation("FunctionDelete", []interface{}{arg1, arg2})
	fake.functionDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FunctionDeleteCallCount() int {
	fake.functionDeleteMutex.RLock()
	defer fake.functionDeleteMutex.RUnlock()
	return len(fake.functionDeleteArgsForCall)
}

func (fake *FakeClient) FunctionDeleteCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.functionDeleteMutex.Lock()
	defer fake.functionDeleteMutex.Unlock()
	fake.FunctionDeleteStub = stub
}

func (fake *FakeClient) FunctionDeleteArgsForCall(i int) (context.Context, string) {
	fake.functionDeleteMutex.RLock()
	defer fake.functionDeleteMutex.RUnlock()
	argsForCall := fake.functionDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) FunctionDeleteReturns(result1 *redisa.StringCmd) {
	fake.functionDeleteMutex.Lock()
	defer fake.functionDeleteMutex.Unlock()
	fake.FunctionDeleteStub = nil
	fake.functionDeleteReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionDeleteReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.functionDeleteMutex.Lock()
	defer fake.functionDeleteMutex.Unlock()
	fake.FunctionDeleteStub = nil
	if fake.functionDeleteReturnsOnCall == nil {
		fake.functionDeleteReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.functionDeleteReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionDump(arg1 context.Context) *redisa.StringCmd {
	fake.functionDumpMutex.Lock()
	ret, specificReturn := fake.functionDumpReturnsOnCall[len(fake.functionDumpArgsForCall)]
	fake.functionDumpArgsForCall = append(fake.functionDumpArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.FunctionDumpStub
	fakeReturns := fake.functionDumpReturns
	fake.recordInvocation("FunctionDump", []interface{}{arg1})
	fake.functionDumpMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FunctionDumpCallCount() int {
	fake.functionDumpMutex.RLock()
	defer fake.functionDumpMutex.RUnlock()
	return len(fake.functionDumpArgsForCall)
}

func (fake *FakeClient) FunctionDumpCalls(stub func(context.Context) *redisa.StringCmd) {
	fake.functionDumpMutex.Lock()
	defer fake.functionDumpMutex.Unlock()
	fake.FunctionDumpStub = stub
}

func (fake *FakeClient) FunctionDumpArgsForCall(i int) context.Context {
	fake.functionDumpMutex.RLock()
	defer fake.functionDumpMutex.RUnlock()
	argsForCall := fake.functionDumpArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) FunctionDumpReturns(result1 *redisa.StringCmd) {
	fake.functionDumpMutex.Lock()
	defer fake.functionDumpMutex.Unlock()
	fake.FunctionDumpStub = nil
	fake.functionDumpReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionDumpReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.functionDumpMutex.Lock()
	defer fake.functionDumpMutex.Unlock()
	fake.FunctionDumpStub = nil
	if fake.functionDumpReturnsOnCall == nil {
		fake.functionDumpReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.functionDumpReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionFlush(arg1 context.Context) *redisa.StringCmd {
	fake.functionFlushMutex.Lock()
	ret, specificReturn := fake.functionFlushReturnsOnCall[len(fake.functionFlushArgsForCall)]
	fake.functionFlushArgsForCall = append(fake.functionFlushArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.FunctionFlushStub
	fakeReturns := fake.functionFlushReturns
	fake.recordInvocation("FunctionFlush", []interface{}{arg1})
	fake.functionFlushMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FunctionFlushCallCount() int {
	fake.functionFlushMutex.RLock()
	defer fake.functionFlushMutex.RUnlock()
	return len(fake.functionFlushArgsForCall)
}

func (fake *FakeClient) FunctionFlushCalls(stub func(context.Context) *redisa.StringCmd) {
	fake.functionFlushMutex.Lock()
	defer fake.functionFlushMutex.Unlock()
	fake.FunctionFlushStub = stub
}

func (fake *FakeClient) FunctionFlushArgsForCall(i int) context.Context {
	fake.functionFlushMutex.RLock()
	defer fake.functionFlushMutex.RUnlock()
	argsForCall := fake.functionFlushArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) FunctionFlushReturns(result1 *redisa.StringCmd) {
	fake.functionFlushMutex.Lock()
	defer fake.functionFlushMutex.Unlock()
	fake.FunctionFlushStub = nil
	fake.functionFlushReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionFlushReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.functionFlushMutex.Lock()
	defer fake.functionFlushMutex.Unlock()
	fake.FunctionFlushStub = nil
	if fake.functionFlushReturnsOnCall == nil {
		fake.functionFlushReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.functionFlushReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionFlushAsync(arg1 context.Context) *redisa.StringCmd {
	fake.functionFlushAsyncMutex.Lock()
	ret, specificReturn := fake.functionFlushAsyncReturnsOnCall[len(fake.functionFlushAsyncArgsForCall)]
	fake.functionFlushAsyncArgsForCall = append(fake.functionFlushAsyncArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.FunctionFlushAsyncStub
	fakeReturns := fake.functionFlushAsyncReturns
	fake.recordInvocation("FunctionFlushAsync", []interface{}{arg1})
	fake.functionFlushAsyncMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FunctionFlushAsyncCallCount() int {
	fake.functionFlushAsyncMutex.RLock()
	defer fake.functionFlushAsyncMutex.RUnlock()
	return len(fake.functionFlushAsyncArgsForCall)
}

func (fake *FakeClient) FunctionFlushAsyncCalls(stub func(context.Context) *redisa.StringCmd) {
	fake.functionFlushAsyncMutex.Lock()
	defer fake.functionFlushAsyncMutex.Unlock()
	fake.FunctionFlushAsyncStub = stub
}

func (fake *FakeClient) FunctionFlushAsyncArgsForCall(i int) context.Context {
	fake.functionFlushAsyncMutex.RLock()
	defer fake.functionFlushAsyncMutex.RUnlock()
	argsForCall := fake.functionFlushAsyncArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) FunctionFlushAsyncReturns(result1 *redisa.StringCmd) {
	fake.functionFlushAsyncMutex.Lock()
	defer fake.functionFlushAsyncMutex.Unlock()
	fake.FunctionFlushAsyncStub = nil
	fake.functionFlushAsyncReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionFlushAsyncReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.functionFlushAsyncMutex.Lock()
	defer fake.functionFlushAsyncMutex.Unlock()
	fake.FunctionFlushAsyncStub = nil
	if fake.functionFlushAsyncReturnsOnCall == nil {
		fake.functionFlushAsyncReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.functionFlushAsyncReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionKill(arg1 context.Context) *redisa.StringCmd {
	fake.functionKillMutex.Lock()
	ret, specificReturn := fake.functionKillReturnsOnCall[len(fake.functionKillArgsForCall)]
	fake.functionKillArgsForCall = append(fake.functionKillArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.FunctionKillStub
	fakeReturns := fake.functionKillReturns
	fake.recordInvocation("FunctionKill", []interface{}{arg1})
	fake.functionKillMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FunctionKillCallCount() int {
	fake.functionKillMutex.RLock()
	defer fake.functionKillMutex.RUnlock()
	return len(fake.functionKillArgsForCall)
}

func (fake *FakeClient) FunctionKillCalls(stub func(context.Context) *redisa.StringCmd) {
	fake.functionKillMutex.Lock()
	defer fake.functionKillMutex.Unlock()
	fake.FunctionKillStub = stub
}

func (fake *FakeClient) FunctionKillArgsForCall(i int) context.Context {
	fake.functionKillMutex.RLock()
	defer fake.functionKillMutex.RUnlock()
	argsForCall := fake.functionKillArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) FunctionKillReturns(result1 *redisa.StringCmd) {
	fake.functionKillMutex.Lock()
	defer fake.functionKillMutex.Unlock()
	fake.FunctionKillStub = nil
	fake.functionKillReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionKillReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.functionKillMutex.Lock()
	defer fake.functionKillMutex.Unlock()
	fake.FunctionKillStub = nil
	if fake.functionKillReturnsOnCall == nil {
		fake.functionKillReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.functionKillReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionList(arg1 context.Context, arg2 redisa.FunctionListQuery) *redisa.FunctionListCmd {
	fake.functionListMutex.Lock()
	ret, specificReturn := fake.functionListReturnsOnCall[len(fake.functionListArgsForCall)]
	fake.functionListArgsForCall = append(fake.functionListArgsForCall, struct {
		arg1 context.Context
		arg2 redisa.FunctionListQuery
	}{arg1, arg2})
	stub := fake.FunctionListStub
	fakeReturns := fake.functionListReturns
	fake.recordInvocation("FunctionList", []interface{}{arg1, arg2})
	fake.functionListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FunctionListCallCount() int {
	fake.functionListMutex.RLock()
	defer fake.functionListMutex.RUnlock()
	return len(fake.functionListArgsForCall)
}

func (fake *FakeClient) FunctionListCalls(stub func(context.Context, redisa.FunctionListQuery) *redisa.FunctionListCmd) {
	fake.functionListMutex.Lock()
	defer fake.functionListMutex.Unlock()
	fake.FunctionListStub = stub
}

func (fake *FakeClient) FunctionListArgsForCall(i int) (context.Context, redisa.FunctionListQuery) {
	fake.functionListMutex.RLock()
	defer fake.functionListMutex.RUnlock()
	argsForCall := fake.functionListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) FunctionListReturns(result1 *redisa.FunctionListCmd) {
	fake.functionListMutex.Lock()
	defer fake.functionListMutex.Unlock()
	fake.FunctionListStub = nil
	fake.functionListReturns = struct {
		result1 *redisa.FunctionListCmd
	}{result1}
}

func (fake *FakeClient) FunctionListReturnsOnCall(i int, result1 *redisa.FunctionListCmd) {
	fake.functionListMutex.Lock()
	defer fake.functionListMutex.Unlock()
	fake.FunctionListStub = nil
	if fake.functionListReturnsOnCall == nil {
		fake.functionListReturnsOnCall = make(map[int]struct {
			result1 *redisa.FunctionListCmd
		})
	}
	fake.functionListReturnsOnCall[i] = struct {
		result1 *redisa.FunctionListCmd
	}{result1}
}

func (fake *FakeClient) FunctionLoad(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.functionLoadMutex.Lock()
	ret, specificReturn := fake.functionLoadReturnsOnCall[len(fake.functionLoadArgsForCall)]
	fake.functionLoadArgsForCall = append(fake.functionLoadArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FunctionLoadStub
	fakeReturns := fake.functionLoadReturns
	fake.recordInvocation("FunctionLoad", []interface{}{arg1, arg2})
	fake.functionLoadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FunctionLoadCallCount() int {
	fake.functionLoadMutex.RLock()
	defer fake.functionLoadMutex.RUnlock()
	return len(fake.functionLoadArgsForCall)
}

func (fake *FakeClient) FunctionLoadCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.functionLoadMutex.Lock()
	defer fake.functionLoadMutex.Unlock()
	fake.FunctionLoadStub = stub
}

func (fake *FakeClient) FunctionLoadArgsForCall(i int) (context.Context, string) {
	fake.functionLoadMutex.RLock()
	defer fake.functionLoadMutex.RUnlock()
	argsForCall := fake.functionLoadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) FunctionLoadReturns(result1 *redisa.StringCmd) {
	fake.functionLoadMutex.Lock()
	defer fake.functionLoadMutex.Unlock()
	fake.FunctionLoadStub = nil
	fake.functionLoadReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionLoadReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.functionLoadMutex.Lock()
	defer fake.functionLoadMutex.Unlock()
	fake.FunctionLoadStub = nil
	if fake.functionLoadReturnsOnCall == nil {
		fake.functionLoadReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.functionLoadReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionLoadReplace(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.functionLoadReplaceMutex.Lock()
	ret, specificReturn := fake.functionLoadReplaceReturnsOnCall[len(fake.functionLoadReplaceArgsForCall)]
	fake.functionLoadReplaceArgsForCall = append(fake.functionLoadReplaceArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FunctionLoadReplaceStub
	fakeReturns := fake.functionLoadReplaceReturns
	fake.recordInvocation("FunctionLoadReplace", []interface{}{arg1, arg2})
	fake.functionLoadReplaceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FunctionLoadReplaceCallCount() int {
	fake.functionLoadReplaceMutex.RLock()
	defer fake.functionLoadReplaceMutex.RUnlock()
	return len(fake.functionLoadReplaceArgsForCall)
}

func (fake *FakeClient) FunctionLoadReplaceCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.functionLoadReplaceMutex.Lock()
	defer fake.functionLoadReplaceMutex.Unlock()
	fake.FunctionLoadReplaceStub = stub
}

func (fake *FakeClient) FunctionLoadReplaceArgsForCall(i int) (context.Context, string) {
	fake.functionLoadReplaceMutex.RLock()
	defer fake.functionLoadReplaceMutex.RUnlock()
	argsForCall := fake.functionLoadReplaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) FunctionLoadReplaceReturns(result1 *redisa.StringCmd) {
	fake.functionLoadReplaceMutex.Lock()
	defer fake.functionLoadReplaceMutex.Unlock()
	fake.FunctionLoadReplaceStub = nil
	fake.functionLoadReplaceReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionLoadReplaceReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.functionLoadReplaceMutex.Lock()
	defer fake.functionLoadReplaceMutex.Unlock()
	fake.FunctionLoadReplaceStub = nil
	if fake.functionLoadReplaceReturnsOnCall == nil {
		fake.functionLoadReplaceReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.functionLoadReplaceReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionRestore(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.functionRestoreMutex.Lock()
	ret, specificReturn := fake.functionRestoreReturnsOnCall[len(fake.functionRestoreArgsForCall)]
	fake.functionRestoreArgsForCall = append(fake.functionRestoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FunctionRestoreStub
	fakeReturns := fake.functionRestoreReturns
	fake.recordInvocation("FunctionRestore", []interface{}{arg1, arg2})
	fake.functionRestoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FunctionRestoreCallCount() int {
	fake.functionRestoreMutex.RLock()
	defer fake.functionRestoreMutex.RUnlock()
	return len(fake.functionRestoreArgsForCall)
}

func (fake *FakeClient) FunctionRestoreCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.functionRestoreMutex.Lock()
	defer fake.functionRestoreMutex.Unlock()
	fake.FunctionRestoreStub = stub
}

func (fake *FakeClient) FunctionRestoreArgsForCall(i int) (context.Context, string) {
	fake.functionRestoreMutex.RLock()
	defer fake.functionRestoreMutex.RUnlock()
	argsForCall := fake.functionRestoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) FunctionRestoreReturns(result1 *redisa.StringCmd) {
	fake.functionRestoreMutex.Lock()
	defer fake.functionRestoreMutex.Unlock()
	fake.FunctionRestoreStub = nil
	fake.functionRestoreReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionRestoreReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.functionRestoreMutex.Lock()
	defer fake.functionRestoreMutex.Unlock()
	fake.FunctionRestoreStub = nil
	if fake.functionRestoreReturnsOnCall == nil {
		fake.functionRestoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.functionRestoreReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) FunctionStats(arg1 context.Context) *redisa.FunctionStatsCmd {
	fake.functionStatsMutex.Lock()
	ret, specificReturn := fake.functionStatsReturnsOnCall[len(fake.functionStatsArgsForCall)]
	fake.functionStatsArgsForCall = append(fake.functionStatsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.FunctionStatsStub
	fakeReturns := fake.functionStatsReturns
	fake.recordInvocation("FunctionStats", []interface{}{arg1})
	fake.functionStatsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) FunctionStatsCallCount() int {
	fake.functionStatsMutex.RLock()
	defer fake.functionStatsMutex.RUnlock()
	return len(fake.functionStatsArgsForCall)
}

func (fake *FakeClient) FunctionStatsCalls(stub func(context.Context) *redisa.FunctionStatsCmd) {
	fake.functionStatsMutex.Lock()
	defer fake.functionStatsMutex.Unlock()
	fake.FunctionStatsStub = stub
}

func (fake *FakeClient) FunctionStatsArgsForCall(i int) context.Context {
	fake.functionStatsMutex.RLock()
	defer fake.functionStatsMutex.RUnlock()
	argsForCall := fake.functionStatsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) FunctionStatsReturns(result1 *redisa.FunctionStatsCmd) {
	fake.functionStatsMutex.Lock()
	defer fake.functionStatsMutex.Unlock()
	fake.FunctionStatsStub = nil
	fake.functionStatsReturns = struct {
		result1 *redisa.FunctionStatsCmd
	}{result1}
}

func (fake *FakeClient) FunctionStatsReturnsOnCall(i int, result1 *redisa.FunctionStatsCmd) {
	fake.functionStatsMutex.Lock()
	defer fake.functionStatsMutex.Unlock()
	fake.FunctionStatsStub = nil
	if fake.functionStatsReturnsOnCall == nil {
		fake.functionStatsReturnsOnCall = make(map[int]struct {
			result1 *redisa.FunctionStatsCmd
		})
	}
	fake.functionStatsReturnsOnCall[i] = struct {
		result1 *redisa.FunctionStatsCmd
	}{result1}
}

func (fake *FakeClient) GeoAdd(arg1 context.Context, arg2 string, arg3 ...*redisa.GeoLocation) *redisa.IntCmd {
	fake.geoAddMutex.Lock()
	ret, specificReturn := fake.geoAddReturnsOnCall[len(fake.geoAddArgsForCall)]
	fake.geoAddArgsForCall = append(fake.geoAddArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []*redisa.GeoLocation
	}{arg1, arg2, arg3})
	stub := fake.GeoAddStub
	fakeReturns := fake.geoAddReturns
	fake.recordInvocation("GeoAdd", []interface{}{arg1, arg2, arg3})
	fake.geoAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GeoAddCallCount() int {
	fake.geoAddMutex.RLock()
	defer fake.geoAddMutex.RUnlock()
	return len(fake.geoAddArgsForCall)
}

func (fake *FakeClient) GeoAddCalls(stub func(context.Context, string, ...*redisa.GeoLocation) *redisa.IntCmd) {
	fake.geoAddMutex.Lock()
	defer fake.geoAddMutex.Unlock()
	fake.GeoAddStub = stub
}

func (fake *FakeClient) GeoAddArgsForCall(i int) (context.Context, string, []*redisa.GeoLocation) {
	fake.geoAddMutex.RLock()
	defer fake.geoAddMutex.RUnlock()
	argsForCall := fake.geoAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GeoAddReturns(result1 *redisa.IntCmd) {
	fake.geoAddMutex.Lock()
	defer fake.geoAddMutex.Unlock()
	fake.GeoAddStub = nil
	fake.geoAddReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) GeoAddReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.geoAddMutex.Lock()
	defer fake.geoAddMutex.Unlock()
	fake.GeoAddStub = nil
	if fake.geoAddReturnsOnCall == nil {
		fake.geoAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.geoAddReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) GeoDist(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string) *redisa.FloatCmd {
	fake.geoDistMutex.Lock()
	ret, specificReturn := fake.geoDistReturnsOnCall[len(fake.geoDistArgsForCall)]
	fake.geoDistArgsForCall = append(fake.geoDistArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.GeoDistStub
	fakeReturns := fake.geoDistReturns
	fake.recordInvocation("GeoDist", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.geoDistMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GeoDistCallCount() int {
	fake.geoDistMutex.RLock()
	defer fake.geoDistMutex.RUnlock()
	return len(fake.geoDistArgsForCall)
}

func (fake *FakeClient) GeoDistCalls(stub func(context.Context, string, string, string, string) *redisa.FloatCmd) {
	fake.geoDistMutex.Lock()
	defer fake.geoDistMutex.Unlock()
	fake.GeoDistStub = stub
}

func (fake *FakeClient) GeoDistArgsForCall(i int) (context.Context, string, string, string, string) {
	fake.geoDistMutex.RLock()
	defer fake.geoDistMutex.RUnlock()
	argsForCall := fake.geoDistArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) GeoDistReturns(result1 *redisa.FloatCmd) {
	fake.geoDistMutex.Lock()
	defer fake.geoDistMutex.Unlock()
	fake.GeoDistStub = nil
	fake.geoDistReturns = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) GeoDistReturnsOnCall(i int, result1 *redisa.FloatCmd) {
	fake.geoDistMutex.Lock()
	defer fake.geoDistMutex.Unlock()
	fake.GeoDistStub = nil
	if fake.geoDistReturnsOnCall == nil {
		fake.geoDistReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatCmd
		})
	}
	fake.geoDistReturnsOnCall[i] = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) GeoHash(arg1 context.Context, arg2 string, arg3 ...string) *redisa.StringSliceCmd {
	fake.geoHashMutex.Lock()
	ret, specificReturn := fake.geoHashReturnsOnCall[len(fake.geoHashArgsForCall)]
	fake.geoHashArgsForCall = append(fake.geoHashArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.GeoHashStub
	fakeReturns := fake.geoHashReturns
	fake.recordInvocation("GeoHash", []interface{}{arg1, arg2, arg3})
	fake.geoHashMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GeoHashCallCount() int {
	fake.geoHashMutex.RLock()
	defer fake.geoHashMutex.RUnlock()
	return len(fake.geoHashArgsForCall)
}

func (fake *FakeClient) GeoHashCalls(stub func(context.Context, string, ...string) *redisa.StringSliceCmd) {
	fake.geoHashMutex.Lock()
	defer fake.geoHashMutex.Unlock()
	fake.GeoHashStub = stub
}

func (fake *FakeClient) GeoHashArgsForCall(i int) (context.Context, string, []string) {
	fake.geoHashMutex.RLock()
	defer fake.geoHashMutex.RUnlock()
	argsForCall := fake.geoHashArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GeoHashReturns(result1 *redisa.StringSliceCmd) {
	fake.geoHashMutex.Lock()
	defer fake.geoHashMutex.Unlock()
	fake.GeoHashStub = nil
	fake.geoHashReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) GeoHashReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.geoHashMutex.Lock()
	defer fake.geoHashMutex.Unlock()
	fake.GeoHashStub = nil
	if fake.geoHashReturnsOnCall == nil {
		fake.geoHashReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.geoHashReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) GeoPos(arg1 context.Context, arg2 string, arg3 ...string) *redisa.GeoPosCmd {
	fake.geoPosMutex.Lock()
	ret, specificReturn := fake.geoPosReturnsOnCall[len(fake.geoPosArgsForCall)]
	fake.geoPosArgsForCall = append(fake.geoPosArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.GeoPosStub
	fakeReturns := fake.geoPosReturns
	fake.recordInvocation("GeoPos", []interface{}{arg1, arg2, arg3})
	fake.geoPosMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GeoPosCallCount() int {
	fake.geoPosMutex.RLock()
	defer fake.geoPosMutex.RUnlock()
	return len(fake.geoPosArgsForCall)
}

func (fake *FakeClient) GeoPosCalls(stub func(context.Context, string, ...string) *redisa.GeoPosCmd) {
	fake.geoPosMutex.Lock()
	defer fake.geoPosMutex.Unlock()
	fake.GeoPosStub = stub
}

func (fake *FakeClient) GeoPosArgsForCall(i int) (context.Context, string, []string) {
	fake.geoPosMutex.RLock()
	defer fake.geoPosMutex.RUnlock()
	argsForCall := fake.geoPosArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GeoPosReturns(result1 *redisa.GeoPosCmd) {
	fake.geoPosMutex.Lock()
	defer fake.geoPosMutex.Unlock()
	fake.GeoPosStub = nil
	fake.geoPosReturns = struct {
		result1 *redisa.GeoPosCmd
	}{result1}
}

func (fake *FakeClient) GeoPosReturnsOnCall(i int, result1 *redisa.GeoPosCmd) {
	fake.geoPosMutex.Lock()
	defer fake.geoPosMutex.Unlock()
	fake.GeoPosStub = nil
	if fake.geoPosReturnsOnCall == nil {
		fake.geoPosReturnsOnCall = make(map[int]struct {
			result1 *redisa.GeoPosCmd
		})
	}
	fake.geoPosReturnsOnCall[i] = struct {
		result1 *redisa.GeoPosCmd
	}{result1}
}

func (fake *FakeClient) GeoRadius(arg1 context.Context, arg2 string, arg3 float64, arg4 float64, arg5 *redisa.GeoRadiusQuery) *redisa.GeoLocationCmd {
	fake.geoRadiusMutex.Lock()
	ret, specificReturn := fake.geoRadiusReturnsOnCall[len(fake.geoRadiusArgsForCall)]
	fake.geoRadiusArgsForCall = append(fake.geoRadiusArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 float64
		arg5 *redisa.GeoRadiusQuery
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.GeoRadiusStub
	fakeReturns := fake.geoRadiusReturns
	fake.recordInvocation("GeoRadius", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.geoRadiusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GeoRadiusCallCount() int {
	fake.geoRadiusMutex.RLock()
	defer fake.geoRadiusMutex.RUnlock()
	return len(fake.geoRadiusArgsForCall)
}

func (fake *FakeClient) GeoRadiusCalls(stub func(context.Context, string, float64, float64, *redisa.GeoRadiusQuery) *redisa.GeoLocationCmd) {
	fake.geoRadiusMutex.Lock()
	defer fake.geoRadiusMutex.Unlock()
	fake.GeoRadiusStub = stub
}

func (fake *FakeClient) GeoRadiusArgsForCall(i int) (context.Context, string, float64, float64, *redisa.GeoRadiusQuery) {
	fake.geoRadiusMutex.RLock()
	defer fake.geoRadiusMutex.RUnlock()
	argsForCall := fake.geoRadiusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) GeoRadiusReturns(result1 *redisa.GeoLocationCmd) {
	fake.geoRadiusMutex.Lock()
	defer fake.geoRadiusMutex.Unlock()
	fake.GeoRadiusStub = nil
	fake.geoRadiusReturns = struct {
		result1 *redisa.GeoLocationCmd
	}{result1}
}

func (fake *FakeClient) GeoRadiusReturnsOnCall(i int, result1 *redisa.GeoLocationCmd) {
	fake.geoRadiusMutex.Lock()
	defer fake.geoRadiusMutex.Unlock()
	fake.GeoRadiusStub = nil
	if fake.geoRadiusReturnsOnCall == nil {
		fake.geoRadiusReturnsOnCall = make(map[int]struct {
			result1 *redisa.GeoLocationCmd
		})
	}
	fake.geoRadiusReturnsOnCall[i] = struct {
		result1 *redisa.GeoLocationCmd
	}{result1}
}

func (fake *FakeClient) GeoRadiusByMember(arg1 context.Context, arg2 string, arg3 string, arg4 *redisa.GeoRadiusQuery) *redisa.GeoLocationCmd {
	fake.geoRadiusByMemberMutex.Lock()
	ret, specificReturn := fake.geoRadiusByMemberReturnsOnCall[len(fake.geoRadiusByMemberArgsForCall)]
	fake.geoRadiusByMemberArgsForCall = append(fake.geoRadiusByMemberArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.GeoRadiusQuery
	}{arg1, arg2, arg3, arg4})
	stub := fake.GeoRadiusByMemberStub
	fakeReturns := fake.geoRadiusByMemberReturns
	fake.recordInvocation("GeoRadiusByMember", []interface{}{arg1, arg2, arg3, arg4})
	fake.geoRadiusByMemberMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GeoRadiusByMemberCallCount() int {
	fake.geoRadiusByMemberMutex.RLock()
	defer fake.geoRadiusByMemberMutex.RUnlock()
	return len(fake.geoRadiusByMemberArgsForCall)
}

func (fake *FakeClient) GeoRadiusByMemberCalls(stub func(context.Context, string, string, *redisa.GeoRadiusQuery) *redisa.GeoLocationCmd) {
	fake.geoRadiusByMemberMutex.Lock()
	defer fake.geoRadiusByMemberMutex.Unlock()
	fake.GeoRadiusByMemberStub = stub
}

func (fake *FakeClient) GeoRadiusByMemberArgsForCall(i int) (context.Context, string, string, *redisa.GeoRadiusQuery) {
	fake.geoRadiusByMemberMutex.RLock()
	defer fake.geoRadiusByMemberMutex.RUnlock()
	argsForCall := fake.geoRadiusByMemberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) GeoRadiusByMemberReturns(result1 *redisa.GeoLocationCmd) {
	fake.geoRadiusByMemberMutex.Lock()
	defer fake.geoRadiusByMemberMutex.Unlock()
	fake.GeoRadiusByMemberStub = nil
	fake.geoRadiusByMemberReturns = struct {
		result1 *redisa.GeoLocationCmd
	}{result1}
}

func (fake *FakeClient) GeoRadiusByMemberReturnsOnCall(i int, result1 *redisa.GeoLocationCmd) {
	fake.geoRadiusByMemberMutex.Lock()
	defer fake.geoRadiusByMemberMutex.Unlock()
	fake.GeoRadiusByMemberStub = nil
	if fake.geoRadiusByMemberReturnsOnCall == nil {
		fake.geoRadiusByMemberReturnsOnCall = make(map[int]struct {
			result1 *redisa.GeoLocationCmd
		})
	}
	fake.geoRadiusByMemberReturnsOnCall[i] = struct {
		result1 *redisa.GeoLocationCmd
	}{result1}
}

func (fake *FakeClient) GeoRadiusByMemberStore(arg1 context.Context, arg2 string, arg3 string, arg4 *redisa.GeoRadiusQuery) *redisa.IntCmd {
	fake.geoRadiusByMemberStoreMutex.Lock()
	ret, specificReturn := fake.geoRadiusByMemberStoreReturnsOnCall[len(fake.geoRadiusByMemberStoreArgsForCall)]
	fake.geoRadiusByMemberStoreArgsForCall = append(fake.geoRadiusByMemberStoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.GeoRadiusQuery
	}{arg1, arg2, arg3, arg4})
	stub := fake.GeoRadiusByMemberStoreStub
	fakeReturns := fake.geoRadiusByMemberStoreReturns
	fake.recordInvocation("GeoRadiusByMemberStore", []interface{}{arg1, arg2, arg3, arg4})
	fake.geoRadiusByMemberStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GeoRadiusByMemberStoreCallCount() int {
	fake.geoRadiusByMemberStoreMutex.RLock()
	defer fake.geoRadiusByMemberStoreMutex.RUnlock()
	return len(fake.geoRadiusByMemberStoreArgsForCall)
}

func (fake *FakeClient) GeoRadiusByMemberStoreCalls(stub func(context.Context, string, string, *redisa.GeoRadiusQuery) *redisa.IntCmd) {
	fake.geoRadiusByMemberStoreMutex.Lock()
	defer fake.geoRadiusByMemberStoreMutex.Unlock()
	fake.GeoRadiusByMemberStoreStub = stub
}

func (fake *FakeClient) GeoRadiusByMemberStoreArgsForCall(i int) (context.Context, string, string, *redisa.GeoRadiusQuery) {
	fake.geoRadiusByMemberStoreMutex.RLock()
	defer fake.geoRadiusByMemberStoreMutex.RUnlock()
	argsForCall := fake.geoRadiusByMemberStoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) GeoRadiusByMemberStoreReturns(result1 *redisa.IntCmd) {
	fake.geoRadiusByMemberStoreMutex.Lock()
	defer fake.geoRadiusByMemberStoreMutex.Unlock()
	fake.GeoRadiusByMemberStoreStub = nil
	fake.geoRadiusByMemberStoreReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) GeoRadiusByMemberStoreReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.geoRadiusByMemberStoreMutex.Lock()
	defer fake.geoRadiusByMemberStoreMutex.Unlock()
	fake.GeoRadiusByMemberStoreStub = nil
	if fake.geoRadiusByMemberStoreReturnsOnCall == nil {
		fake.geoRadiusByMemberStoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.geoRadiusByMemberStoreReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) GeoRadiusStore(arg1 context.Context, arg2 string, arg3 float64, arg4 float64, arg5 *redisa.GeoRadiusQuery) *redisa.IntCmd {
	fake.geoRadiusStoreMutex.Lock()
	ret, specificReturn := fake.geoRadiusStoreReturnsOnCall[len(fake.geoRadiusStoreArgsForCall)]
	fake.geoRadiusStoreArgsForCall = append(fake.geoRadiusStoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 float64
		arg5 *redisa.GeoRadiusQuery
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.GeoRadiusStoreStub
	fakeReturns := fake.geoRadiusStoreReturns
	fake.recordInvocation("GeoRadiusStore", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.geoRadiusStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GeoRadiusStoreCallCount() int {
	fake.geoRadiusStoreMutex.RLock()
	defer fake.geoRadiusStoreMutex.RUnlock()
	return len(fake.geoRadiusStoreArgsForCall)
}

func (fake *FakeClient) GeoRadiusStoreCalls(stub func(context.Context, string, float64, float64, *redisa.GeoRadiusQuery) *redisa.IntCmd) {
	fake.geoRadiusStoreMutex.Lock()
	defer fake.geoRadiusStoreMutex.Unlock()
	fake.GeoRadiusStoreStub = stub
}

func (fake *FakeClient) GeoRadiusStoreArgsForCall(i int) (context.Context, string, float64, float64, *redisa.GeoRadiusQuery) {
	fake.geoRadiusStoreMutex.RLock()
	defer fake.geoRadiusStoreMutex.RUnlock()
	argsForCall := fake.geoRadiusStoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) GeoRadiusStoreReturns(result1 *redisa.IntCmd) {
	fake.geoRadiusStoreMutex.Lock()
	defer fake.geoRadiusStoreMutex.Unlock()
	fake.GeoRadiusStoreStub = nil
	fake.geoRadiusStoreReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) GeoRadiusStoreReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.geoRadiusStoreMutex.Lock()
	defer fake.geoRadiusStoreMutex.Unlock()
	fake.GeoRadiusStoreStub = nil
	if fake.geoRadiusStoreReturnsOnCall == nil {
		fake.geoRadiusStoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.geoRadiusStoreReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) GeoSearch(arg1 context.Context, arg2 string, arg3 *redisa.GeoSearchQuery) *redisa.StringSliceCmd {
	fake.geoSearchMutex.Lock()
	ret, specificReturn := fake.geoSearchReturnsOnCall[len(fake.geoSearchArgsForCall)]
	fake.geoSearchArgsForCall = append(fake.geoSearchArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.GeoSearchQuery
	}{arg1, arg2, arg3})
	stub := fake.GeoSearchStub
	fakeReturns := fake.geoSearchReturns
	fake.recordInvocation("GeoSearch", []interface{}{arg1, arg2, arg3})
	fake.geoSearchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GeoSearchCallCount() int {
	fake.geoSearchMutex.RLock()
	defer fake.geoSearchMutex.RUnlock()
	return len(fake.geoSearchArgsForCall)
}

func (fake *FakeClient) GeoSearchCalls(stub func(context.Context, string, *redisa.GeoSearchQuery) *redisa.StringSliceCmd) {
	fake.geoSearchMutex.Lock()
	defer fake.geoSearchMutex.Unlock()
	fake.GeoSearchStub = stub
}

func (fake *FakeClient) GeoSearchArgsForCall(i int) (context.Context, string, *redisa.GeoSearchQuery) {
	fake.geoSearchMutex.RLock()
	defer fake.geoSearchMutex.RUnlock()
	argsForCall := fake.geoSearchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GeoSearchReturns(result1 *redisa.StringSliceCmd) {
	fake.geoSearchMutex.Lock()
	defer fake.geoSearchMutex.Unlock()
	fake.GeoSearchStub = nil
	fake.geoSearchReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) GeoSearchReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.geoSearchMutex.Lock()
	defer fake.geoSearchMutex.Unlock()
	fake.GeoSearchStub = nil
	if fake.geoSearchReturnsOnCall == nil {
		fake.geoSearchReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.geoSearchReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) GeoSearchLocation(arg1 context.Context, arg2 string, arg3 *redisa.GeoSearchLocationQuery) *redisa.GeoSearchLocationCmd {
	fake.geoSearchLocationMutex.Lock()
	ret, specificReturn := fake.geoSearchLocationReturnsOnCall[len(fake.geoSearchLocationArgsForCall)]
	fake.geoSearchLocationArgsForCall = append(fake.geoSearchLocationArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.GeoSearchLocationQuery
	}{arg1, arg2, arg3})
	stub := fake.GeoSearchLocationStub
	fakeReturns := fake.geoSearchLocationReturns
	fake.recordInvocation("GeoSearchLocation", []interface{}{arg1, arg2, arg3})
	fake.geoSearchLocationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GeoSearchLocationCallCount() int {
	fake.geoSearchLocationMutex.RLock()
	defer fake.geoSearchLocationMutex.RUnlock()
	return len(fake.geoSearchLocationArgsForCall)
}

func (fake *FakeClient) GeoSearchLocationCalls(stub func(context.Context, string, *redisa.GeoSearchLocationQuery) *redisa.GeoSearchLocationCmd) {
	fake.geoSearchLocationMutex.Lock()
	defer fake.geoSearchLocationMutex.Unlock()
	fake.GeoSearchLocationStub = stub
}

func (fake *FakeClient) GeoSearchLocationArgsForCall(i int) (context.Context, string, *redisa.GeoSearchLocationQuery) {
	fake.geoSearchLocationMutex.RLock()
	defer fake.geoSearchLocationMutex.RUnlock()
	argsForCall := fake.geoSearchLocationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GeoSearchLocationReturns(result1 *redisa.GeoSearchLocationCmd) {
	fake.geoSearchLocationMutex.Lock()
	defer fake.geoSearchLocationMutex.Unlock()
	fake.GeoSearchLocationStub = nil
	fake.geoSearchLocationReturns = struct {
		result1 *redisa.GeoSearchLocationCmd
	}{result1}
}

func (fake *FakeClient) GeoSearchLocationReturnsOnCall(i int, result1 *redisa.GeoSearchLocationCmd) {
	fake.geoSearchLocationMutex.Lock()
	defer fake.geoSearchLocationMutex.Unlock()
	fake.GeoSearchLocationStub = nil
	if fake.geoSearchLocationReturnsOnCall == nil {
		fake.geoSearchLocationReturnsOnCall = make(map[int]struct {
			result1 *redisa.GeoSearchLocationCmd
		})
	}
	fake.geoSearchLocationReturnsOnCall[i] = struct {
		result1 *redisa.GeoSearchLocationCmd
	}{result1}
}

func (fake *FakeClient) GeoSearchStore(arg1 context.Context, arg2 string, arg3 string, arg4 *redisa.GeoSearchStoreQuery) *redisa.IntCmd {
	fake.geoSearchStoreMutex.Lock()
	ret, specificReturn := fake.geoSearchStoreReturnsOnCall[len(fake.geoSearchStoreArgsForCall)]
	fake.geoSearchStoreArgsForCall = append(fake.geoSearchStoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.GeoSearchStoreQuery
	}{arg1, arg2, arg3, arg4})
	stub := fake.GeoSearchStoreStub
	fakeReturns := fake.geoSearchStoreReturns
	fake.recordInvocation("GeoSearchStore", []interface{}{arg1, arg2, arg3, arg4})
	fake.geoSearchStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GeoSearchStoreCallCount() int {
	fake.geoSearchStoreMutex.RLock()
	defer fake.geoSearchStoreMutex.RUnlock()
	return len(fake.geoSearchStoreArgsForCall)
}

func (fake *FakeClient) GeoSearchStoreCalls(stub func(context.Context, string, string, *redisa.GeoSearchStoreQuery) *redisa.IntCmd) {
	fake.geoSearchStoreMutex.Lock()
	defer fake.geoSearchStoreMutex.Unlock()
	fake.GeoSearchStoreStub = stub
}

func (fake *FakeClient) GeoSearchStoreArgsForCall(i int) (context.Context, string, string, *redisa.GeoSearchStoreQuery) {
	fake.geoSearchStoreMutex.RLock()
	defer fake.geoSearchStoreMutex.RUnlock()
	argsForCall := fake.geoSearchStoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) GeoSearchStoreReturns(result1 *redisa.IntCmd) {
	fake.geoSearchStoreMutex.Lock()
	defer fake.geoSearchStoreMutex.Unlock()
	fake.GeoSearchStoreStub = nil
	fake.geoSearchStoreReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) GeoSearchStoreReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.geoSearchStoreMutex.Lock()
	defer fake.geoSearchStoreMutex.Unlock()
	fake.GeoSearchStoreStub = nil
	if fake.geoSearchStoreReturnsOnCall == nil {
		fake.geoSearchStoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.geoSearchStoreReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) Get(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1, arg2})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeClient) GetCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeClient) GetArgsForCall(i int) (context.Context, string) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetReturns(result1 *redisa.StringCmd) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) GetReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) GetBit(arg1 context.Context, arg2 string, arg3 int64) *redisa.IntCmd {
	fake.getBitMutex.Lock()
	ret, specificReturn := fake.getBitReturnsOnCall[len(fake.getBitArgsForCall)]
	fake.getBitArgsForCall = append(fake.getBitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.GetBitStub
	fakeReturns := fake.getBitReturns
	fake.recordInvocation("GetBit", []interface{}{arg1, arg2, arg3})
	fake.getBitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GetBitCallCount() int {
	fake.getBitMutex.RLock()
	defer fake.getBitMutex.RUnlock()
	return len(fake.getBitArgsForCall)
}

func (fake *FakeClient) GetBitCalls(stub func(context.Context, string, int64) *redisa.IntCmd) {
	fake.getBitMutex.Lock()
	defer fake.getBitMutex.Unlock()
	fake.GetBitStub = stub
}

func (fake *FakeClient) GetBitArgsForCall(i int) (context.Context, string, int64) {
	fake.getBitMutex.RLock()
	defer fake.getBitMutex.RUnlock()
	argsForCall := fake.getBitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GetBitReturns(result1 *redisa.IntCmd) {
	fake.getBitMutex.Lock()
	defer fake.getBitMutex.Unlock()
	fake.GetBitStub = nil
	fake.getBitReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) GetBitReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.getBitMutex.Lock()
	defer fake.getBitMutex.Unlock()
	fake.GetBitStub = nil
	if fake.getBitReturnsOnCall == nil {
		fake.getBitReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.getBitReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) GetDel(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.getDelMutex.Lock()
	ret, specificReturn := fake.getDelReturnsOnCall[len(fake.getDelArgsForCall)]
	fake.getDelArgsForCall = append(fake.getDelArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetDelStub
	fakeReturns := fake.getDelReturns
	fake.recordInvocation("GetDel", []interface{}{arg1, arg2})
	fake.getDelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GetDelCallCount() int {
	fake.getDelMutex.RLock()
	defer fake.getDelMutex.RUnlock()
	return len(fake.getDelArgsForCall)
}

func (fake *FakeClient) GetDelCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.getDelMutex.Lock()
	defer fake.getDelMutex.Unlock()
	fake.GetDelStub = stub
}

func (fake *FakeClient) GetDelArgsForCall(i int) (context.Context, string) {
	fake.getDelMutex.RLock()
	defer fake.getDelMutex.RUnlock()
	argsForCall := fake.getDelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetDelReturns(result1 *redisa.StringCmd) {
	fake.getDelMutex.Lock()
	defer fake.getDelMutex.Unlock()
	fake.GetDelStub = nil
	fake.getDelReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) GetDelReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.getDelMutex.Lock()
	defer fake.getDelMutex.Unlock()
	fake.GetDelStub = nil
	if fake.getDelReturnsOnCall == nil {
		fake.getDelReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.getDelReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) GetEx(arg1 context.Context, arg2 string, arg3 time.Duration) *redisa.StringCmd {
	fake.getExMutex.Lock()
	ret, specificReturn := fake.getExReturnsOnCall[len(fake.getExArgsForCall)]
	fake.getExArgsForCall = append(fake.getExArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}{arg1, arg2, arg3})
	stub := fake.GetExStub
	fakeReturns := fake.getExReturns
	fake.recordInvocation("GetEx", []interface{}{arg1, arg2, arg3})
	fake.getExMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GetExCallCount() int {
	fake.getExMutex.RLock()
	defer fake.getExMutex.RUnlock()
	return len(fake.getExArgsForCall)
}

func (fake *FakeClient) GetExCalls(stub func(context.Context, string, time.Duration) *redisa.StringCmd) {
	fake.getExMutex.Lock()
	defer fake.getExMutex.Unlock()
	fake.GetExStub = stub
}

func (fake *FakeClient) GetExArgsForCall(i int) (context.Context, string, time.Duration) {
	fake.getExMutex.RLock()
	defer fake.getExMutex.RUnlock()
	argsForCall := fake.getExArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GetExReturns(result1 *redisa.StringCmd) {
	fake.getExMutex.Lock()
	defer fake.getExMutex.Unlock()
	fake.GetExStub = nil
	fake.getExReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) GetExReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.getExMutex.Lock()
	defer fake.getExMutex.Unlock()
	fake.GetExStub = nil
	if fake.getExReturnsOnCall == nil {
		fake.getExReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.getExReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) GetRange(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) *redisa.StringCmd {
	fake.getRangeMutex.Lock()
	ret, specificReturn := fake.getRangeReturnsOnCall[len(fake.getRangeArgsForCall)]
	fake.getRangeArgsForCall = append(fake.getRangeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetRangeStub
	fakeReturns := fake.getRangeReturns
	fake.recordInvocation("GetRange", []interface{}{arg1, arg2, arg3, arg4})
	fake.getRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GetRangeCallCount() int {
	fake.getRangeMutex.RLock()
	defer fake.getRangeMutex.RUnlock()
	return len(fake.getRangeArgsForCall)
}

func (fake *FakeClient) GetRangeCalls(stub func(context.Context, string, int64, int64) *redisa.StringCmd) {
	fake.getRangeMutex.Lock()
	defer fake.getRangeMutex.Unlock()
	fake.GetRangeStub = stub
}

func (fake *FakeClient) GetRangeArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.getRangeMutex.RLock()
	defer fake.getRangeMutex.RUnlock()
	argsForCall := fake.getRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) GetRangeReturns(result1 *redisa.StringCmd) {
	fake.getRangeMutex.Lock()
	defer fake.getRangeMutex.Unlock()
	fake.GetRangeStub = nil
	fake.getRangeReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) GetRangeReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.getRangeMutex.Lock()
	defer fake.getRangeMutex.Unlock()
	fake.GetRangeStub = nil
	if fake.getRangeReturnsOnCall == nil {
		fake.getRangeReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.getRangeReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) GetSet(arg1 context.Context, arg2 string, arg3 interface{}) *redisa.StringCmd {
	fake.getSetMutex.Lock()
	ret, specificReturn := fake.getSetReturnsOnCall[len(fake.getSetArgsForCall)]
	fake.getSetArgsForCall = append(fake.getSetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.GetSetStub
	fakeReturns := fake.getSetReturns
	fake.recordInvocation("GetSet", []interface{}{arg1, arg2, arg3})
	fake.getSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GetSetCallCount() int {
	fake.getSetMutex.RLock()
	defer fake.getSetMutex.RUnlock()
	return len(fake.getSetArgsForCall)
}

func (fake *FakeClient) GetSetCalls(stub func(context.Context, string, interface{}) *redisa.StringCmd) {
	fake.getSetMutex.Lock()
	defer fake.getSetMutex.Unlock()
	fake.GetSetStub = stub
}

func (fake *FakeClient) GetSetArgsForCall(i int) (context.Context, string, interface{}) {
	fake.getSetMutex.RLock()
	defer fake.getSetMutex.RUnlock()
	argsForCall := fake.getSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GetSetReturns(result1 *redisa.StringCmd) {
	fake.getSetMutex.Lock()
	defer fake.getSetMutex.Unlock()
	fake.GetSetStub = nil
	fake.getSetReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) GetSetReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.getSetMutex.Lock()
	defer fake.getSetMutex.Unlock()
	fake.GetSetStub = nil
	if fake.getSetReturnsOnCall == nil {
		fake.getSetReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.getSetReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) HDel(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntCmd {
	fake.hDelMutex.Lock()
	ret, specificReturn := fake.hDelReturnsOnCall[len(fake.hDelArgsForCall)]
	fake.hDelArgsForCall = append(fake.hDelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.HDelStub
	fakeReturns := fake.hDelReturns
	fake.recordInvocation("HDel", []interface{}{arg1, arg2, arg3})
	fake.hDelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HDelCallCount() int {
	fake.hDelMutex.RLock()
	defer fake.hDelMutex.RUnlock()
	return len(fake.hDelArgsForCall)
}

func (fake *FakeClient) HDelCalls(stub func(context.Context, string, ...string) *redisa.IntCmd) {
	fake.hDelMutex.Lock()
	defer fake.hDelMutex.Unlock()
	fake.HDelStub = stub
}

func (fake *FakeClient) HDelArgsForCall(i int) (context.Context, string, []string) {
	fake.hDelMutex.RLock()
	defer fake.hDelMutex.RUnlock()
	argsForCall := fake.hDelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) HDelReturns(result1 *redisa.IntCmd) {
	fake.hDelMutex.Lock()
	defer fake.hDelMutex.Unlock()
	fake.HDelStub = nil
	fake.hDelReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) HDelReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.hDelMutex.Lock()
	defer fake.hDelMutex.Unlock()
	fake.HDelStub = nil
	if fake.hDelReturnsOnCall == nil {
		fake.hDelReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.hDelReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) HExists(arg1 context.Context, arg2 string, arg3 string) *redisa.BoolCmd {
	fake.hExistsMutex.Lock()
	ret, specificReturn := fake.hExistsReturnsOnCall[len(fake.hExistsArgsForCall)]
	fake.hExistsArgsForCall = append(fake.hExistsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.HExistsStub
	fakeReturns := fake.hExistsReturns
	fake.recordInvocation("HExists", []interface{}{arg1, arg2, arg3})
	fake.hExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HExistsCallCount() int {
	fake.hExistsMutex.RLock()
	defer fake.hExistsMutex.RUnlock()
	return len(fake.hExistsArgsForCall)
}

func (fake *FakeClient) HExistsCalls(stub func(context.Context, string, string) *redisa.BoolCmd) {
	fake.hExistsMutex.Lock()
	defer fake.hExistsMutex.Unlock()
	fake.HExistsStub = stub
}

func (fake *FakeClient) HExistsArgsForCall(i int) (context.Context, string, string) {
	fake.hExistsMutex.RLock()
	defer fake.hExistsMutex.RUnlock()
	argsForCall := fake.hExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) HExistsReturns(result1 *redisa.BoolCmd) {
	fake.hExistsMutex.Lock()
	defer fake.hExistsMutex.Unlock()
	fake.HExistsStub = nil
	fake.hExistsReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) HExistsReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.hExistsMutex.Lock()
	defer fake.hExistsMutex.Unlock()
	fake.HExistsStub = nil
	if fake.hExistsReturnsOnCall == nil {
		fake.hExistsReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.hExistsReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) HExpire(arg1 context.Context, arg2 string, arg3 time.Duration, arg4 ...string) *redisa.IntSliceCmd {
	fake.hExpireMutex.Lock()
	ret, specificReturn := fake.hExpireReturnsOnCall[len(fake.hExpireArgsForCall)]
	fake.hExpireArgsForCall = append(fake.hExpireArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
		arg4 []string
	}{arg1, arg2, arg3, arg4})
	stub := fake.HExpireStub
	fakeReturns := fake.hExpireReturns
	fake.recordInvocation("HExpire", []interface{}{arg1, arg2, arg3, arg4})
	fake.hExpireMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HExpireCallCount() int {
	fake.hExpireMutex.RLock()
	defer fake.hExpireMutex.RUnlock()
	return len(fake.hExpireArgsForCall)
}

func (fake *FakeClient) HExpireCalls(stub func(context.Context, string, time.Duration, ...string) *redisa.IntSliceCmd) {
	fake.hExpireMutex.Lock()
	defer fake.hExpireMutex.Unlock()
	fake.HExpireStub = stub
}

func (fake *FakeClient) HExpireArgsForCall(i int) (context.Context, string, time.Duration, []string) {
	fake.hExpireMutex.RLock()
	defer fake.hExpireMutex.RUnlock()
	argsForCall := fake.hExpireArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) HExpireReturns(result1 *redisa.IntSliceCmd) {
	fake.hExpireMutex.Lock()
	defer fake.hExpireMutex.Unlock()
	fake.HExpireStub = nil
	fake.hExpireReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HExpireReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.hExpireMutex.Lock()
	defer fake.hExpireMutex.Unlock()
	fake.HExpireStub = nil
	if fake.hExpireReturnsOnCall == nil {
		fake.hExpireReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.hExpireReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HExpireAt(arg1 context.Context, arg2 string, arg3 time.Time, arg4 ...string) *redisa.IntSliceCmd {
	fake.hExpireAtMutex.Lock()
	ret, specificReturn := fake.hExpireAtReturnsOnCall[len(fake.hExpireAtArgsForCall)]
	fake.hExpireAtArgsForCall = append(fake.hExpireAtArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Time
		arg4 []string
	}{arg1, arg2, arg3, arg4})
	stub := fake.HExpireAtStub
	fakeReturns := fake.hExpireAtReturns
	fake.recordInvocation("HExpireAt", []interface{}{arg1, arg2, arg3, arg4})
	fake.hExpireAtMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HExpireAtCallCount() int {
	fake.hExpireAtMutex.RLock()
	defer fake.hExpireAtMutex.RUnlock()
	return len(fake.hExpireAtArgsForCall)
}

func (fake *FakeClient) HExpireAtCalls(stub func(context.Context, string, time.Time, ...string) *redisa.IntSliceCmd) {
	fake.hExpireAtMutex.Lock()
	defer fake.hExpireAtMutex.Unlock()
	fake.HExpireAtStub = stub
}

func (fake *FakeClient) HExpireAtArgsForCall(i int) (context.Context, string, time.Time, []string) {
	fake.hExpireAtMutex.RLock()
	defer fake.hExpireAtMutex.RUnlock()
	argsForCall := fake.hExpireAtArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) HExpireAtReturns(result1 *redisa.IntSliceCmd) {
	fake.hExpireAtMutex.Lock()
	defer fake.hExpireAtMutex.Unlock()
	fake.HExpireAtStub = nil
	fake.hExpireAtReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HExpireAtReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.hExpireAtMutex.Lock()
	defer fake.hExpireAtMutex.Unlock()
	fake.HExpireAtStub = nil
	if fake.hExpireAtReturnsOnCall == nil {
		fake.hExpireAtReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.hExpireAtReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HExpireAtWithArgs(arg1 context.Context, arg2 string, arg3 time.Time, arg4 redisa.HExpireArgs, arg5 ...string) *redisa.IntSliceCmd {
	fake.hExpireAtWithArgsMutex.Lock()
	ret, specificReturn := fake.hExpireAtWithArgsReturnsOnCall[len(fake.hExpireAtWithArgsArgsForCall)]
	fake.hExpireAtWithArgsArgsForCall = append(fake.hExpireAtWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Time
		arg4 redisa.HExpireArgs
		arg5 []string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.HExpireAtWithArgsStub
	fakeReturns := fake.hExpireAtWithArgsReturns
	fake.recordInvocation("HExpireAtWithArgs", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.hExpireAtWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HExpireAtWithArgsCallCount() int {
	fake.hExpireAtWithArgsMutex.RLock()
	defer fake.hExpireAtWithArgsMutex.RUnlock()
	return len(fake.hExpireAtWithArgsArgsForCall)
}

func (fake *FakeClient) HExpireAtWithArgsCalls(stub func(context.Context, string, time.Time, redisa.HExpireArgs, ...string) *redisa.IntSliceCmd) {
	fake.hExpireAtWithArgsMutex.Lock()
	defer fake.hExpireAtWithArgsMutex.Unlock()
	fake.HExpireAtWithArgsStub = stub
}

func (fake *FakeClient) HExpireAtWithArgsArgsForCall(i int) (context.Context, string, time.Time, redisa.HExpireArgs, []string) {
	fake.hExpireAtWithArgsMutex.RLock()
	defer fake.hExpireAtWithArgsMutex.RUnlock()
	argsForCall := fake.hExpireAtWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) HExpireAtWithArgsReturns(result1 *redisa.IntSliceCmd) {
	fake.hExpireAtWithArgsMutex.Lock()
	defer fake.hExpireAtWithArgsMutex.Unlock()
	fake.HExpireAtWithArgsStub = nil
	fake.hExpireAtWithArgsReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HExpireAtWithArgsReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.hExpireAtWithArgsMutex.Lock()
	defer fake.hExpireAtWithArgsMutex.Unlock()
	fake.HExpireAtWithArgsStub = nil
	if fake.hExpireAtWithArgsReturnsOnCall == nil {
		fake.hExpireAtWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.hExpireAtWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HExpireTime(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntSliceCmd {
	fake.hExpireTimeMutex.Lock()
	ret, specificReturn := fake.hExpireTimeReturnsOnCall[len(fake.hExpireTimeArgsForCall)]
	fake.hExpireTimeArgsForCall = append(fake.hExpireTimeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.HExpireTimeStub
	fakeReturns := fake.hExpireTimeReturns
	fake.recordInvocation("HExpireTime", []interface{}{arg1, arg2, arg3})
	fake.hExpireTimeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HExpireTimeCallCount() int {
	fake.hExpireTimeMutex.RLock()
	defer fake.hExpireTimeMutex.RUnlock()
	return len(fake.hExpireTimeArgsForCall)
}

func (fake *FakeClient) HExpireTimeCalls(stub func(context.Context, string, ...string) *redisa.IntSliceCmd) {
	fake.hExpireTimeMutex.Lock()
	defer fake.hExpireTimeMutex.Unlock()
	fake.HExpireTimeStub = stub
}

func (fake *FakeClient) HExpireTimeArgsForCall(i int) (context.Context, string, []string) {
	fake.hExpireTimeMutex.RLock()
	defer fake.hExpireTimeMutex.RUnlock()
	argsForCall := fake.hExpireTimeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) HExpireTimeReturns(result1 *redisa.IntSliceCmd) {
	fake.hExpireTimeMutex.Lock()
	defer fake.hExpireTimeMutex.Unlock()
	fake.HExpireTimeStub = nil
	fake.hExpireTimeReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HExpireTimeReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.hExpireTimeMutex.Lock()
	defer fake.hExpireTimeMutex.Unlock()
	fake.HExpireTimeStub = nil
	if fake.hExpireTimeReturnsOnCall == nil {
		fake.hExpireTimeReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.hExpireTimeReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HExpireWithArgs(arg1 context.Context, arg2 string, arg3 time.Duration, arg4 redisa.HExpireArgs, arg5 ...string) *redisa.IntSliceCmd {
	fake.hExpireWithArgsMutex.Lock()
	ret, specificReturn := fake.hExpireWithArgsReturnsOnCall[len(fake.hExpireWithArgsArgsForCall)]
	fake.hExpireWithArgsArgsForCall = append(fake.hExpireWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
		arg4 redisa.HExpireArgs
		arg5 []string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.HExpireWithArgsStub
	fakeReturns := fake.hExpireWithArgsReturns
	fake.recordInvocation("HExpireWithArgs", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.hExpireWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HExpireWithArgsCallCount() int {
	fake.hExpireWithArgsMutex.RLock()
	defer fake.hExpireWithArgsMutex.RUnlock()
	return len(fake.hExpireWithArgsArgsForCall)
}

func (fake *FakeClient) HExpireWithArgsCalls(stub func(context.Context, string, time.Duration, redisa.HExpireArgs, ...string) *redisa.IntSliceCmd) {
	fake.hExpireWithArgsMutex.Lock()
	defer fake.hExpireWithArgsMutex.Unlock()
	fake.HExpireWithArgsStub = stub
}

func (fake *FakeClient) HExpireWithArgsArgsForCall(i int) (context.Context, string, time.Duration, redisa.HExpireArgs, []string) {
	fake.hExpireWithArgsMutex.RLock()
	defer fake.hExpireWithArgsMutex.RUnlock()
	argsForCall := fake.hExpireWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) HExpireWithArgsReturns(result1 *redisa.IntSliceCmd) {
	fake.hExpireWithArgsMutex.Lock()
	defer fake.hExpireWithArgsMutex.Unlock()
	fake.HExpireWithArgsStub = nil
	fake.hExpireWithArgsReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HExpireWithArgsReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.hExpireWithArgsMutex.Lock()
	defer fake.hExpireWithArgsMutex.Unlock()
	fake.HExpireWithArgsStub = nil
	if fake.hExpireWithArgsReturnsOnCall == nil {
		fake.hExpireWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.hExpireWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HGet(arg1 context.Context, arg2 string, arg3 string) *redisa.StringCmd {
	fake.hGetMutex.Lock()
	ret, specificReturn := fake.hGetReturnsOnCall[len(fake.hGetArgsForCall)]
	fake.hGetArgsForCall = append(fake.hGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.HGetStub
	fakeReturns := fake.hGetReturns
	fake.recordInvocation("HGet", []interface{}{arg1, arg2, arg3})
	fake.hGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HGetCallCount() int {
	fake.hGetMutex.RLock()
	defer fake.hGetMutex.RUnlock()
	return len(fake.hGetArgsForCall)
}

func (fake *FakeClient) HGetCalls(stub func(context.Context, string, string) *redisa.StringCmd) {
	fake.hGetMutex.Lock()
	defer fake.hGetMutex.Unlock()
	fake.HGetStub = stub
}

func (fake *FakeClient) HGetArgsForCall(i int) (context.Context, string, string) {
	fake.hGetMutex.RLock()
	defer fake.hGetMutex.RUnlock()
	argsForCall := fake.hGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) HGetReturns(result1 *redisa.StringCmd) {
	fake.hGetMutex.Lock()
	defer fake.hGetMutex.Unlock()
	fake.HGetStub = nil
	fake.hGetReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) HGetReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.hGetMutex.Lock()
	defer fake.hGetMutex.Unlock()
	fake.HGetStub = nil
	if fake.hGetReturnsOnCall == nil {
		fake.hGetReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.hGetReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) HGetAll(arg1 context.Context, arg2 string) *redisa.MapStringStringCmd {
	fake.hGetAllMutex.Lock()
	ret, specificReturn := fake.hGetAllReturnsOnCall[len(fake.hGetAllArgsForCall)]
	fake.hGetAllArgsForCall = append(fake.hGetAllArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.HGetAllStub
	fakeReturns := fake.hGetAllReturns
	fake.recordInvocation("HGetAll", []interface{}{arg1, arg2})
	fake.hGetAllMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HGetAllCallCount() int {
	fake.hGetAllMutex.RLock()
	defer fake.hGetAllMutex.RUnlock()
	return len(fake.hGetAllArgsForCall)
}

func (fake *FakeClient) HGetAllCalls(stub func(context.Context, string) *redisa.MapStringStringCmd) {
	fake.hGetAllMutex.Lock()
	defer fake.hGetAllMutex.Unlock()
	fake.HGetAllStub = stub
}

func (fake *FakeClient) HGetAllArgsForCall(i int) (context.Context, string) {
	fake.hGetAllMutex.RLock()
	defer fake.hGetAllMutex.RUnlock()
	argsForCall := fake.hGetAllArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) HGetAllReturns(result1 *redisa.MapStringStringCmd) {
	fake.hGetAllMutex.Lock()
	defer fake.hGetAllMutex.Unlock()
	fake.HGetAllStub = nil
	fake.hGetAllReturns = struct {
		result1 *redisa.MapStringStringCmd
	}{result1}
}

func (fake *FakeClient) HGetAllReturnsOnCall(i int, result1 *redisa.MapStringStringCmd) {
	fake.hGetAllMutex.Lock()
	defer fake.hGetAllMutex.Unlock()
	fake.HGetAllStub = nil
	if fake.hGetAllReturnsOnCall == nil {
		fake.hGetAllReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringStringCmd
		})
	}
	fake.hGetAllReturnsOnCall[i] = struct {
		result1 *redisa.MapStringStringCmd
	}{result1}
}

func (fake *FakeClient) HIncrBy(arg1 context.Context, arg2 string, arg3 string, arg4 int64) *redisa.IntCmd {
	fake.hIncrByMutex.Lock()
	ret, specificReturn := fake.hIncrByReturnsOnCall[len(fake.hIncrByArgsForCall)]
	fake.hIncrByArgsForCall = append(fake.hIncrByArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.HIncrByStub
	fakeReturns := fake.hIncrByReturns
	fake.recordInvocation("HIncrBy", []interface{}{arg1, arg2, arg3, arg4})
	fake.hIncrByMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HIncrByCallCount() int {
	fake.hIncrByMutex.RLock()
	defer fake.hIncrByMutex.RUnlock()
	return len(fake.hIncrByArgsForCall)
}

func (fake *FakeClient) HIncrByCalls(stub func(context.Context, string, string, int64) *redisa.IntCmd) {
	fake.hIncrByMutex.Lock()
	defer fake.hIncrByMutex.Unlock()
	fake.HIncrByStub = stub
}

func (fake *FakeClient) HIncrByArgsForCall(i int) (context.Context, string, string, int64) {
	fake.hIncrByMutex.RLock()
	defer fake.hIncrByMutex.RUnlock()
	argsForCall := fake.hIncrByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) HIncrByReturns(result1 *redisa.IntCmd) {
	fake.hIncrByMutex.Lock()
	defer fake.hIncrByMutex.Unlock()
	fake.HIncrByStub = nil
	fake.hIncrByReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) HIncrByReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.hIncrByMutex.Lock()
	defer fake.hIncrByMutex.Unlock()
	fake.HIncrByStub = nil
	if fake.hIncrByReturnsOnCall == nil {
		fake.hIncrByReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.hIncrByReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) HIncrByFloat(arg1 context.Context, arg2 string, arg3 string, arg4 float64) *redisa.FloatCmd {
	fake.hIncrByFloatMutex.Lock()
	ret, specificReturn := fake.hIncrByFloatReturnsOnCall[len(fake.hIncrByFloatArgsForCall)]
	fake.hIncrByFloatArgsForCall = append(fake.hIncrByFloatArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 float64
	}{arg1, arg2, arg3, arg4})
	stub := fake.HIncrByFloatStub
	fakeReturns := fake.hIncrByFloatReturns
	fake.recordInvocation("HIncrByFloat", []interface{}{arg1, arg2, arg3, arg4})
	fake.hIncrByFloatMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HIncrByFloatCallCount() int {
	fake.hIncrByFloatMutex.RLock()
	defer fake.hIncrByFloatMutex.RUnlock()
	return len(fake.hIncrByFloatArgsForCall)
}

func (fake *FakeClient) HIncrByFloatCalls(stub func(context.Context, string, string, float64) *redisa.FloatCmd) {
	fake.hIncrByFloatMutex.Lock()
	defer fake.hIncrByFloatMutex.Unlock()
	fake.HIncrByFloatStub = stub
}

func (fake *FakeClient) HIncrByFloatArgsForCall(i int) (context.Context, string, string, float64) {
	fake.hIncrByFloatMutex.RLock()
	defer fake.hIncrByFloatMutex.RUnlock()
	argsForCall := fake.hIncrByFloatArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) HIncrByFloatReturns(result1 *redisa.FloatCmd) {
	fake.hIncrByFloatMutex.Lock()
	defer fake.hIncrByFloatMutex.Unlock()
	fake.HIncrByFloatStub = nil
	fake.hIncrByFloatReturns = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) HIncrByFloatReturnsOnCall(i int, result1 *redisa.FloatCmd) {
	fake.hIncrByFloatMutex.Lock()
	defer fake.hIncrByFloatMutex.Unlock()
	fake.HIncrByFloatStub = nil
	if fake.hIncrByFloatReturnsOnCall == nil {
		fake.hIncrByFloatReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatCmd
		})
	}
	fake.hIncrByFloatReturnsOnCall[i] = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) HKeys(arg1 context.Context, arg2 string) *redisa.StringSliceCmd {
	fake.hKeysMutex.Lock()
	ret, specificReturn := fake.hKeysReturnsOnCall[len(fake.hKeysArgsForCall)]
	fake.hKeysArgsForCall = append(fake.hKeysArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.HKeysStub
	fakeReturns := fake.hKeysReturns
	fake.recordInvocation("HKeys", []interface{}{arg1, arg2})
	fake.hKeysMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HKeysCallCount() int {
	fake.hKeysMutex.RLock()
	defer fake.hKeysMutex.RUnlock()
	return len(fake.hKeysArgsForCall)
}

func (fake *FakeClient) HKeysCalls(stub func(context.Context, string) *redisa.StringSliceCmd) {
	fake.hKeysMutex.Lock()
	defer fake.hKeysMutex.Unlock()
	fake.HKeysStub = stub
}

func (fake *FakeClient) HKeysArgsForCall(i int) (context.Context, string) {
	fake.hKeysMutex.RLock()
	defer fake.hKeysMutex.RUnlock()
	argsForCall := fake.hKeysArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) HKeysReturns(result1 *redisa.StringSliceCmd) {
	fake.hKeysMutex.Lock()
	defer fake.hKeysMutex.Unlock()
	fake.HKeysStub = nil
	fake.hKeysReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) HKeysReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.hKeysMutex.Lock()
	defer fake.hKeysMutex.Unlock()
	fake.HKeysStub = nil
	if fake.hKeysReturnsOnCall == nil {
		fake.hKeysReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.hKeysReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) HLen(arg1 context.Context, arg2 string) *redisa.IntCmd {
	fake.hLenMutex.Lock()
	ret, specificReturn := fake.hLenReturnsOnCall[len(fake.hLenArgsForCall)]
	fake.hLenArgsForCall = append(fake.hLenArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.HLenStub
	fakeReturns := fake.hLenReturns
	fake.recordInvocation("HLen", []interface{}{arg1, arg2})
	fake.hLenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HLenCallCount() int {
	fake.hLenMutex.RLock()
	defer fake.hLenMutex.RUnlock()
	return len(fake.hLenArgsForCall)
}

func (fake *FakeClient) HLenCalls(stub func(context.Context, string) *redisa.IntCmd) {
	fake.hLenMutex.Lock()
	defer fake.hLenMutex.Unlock()
	fake.HLenStub = stub
}

func (fake *FakeClient) HLenArgsForCall(i int) (context.Context, string) {
	fake.hLenMutex.RLock()
	defer fake.hLenMutex.RUnlock()
	argsForCall := fake.hLenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) HLenReturns(result1 *redisa.IntCmd) {
	fake.hLenMutex.Lock()
	defer fake.hLenMutex.Unlock()
	fake.HLenStub = nil
	fake.hLenReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) HLenReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.hLenMutex.Lock()
	defer fake.hLenMutex.Unlock()
	fake.HLenStub = nil
	if fake.hLenReturnsOnCall == nil {
		fake.hLenReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.hLenReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) HMGet(arg1 context.Context, arg2 string, arg3 ...string) *redisa.SliceCmd {
	fake.hMGetMutex.Lock()
	ret, specificReturn := fake.hMGetReturnsOnCall[len(fake.hMGetArgsForCall)]
	fake.hMGetArgsForCall = append(fake.hMGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.HMGetStub
	fakeReturns := fake.hMGetReturns
	fake.recordInvocation("HMGet", []interface{}{arg1, arg2, arg3})
	fake.hMGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HMGetCallCount() int {
	fake.hMGetMutex.RLock()
	defer fake.hMGetMutex.RUnlock()
	return len(fake.hMGetArgsForCall)
}

func (fake *FakeClient) HMGetCalls(stub func(context.Context, string, ...string) *redisa.SliceCmd) {
	fake.hMGetMutex.Lock()
	defer fake.hMGetMutex.Unlock()
	fake.HMGetStub = stub
}

func (fake *FakeClient) HMGetArgsForCall(i int) (context.Context, string, []string) {
	fake.hMGetMutex.RLock()
	defer fake.hMGetMutex.RUnlock()
	argsForCall := fake.hMGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) HMGetReturns(result1 *redisa.SliceCmd) {
	fake.hMGetMutex.Lock()
	defer fake.hMGetMutex.Unlock()
	fake.HMGetStub = nil
	fake.hMGetReturns = struct {
		result1 *redisa.SliceCmd
	}{result1}
}

func (fake *FakeClient) HMGetReturnsOnCall(i int, result1 *redisa.SliceCmd) {
	fake.hMGetMutex.Lock()
	defer fake.hMGetMutex.Unlock()
	fake.HMGetStub = nil
	if fake.hMGetReturnsOnCall == nil {
		fake.hMGetReturnsOnCall = make(map[int]struct {
			result1 *redisa.SliceCmd
		})
	}
	fake.hMGetReturnsOnCall[i] = struct {
		result1 *redisa.SliceCmd
	}{result1}
}

func (fake *FakeClient) HMSet(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.BoolCmd {
	fake.hMSetMutex.Lock()
	ret, specificReturn := fake.hMSetReturnsOnCall[len(fake.hMSetArgsForCall)]
	fake.hMSetArgsForCall = append(fake.hMSetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.HMSetStub
	fakeReturns := fake.hMSetReturns
	fake.recordInvocation("HMSet", []interface{}{arg1, arg2, arg3})
	fake.hMSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HMSetCallCount() int {
	fake.hMSetMutex.RLock()
	defer fake.hMSetMutex.RUnlock()
	return len(fake.hMSetArgsForCall)
}

func (fake *FakeClient) HMSetCalls(stub func(context.Context, string, ...interface{}) *redisa.BoolCmd) {
	fake.hMSetMutex.Lock()
	defer fake.hMSetMutex.Unlock()
	fake.HMSetStub = stub
}

func (fake *FakeClient) HMSetArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.hMSetMutex.RLock()
	defer fake.hMSetMutex.RUnlock()
	argsForCall := fake.hMSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) HMSetReturns(result1 *redisa.BoolCmd) {
	fake.hMSetMutex.Lock()
	defer fake.hMSetMutex.Unlock()
	fake.HMSetStub = nil
	fake.hMSetReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) HMSetReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.hMSetMutex.Lock()
	defer fake.hMSetMutex.Unlock()
	fake.HMSetStub = nil
	if fake.hMSetReturnsOnCall == nil {
		fake.hMSetReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.hMSetReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) HPExpire(arg1 context.Context, arg2 string, arg3 time.Duration, arg4 ...string) *redisa.IntSliceCmd {
	fake.hPExpireMutex.Lock()
	ret, specificReturn := fake.hPExpireReturnsOnCall[len(fake.hPExpireArgsForCall)]
	fake.hPExpireArgsForCall = append(fake.hPExpireArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
		arg4 []string
	}{arg1, arg2, arg3, arg4})
	stub := fake.HPExpireStub
	fakeReturns := fake.hPExpireReturns
	fake.recordInvocation("HPExpire", []interface{}{arg1, arg2, arg3, arg4})
	fake.hPExpireMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HPExpireCallCount() int {
	fake.hPExpireMutex.RLock()
	defer fake.hPExpireMutex.RUnlock()
	return len(fake.hPExpireArgsForCall)
}

func (fake *FakeClient) HPExpireCalls(stub func(context.Context, string, time.Duration, ...string) *redisa.IntSliceCmd) {
	fake.hPExpireMutex.Lock()
	defer fake.hPExpireMutex.Unlock()
	fake.HPExpireStub = stub
}

func (fake *FakeClient) HPExpireArgsForCall(i int) (context.Context, string, time.Duration, []string) {
	fake.hPExpireMutex.RLock()
	defer fake.hPExpireMutex.RUnlock()
	argsForCall := fake.hPExpireArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) HPExpireReturns(result1 *redisa.IntSliceCmd) {
	fake.hPExpireMutex.Lock()
	defer fake.hPExpireMutex.Unlock()
	fake.HPExpireStub = nil
	fake.hPExpireReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HPExpireReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.hPExpireMutex.Lock()
	defer fake.hPExpireMutex.Unlock()
	fake.HPExpireStub = nil
	if fake.hPExpireReturnsOnCall == nil {
		fake.hPExpireReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.hPExpireReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HPExpireAt(arg1 context.Context, arg2 string, arg3 time.Time, arg4 ...string) *redisa.IntSliceCmd {
	fake.hPExpireAtMutex.Lock()
	ret, specificReturn := fake.hPExpireAtReturnsOnCall[len(fake.hPExpireAtArgsForCall)]
	fake.hPExpireAtArgsForCall = append(fake.hPExpireAtArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Time
		arg4 []string
	}{arg1, arg2, arg3, arg4})
	stub := fake.HPExpireAtStub
	fakeReturns := fake.hPExpireAtReturns
	fake.recordInvocation("HPExpireAt", []interface{}{arg1, arg2, arg3, arg4})
	fake.hPExpireAtMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HPExpireAtCallCount() int {
	fake.hPExpireAtMutex.RLock()
	defer fake.hPExpireAtMutex.RUnlock()
	return len(fake.hPExpireAtArgsForCall)
}

func (fake *FakeClient) HPExpireAtCalls(stub func(context.Context, string, time.Time, ...string) *redisa.IntSliceCmd) {
	fake.hPExpireAtMutex.Lock()
	defer fake.hPExpireAtMutex.Unlock()
	fake.HPExpireAtStub = stub
}

func (fake *FakeClient) HPExpireAtArgsForCall(i int) (context.Context, string, time.Time, []string) {
	fake.hPExpireAtMutex.RLock()
	defer fake.hPExpireAtMutex.RUnlock()
	argsForCall := fake.hPExpireAtArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) HPExpireAtReturns(result1 *redisa.IntSliceCmd) {
	fake.hPExpireAtMutex.Lock()
	defer fake.hPExpireAtMutex.Unlock()
	fake.HPExpireAtStub = nil
	fake.hPExpireAtReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HPExpireAtReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.hPExpireAtMutex.Lock()
	defer fake.hPExpireAtMutex.Unlock()
	fake.HPExpireAtStub = nil
	if fake.hPExpireAtReturnsOnCall == nil {
		fake.hPExpireAtReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.hPExpireAtReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HPExpireAtWithArgs(arg1 context.Context, arg2 string, arg3 time.Time, arg4 redisa.HExpireArgs, arg5 ...string) *redisa.IntSliceCmd {
	fake.hPExpireAtWithArgsMutex.Lock()
	ret, specificReturn := fake.hPExpireAtWithArgsReturnsOnCall[len(fake.hPExpireAtWithArgsArgsForCall)]
	fake.hPExpireAtWithArgsArgsForCall = append(fake.hPExpireAtWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Time
		arg4 redisa.HExpireArgs
		arg5 []string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.HPExpireAtWithArgsStub
	fakeReturns := fake.hPExpireAtWithArgsReturns
	fake.recordInvocation("HPExpireAtWithArgs", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.hPExpireAtWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HPExpireAtWithArgsCallCount() int {
	fake.hPExpireAtWithArgsMutex.RLock()
	defer fake.hPExpireAtWithArgsMutex.RUnlock()
	return len(fake.hPExpireAtWithArgsArgsForCall)
}

func (fake *FakeClient) HPExpireAtWithArgsCalls(stub func(context.Context, string, time.Time, redisa.HExpireArgs, ...string) *redisa.IntSliceCmd) {
	fake.hPExpireAtWithArgsMutex.Lock()
	defer fake.hPExpireAtWithArgsMutex.Unlock()
	fake.HPExpireAtWithArgsStub = stub
}

func (fake *FakeClient) HPExpireAtWithArgsArgsForCall(i int) (context.Context, string, time.Time, redisa.HExpireArgs, []string) {
	fake.hPExpireAtWithArgsMutex.RLock()
	defer fake.hPExpireAtWithArgsMutex.RUnlock()
	argsForCall := fake.hPExpireAtWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) HPExpireAtWithArgsReturns(result1 *redisa.IntSliceCmd) {
	fake.hPExpireAtWithArgsMutex.Lock()
	defer fake.hPExpireAtWithArgsMutex.Unlock()
	fake.HPExpireAtWithArgsStub = nil
	fake.hPExpireAtWithArgsReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HPExpireAtWithArgsReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.hPExpireAtWithArgsMutex.Lock()
	defer fake.hPExpireAtWithArgsMutex.Unlock()
	fake.HPExpireAtWithArgsStub = nil
	if fake.hPExpireAtWithArgsReturnsOnCall == nil {
		fake.hPExpireAtWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.hPExpireAtWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HPExpireTime(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntSliceCmd {
	fake.hPExpireTimeMutex.Lock()
	ret, specificReturn := fake.hPExpireTimeReturnsOnCall[len(fake.hPExpireTimeArgsForCall)]
	fake.hPExpireTimeArgsForCall = append(fake.hPExpireTimeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.HPExpireTimeStub
	fakeReturns := fake.hPExpireTimeReturns
	fake.recordInvocation("HPExpireTime", []interface{}{arg1, arg2, arg3})
	fake.hPExpireTimeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HPExpireTimeCallCount() int {
	fake.hPExpireTimeMutex.RLock()
	defer fake.hPExpireTimeMutex.RUnlock()
	return len(fake.hPExpireTimeArgsForCall)
}

func (fake *FakeClient) HPExpireTimeCalls(stub func(context.Context, string, ...string) *redisa.IntSliceCmd) {
	fake.hPExpireTimeMutex.Lock()
	defer fake.hPExpireTimeMutex.Unlock()
	fake.HPExpireTimeStub = stub
}

func (fake *FakeClient) HPExpireTimeArgsForCall(i int) (context.Context, string, []string) {
	fake.hPExpireTimeMutex.RLock()
	defer fake.hPExpireTimeMutex.RUnlock()
	argsForCall := fake.hPExpireTimeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) HPExpireTimeReturns(result1 *redisa.IntSliceCmd) {
	fake.hPExpireTimeMutex.Lock()
	defer fake.hPExpireTimeMutex.Unlock()
	fake.HPExpireTimeStub = nil
	fake.hPExpireTimeReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HPExpireTimeReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.hPExpireTimeMutex.Lock()
	defer fake.hPExpireTimeMutex.Unlock()
	fake.HPExpireTimeStub = nil
	if fake.hPExpireTimeReturnsOnCall == nil {
		fake.hPExpireTimeReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.hPExpireTimeReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HPExpireWithArgs(arg1 context.Context, arg2 string, arg3 time.Duration, arg4 redisa.HExpireArgs, arg5 ...string) *redisa.IntSliceCmd {
	fake.hPExpireWithArgsMutex.Lock()
	ret, specificReturn := fake.hPExpireWithArgsReturnsOnCall[len(fake.hPExpireWithArgsArgsForCall)]
	fake.hPExpireWithArgsArgsForCall = append(fake.hPExpireWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
		arg4 redisa.HExpireArgs
		arg5 []string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.HPExpireWithArgsStub
	fakeReturns := fake.hPExpireWithArgsReturns
	fake.recordInvocation("HPExpireWithArgs", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.hPExpireWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HPExpireWithArgsCallCount() int {
	fake.hPExpireWithArgsMutex.RLock()
	defer fake.hPExpireWithArgsMutex.RUnlock()
	return len(fake.hPExpireWithArgsArgsForCall)
}

func (fake *FakeClient) HPExpireWithArgsCalls(stub func(context.Context, string, time.Duration, redisa.HExpireArgs, ...string) *redisa.IntSliceCmd) {
	fake.hPExpireWithArgsMutex.Lock()
	defer fake.hPExpireWithArgsMutex.Unlock()
	fake.HPExpireWithArgsStub = stub
}

func (fake *FakeClient) HPExpireWithArgsArgsForCall(i int) (context.Context, string, time.Duration, redisa.HExpireArgs, []string) {
	fake.hPExpireWithArgsMutex.RLock()
	defer fake.hPExpireWithArgsMutex.RUnlock()
	argsForCall := fake.hPExpireWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) HPExpireWithArgsReturns(result1 *redisa.IntSliceCmd) {
	fake.hPExpireWithArgsMutex.Lock()
	defer fake.hPExpireWithArgsMutex.Unlock()
	fake.HPExpireWithArgsStub = nil
	fake.hPExpireWithArgsReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HPExpireWithArgsReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.hPExpireWithArgsMutex.Lock()
	defer fake.hPExpireWithArgsMutex.Unlock()
	fake.HPExpireWithArgsStub = nil
	if fake.hPExpireWithArgsReturnsOnCall == nil {
		fake.hPExpireWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.hPExpireWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HPTTL(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntSliceCmd {
	fake.hPTTLMutex.Lock()
	ret, specificReturn := fake.hPTTLReturnsOnCall[len(fake.hPTTLArgsForCall)]
	fake.hPTTLArgsForCall = append(fake.hPTTLArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.HPTTLStub
	fakeReturns := fake.hPTTLReturns
	fake.recordInvocation("HPTTL", []interface{}{arg1, arg2, arg3})
	fake.hPTTLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HPTTLCallCount() int {
	fake.hPTTLMutex.RLock()
	defer fake.hPTTLMutex.RUnlock()
	return len(fake.hPTTLArgsForCall)
}

func (fake *FakeClient) HPTTLCalls(stub func(context.Context, string, ...string) *redisa.IntSliceCmd) {
	fake.hPTTLMutex.Lock()
	defer fake.hPTTLMutex.Unlock()
	fake.HPTTLStub = stub
}

func (fake *FakeClient) HPTTLArgsForCall(i int) (context.Context, string, []string) {
	fake.hPTTLMutex.RLock()
	defer fake.hPTTLMutex.RUnlock()
	argsForCall := fake.hPTTLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) HPTTLReturns(result1 *redisa.IntSliceCmd) {
	fake.hPTTLMutex.Lock()
	defer fake.hPTTLMutex.Unlock()
	fake.HPTTLStub = nil
	fake.hPTTLReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HPTTLReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.hPTTLMutex.Lock()
	defer fake.hPTTLMutex.Unlock()
	fake.HPTTLStub = nil
	if fake.hPTTLReturnsOnCall == nil {
		fake.hPTTLReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.hPTTLReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HPersist(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntSliceCmd {
	fake.hPersistMutex.Lock()
	ret, specificReturn := fake.hPersistReturnsOnCall[len(fake.hPersistArgsForCall)]
	fake.hPersistArgsForCall = append(fake.hPersistArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.HPersistStub
	fakeReturns := fake.hPersistReturns
	fake.recordInvocation("HPersist", []interface{}{arg1, arg2, arg3})
	fake.hPersistMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HPersistCallCount() int {
	fake.hPersistMutex.RLock()
	defer fake.hPersistMutex.RUnlock()
	return len(fake.hPersistArgsForCall)
}

func (fake *FakeClient) HPersistCalls(stub func(context.Context, string, ...string) *redisa.IntSliceCmd) {
	fake.hPersistMutex.Lock()
	defer fake.hPersistMutex.Unlock()
	fake.HPersistStub = stub
}

func (fake *FakeClient) HPersistArgsForCall(i int) (context.Context, string, []string) {
	fake.hPersistMutex.RLock()
	defer fake.hPersistMutex.RUnlock()
	argsForCall := fake.hPersistArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) HPersistReturns(result1 *redisa.IntSliceCmd) {
	fake.hPersistMutex.Lock()
	defer fake.hPersistMutex.Unlock()
	fake.HPersistStub = nil
	fake.hPersistReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HPersistReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.hPersistMutex.Lock()
	defer fake.hPersistMutex.Unlock()
	fake.HPersistStub = nil
	if fake.hPersistReturnsOnCall == nil {
		fake.hPersistReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.hPersistReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HRandField(arg1 context.Context, arg2 string, arg3 int) *redisa.StringSliceCmd {
	fake.hRandFieldMutex.Lock()
	ret, specificReturn := fake.hRandFieldReturnsOnCall[len(fake.hRandFieldArgsForCall)]
	fake.hRandFieldArgsForCall = append(fake.hRandFieldArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.HRandFieldStub
	fakeReturns := fake.hRandFieldReturns
	fake.recordInvocation("HRandField", []interface{}{arg1, arg2, arg3})
	fake.hRandFieldMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HRandFieldCallCount() int {
	fake.hRandFieldMutex.RLock()
	defer fake.hRandFieldMutex.RUnlock()
	return len(fake.hRandFieldArgsForCall)
}

func (fake *FakeClient) HRandFieldCalls(stub func(context.Context, string, int) *redisa.StringSliceCmd) {
	fake.hRandFieldMutex.Lock()
	defer fake.hRandFieldMutex.Unlock()
	fake.HRandFieldStub = stub
}

func (fake *FakeClient) HRandFieldArgsForCall(i int) (context.Context, string, int) {
	fake.hRandFieldMutex.RLock()
	defer fake.hRandFieldMutex.RUnlock()
	argsForCall := fake.hRandFieldArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) HRandFieldReturns(result1 *redisa.StringSliceCmd) {
	fake.hRandFieldMutex.Lock()
	defer fake.hRandFieldMutex.Unlock()
	fake.HRandFieldStub = nil
	fake.hRandFieldReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) HRandFieldReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.hRandFieldMutex.Lock()
	defer fake.hRandFieldMutex.Unlock()
	fake.HRandFieldStub = nil
	if fake.hRandFieldReturnsOnCall == nil {
		fake.hRandFieldReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.hRandFieldReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) HRandFieldWithValues(arg1 context.Context, arg2 string, arg3 int) *redisa.KeyValueSliceCmd {
	fake.hRandFieldWithValuesMutex.Lock()
	ret, specificReturn := fake.hRandFieldWithValuesReturnsOnCall[len(fake.hRandFieldWithValuesArgsForCall)]
	fake.hRandFieldWithValuesArgsForCall = append(fake.hRandFieldWithValuesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.HRandFieldWithValuesStub
	fakeReturns := fake.hRandFieldWithValuesReturns
	fake.recordInvocation("HRandFieldWithValues", []interface{}{arg1, arg2, arg3})
	fake.hRandFieldWithValuesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HRandFieldWithValuesCallCount() int {
	fake.hRandFieldWithValuesMutex.RLock()
	defer fake.hRandFieldWithValuesMutex.RUnlock()
	return len(fake.hRandFieldWithValuesArgsForCall)
}

func (fake *FakeClient) HRandFieldWithValuesCalls(stub func(context.Context, string, int) *redisa.KeyValueSliceCmd) {
	fake.hRandFieldWithValuesMutex.Lock()
	defer fake.hRandFieldWithValuesMutex.Unlock()
	fake.HRandFieldWithValuesStub = stub
}

func (fake *FakeClient) HRandFieldWithValuesArgsForCall(i int) (context.Context, string, int) {
	fake.hRandFieldWithValuesMutex.RLock()
	defer fake.hRandFieldWithValuesMutex.RUnlock()
	argsForCall := fake.hRandFieldWithValuesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) HRandFieldWithValuesReturns(result1 *redisa.KeyValueSliceCmd) {
	fake.hRandFieldWithValuesMutex.Lock()
	defer fake.hRandFieldWithValuesMutex.Unlock()
	fake.HRandFieldWithValuesStub = nil
	fake.hRandFieldWithValuesReturns = struct {
		result1 *redisa.KeyValueSliceCmd
	}{result1}
}

func (fake *FakeClient) HRandFieldWithValuesReturnsOnCall(i int, result1 *redisa.KeyValueSliceCmd) {
	fake.hRandFieldWithValuesMutex.Lock()
	defer fake.hRandFieldWithValuesMutex.Unlock()
	fake.HRandFieldWithValuesStub = nil
	if fake.hRandFieldWithValuesReturnsOnCall == nil {
		fake.hRandFieldWithValuesReturnsOnCall = make(map[int]struct {
			result1 *redisa.KeyValueSliceCmd
		})
	}
	fake.hRandFieldWithValuesReturnsOnCall[i] = struct {
		result1 *redisa.KeyValueSliceCmd
	}{result1}
}

func (fake *FakeClient) HScan(arg1 context.Context, arg2 string, arg3 uint64, arg4 string, arg5 int64) *redisa.ScanCmd {
	fake.hScanMutex.Lock()
	ret, specificReturn := fake.hScanReturnsOnCall[len(fake.hScanArgsForCall)]
	fake.hScanArgsForCall = append(fake.hScanArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 uint64
		arg4 string
		arg5 int64
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.HScanStub
	fakeReturns := fake.hScanReturns
	fake.recordInvocation("HScan", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.hScanMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HScanCallCount() int {
	fake.hScanMutex.RLock()
	defer fake.hScanMutex.RUnlock()
	return len(fake.hScanArgsForCall)
}

func (fake *FakeClient) HScanCalls(stub func(context.Context, string, uint64, string, int64) *redisa.ScanCmd) {
	fake.hScanMutex.Lock()
	defer fake.hScanMutex.Unlock()
	fake.HScanStub = stub
}

func (fake *FakeClient) HScanArgsForCall(i int) (context.Context, string, uint64, string, int64) {
	fake.hScanMutex.RLock()
	defer fake.hScanMutex.RUnlock()
	argsForCall := fake.hScanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) HScanReturns(result1 *redisa.ScanCmd) {
	fake.hScanMutex.Lock()
	defer fake.hScanMutex.Unlock()
	fake.HScanStub = nil
	fake.hScanReturns = struct {
		result1 *redisa.ScanCmd
	}{result1}
}

func (fake *FakeClient) HScanReturnsOnCall(i int, result1 *redisa.ScanCmd) {
	fake.hScanMutex.Lock()
	defer fake.hScanMutex.Unlock()
	fake.HScanStub = nil
	if fake.hScanReturnsOnCall == nil {
		fake.hScanReturnsOnCall = make(map[int]struct {
			result1 *redisa.ScanCmd
		})
	}
	fake.hScanReturnsOnCall[i] = struct {
		result1 *redisa.ScanCmd
	}{result1}
}

func (fake *FakeClient) HScanNoValues(arg1 context.Context, arg2 string, arg3 uint64, arg4 string, arg5 int64) *redisa.ScanCmd {
	fake.hScanNoValuesMutex.Lock()
	ret, specificReturn := fake.hScanNoValuesReturnsOnCall[len(fake.hScanNoValuesArgsForCall)]
	fake.hScanNoValuesArgsForCall = append(fake.hScanNoValuesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 uint64
		arg4 string
		arg5 int64
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.HScanNoValuesStub
	fakeReturns := fake.hScanNoValuesReturns
	fake.recordInvocation("HScanNoValues", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.hScanNoValuesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HScanNoValuesCallCount() int {
	fake.hScanNoValuesMutex.RLock()
	defer fake.hScanNoValuesMutex.RUnlock()
	return len(fake.hScanNoValuesArgsForCall)
}

func (fake *FakeClient) HScanNoValuesCalls(stub func(context.Context, string, uint64, string, int64) *redisa.ScanCmd) {
	fake.hScanNoValuesMutex.Lock()
	defer fake.hScanNoValuesMutex.Unlock()
	fake.HScanNoValuesStub = stub
}

func (fake *FakeClient) HScanNoValuesArgsForCall(i int) (context.Context, string, uint64, string, int64) {
	fake.hScanNoValuesMutex.RLock()
	defer fake.hScanNoValuesMutex.RUnlock()
	argsForCall := fake.hScanNoValuesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) HScanNoValuesReturns(result1 *redisa.ScanCmd) {
	fake.hScanNoValuesMutex.Lock()
	defer fake.hScanNoValuesMutex.Unlock()
	fake.HScanNoValuesStub = nil
	fake.hScanNoValuesReturns = struct {
		result1 *redisa.ScanCmd
	}{result1}
}

func (fake *FakeClient) HScanNoValuesReturnsOnCall(i int, result1 *redisa.ScanCmd) {
	fake.hScanNoValuesMutex.Lock()
	defer fake.hScanNoValuesMutex.Unlock()
	fake.HScanNoValuesStub = nil
	if fake.hScanNoValuesReturnsOnCall == nil {
		fake.hScanNoValuesReturnsOnCall = make(map[int]struct {
			result1 *redisa.ScanCmd
		})
	}
	fake.hScanNoValuesReturnsOnCall[i] = struct {
		result1 *redisa.ScanCmd
	}{result1}
}

func (fake *FakeClient) HSet(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntCmd {
	fake.hSetMutex.Lock()
	ret, specificReturn := fake.hSetReturnsOnCall[len(fake.hSetArgsForCall)]
	fake.hSetArgsForCall = append(fake.hSetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.HSetStub
	fakeReturns := fake.hSetReturns
	fake.recordInvocation("HSet", []interface{}{arg1, arg2, arg3})
	fake.hSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HSetCallCount() int {
	fake.hSetMutex.RLock()
	defer fake.hSetMutex.RUnlock()
	return len(fake.hSetArgsForCall)
}

func (fake *FakeClient) HSetCalls(stub func(context.Context, string, ...interface{}) *redisa.IntCmd) {
	fake.hSetMutex.Lock()
	defer fake.hSetMutex.Unlock()
	fake.HSetStub = stub
}

func (fake *FakeClient) HSetArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.hSetMutex.RLock()
	defer fake.hSetMutex.RUnlock()
	argsForCall := fake.hSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) HSetReturns(result1 *redisa.IntCmd) {
	fake.hSetMutex.Lock()
	defer fake.hSetMutex.Unlock()
	fake.HSetStub = nil
	fake.hSetReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) HSetReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.hSetMutex.Lock()
	defer fake.hSetMutex.Unlock()
	fake.HSetStub = nil
	if fake.hSetReturnsOnCall == nil {
		fake.hSetReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.hSetReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) HSetNX(arg1 context.Context, arg2 string, arg3 string, arg4 interface{}) *redisa.BoolCmd {
	fake.hSetNXMutex.Lock()
	ret, specificReturn := fake.hSetNXReturnsOnCall[len(fake.hSetNXArgsForCall)]
	fake.hSetNXArgsForCall = append(fake.hSetNXArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.HSetNXStub
	fakeReturns := fake.hSetNXReturns
	fake.recordInvocation("HSetNX", []interface{}{arg1, arg2, arg3, arg4})
	fake.hSetNXMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HSetNXCallCount() int {
	fake.hSetNXMutex.RLock()
	defer fake.hSetNXMutex.RUnlock()
	return len(fake.hSetNXArgsForCall)
}

func (fake *FakeClient) HSetNXCalls(stub func(context.Context, string, string, interface{}) *redisa.BoolCmd) {
	fake.hSetNXMutex.Lock()
	defer fake.hSetNXMutex.Unlock()
	fake.HSetNXStub = stub
}

func (fake *FakeClient) HSetNXArgsForCall(i int) (context.Context, string, string, interface{}) {
	fake.hSetNXMutex.RLock()
	defer fake.hSetNXMutex.RUnlock()
	argsForCall := fake.hSetNXArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) HSetNXReturns(result1 *redisa.BoolCmd) {
	fake.hSetNXMutex.Lock()
	defer fake.hSetNXMutex.Unlock()
	fake.HSetNXStub = nil
	fake.hSetNXReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) HSetNXReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.hSetNXMutex.Lock()
	defer fake.hSetNXMutex.Unlock()
	fake.HSetNXStub = nil
	if fake.hSetNXReturnsOnCall == nil {
		fake.hSetNXReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.hSetNXReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) HTTL(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntSliceCmd {
	fake.hTTLMutex.Lock()
	ret, specificReturn := fake.hTTLReturnsOnCall[len(fake.hTTLArgsForCall)]
	fake.hTTLArgsForCall = append(fake.hTTLArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.HTTLStub
	fakeReturns := fake.hTTLReturns
	fake.recordInvocation("HTTL", []interface{}{arg1, arg2, arg3})
	fake.hTTLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HTTLCallCount() int {
	fake.hTTLMutex.RLock()
	defer fake.hTTLMutex.RUnlock()
	return len(fake.hTTLArgsForCall)
}

func (fake *FakeClient) HTTLCalls(stub func(context.Context, string, ...string) *redisa.IntSliceCmd) {
	fake.hTTLMutex.Lock()
	defer fake.hTTLMutex.Unlock()
	fake.HTTLStub = stub
}

func (fake *FakeClient) HTTLArgsForCall(i int) (context.Context, string, []string) {
	fake.hTTLMutex.RLock()
	defer fake.hTTLMutex.RUnlock()
	argsForCall := fake.hTTLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) HTTLReturns(result1 *redisa.IntSliceCmd) {
	fake.hTTLMutex.Lock()
	defer fake.hTTLMutex.Unlock()
	fake.HTTLStub = nil
	fake.hTTLReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HTTLReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.hTTLMutex.Lock()
	defer fake.hTTLMutex.Unlock()
	fake.HTTLStub = nil
	if fake.hTTLReturnsOnCall == nil {
		fake.hTTLReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.hTTLReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) HVals(arg1 context.Context, arg2 string) *redisa.StringSliceCmd {
	fake.hValsMutex.Lock()
	ret, specificReturn := fake.hValsReturnsOnCall[len(fake.hValsArgsForCall)]
	fake.hValsArgsForCall = append(fake.hValsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.HValsStub
	fakeReturns := fake.hValsReturns
	fake.recordInvocation("HVals", []interface{}{arg1, arg2})
	fake.hValsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) HValsCallCount() int {
	fake.hValsMutex.RLock()
	defer fake.hValsMutex.RUnlock()
	return len(fake.hValsArgsForCall)
}

func (fake *FakeClient) HValsCalls(stub func(context.Context, string) *redisa.StringSliceCmd) {
	fake.hValsMutex.Lock()
	defer fake.hValsMutex.Unlock()
	fake.HValsStub = stub
}

func (fake *FakeClient) HValsArgsForCall(i int) (context.Context, string) {
	fake.hValsMutex.RLock()
	defer fake.hValsMutex.RUnlock()
	argsForCall := fake.hValsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) HValsReturns(result1 *redisa.StringSliceCmd) {
	fake.hValsMutex.Lock()
	defer fake.hValsMutex.Unlock()
	fake.HValsStub = nil
	fake.hValsReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) HValsReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.hValsMutex.Lock()
	defer fake.hValsMutex.Unlock()
	fake.HValsStub = nil
	if fake.hValsReturnsOnCall == nil {
		fake.hValsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.hValsReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) Incr(arg1 context.Context, arg2 string) *redisa.IntCmd {
	fake.incrMutex.Lock()
	ret, specificReturn := fake.incrReturnsOnCall[len(fake.incrArgsForCall)]
	fake.incrArgsForCall = append(fake.incrArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.IncrStub
	fakeReturns := fake.incrReturns
	fake.recordInvocation("Incr", []interface{}{arg1, arg2})
	fake.incrMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) IncrCallCount() int {
	fake.incrMutex.RLock()
	defer fake.incrMutex.RUnlock()
	return len(fake.incrArgsForCall)
}

func (fake *FakeClient) IncrCalls(stub func(context.Context, string) *redisa.IntCmd) {
	fake.incrMutex.Lock()
	defer fake.incrMutex.Unlock()
	fake.IncrStub = stub
}

func (fake *FakeClient) IncrArgsForCall(i int) (context.Context, string) {
	fake.incrMutex.RLock()
	defer fake.incrMutex.RUnlock()
	argsForCall := fake.incrArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) IncrReturns(result1 *redisa.IntCmd) {
	fake.incrMutex.Lock()
	defer fake.incrMutex.Unlock()
	fake.IncrStub = nil
	fake.incrReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) IncrReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.incrMutex.Lock()
	defer fake.incrMutex.Unlock()
	fake.IncrStub = nil
	if fake.incrReturnsOnCall == nil {
		fake.incrReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.incrReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) IncrBy(arg1 context.Context, arg2 string, arg3 int64) *redisa.IntCmd {
	fake.incrByMutex.Lock()
	ret, specificReturn := fake.incrByReturnsOnCall[len(fake.incrByArgsForCall)]
	fake.incrByArgsForCall = append(fake.incrByArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.IncrByStub
	fakeReturns := fake.incrByReturns
	fake.recordInvocation("IncrBy", []interface{}{arg1, arg2, arg3})
	fake.incrByMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) IncrByCallCount() int {
	fake.incrByMutex.RLock()
	defer fake.incrByMutex.RUnlock()
	return len(fake.incrByArgsForCall)
}

func (fake *FakeClient) IncrByCalls(stub func(context.Context, string, int64) *redisa.IntCmd) {
	fake.incrByMutex.Lock()
	defer fake.incrByMutex.Unlock()
	fake.IncrByStub = stub
}

func (fake *FakeClient) IncrByArgsForCall(i int) (context.Context, string, int64) {
	fake.incrByMutex.RLock()
	defer fake.incrByMutex.RUnlock()
	argsForCall := fake.incrByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) IncrByReturns(result1 *redisa.IntCmd) {
	fake.incrByMutex.Lock()
	defer fake.incrByMutex.Unlock()
	fake.IncrByStub = nil
	fake.incrByReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) IncrByReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.incrByMutex.Lock()
	defer fake.incrByMutex.Unlock()
	fake.IncrByStub = nil
	if fake.incrByReturnsOnCall == nil {
		fake.incrByReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.incrByReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) IncrByFloat(arg1 context.Context, arg2 string, arg3 float64) *redisa.FloatCmd {
	fake.incrByFloatMutex.Lock()
	ret, specificReturn := fake.incrByFloatReturnsOnCall[len(fake.incrByFloatArgsForCall)]
	fake.incrByFloatArgsForCall = append(fake.incrByFloatArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 float64
	}{arg1, arg2, arg3})
	stub := fake.IncrByFloatStub
	fakeReturns := fake.incrByFloatReturns
	fake.recordInvocation("IncrByFloat", []interface{}{arg1, arg2, arg3})
	fake.incrByFloatMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) IncrByFloatCallCount() int {
	fake.incrByFloatMutex.RLock()
	defer fake.incrByFloatMutex.RUnlock()
	return len(fake.incrByFloatArgsForCall)
}

func (fake *FakeClient) IncrByFloatCalls(stub func(context.Context, string, float64) *redisa.FloatCmd) {
	fake.incrByFloatMutex.Lock()
	defer fake.incrByFloatMutex.Unlock()
	fake.IncrByFloatStub = stub
}

func (fake *FakeClient) IncrByFloatArgsForCall(i int) (context.Context, string, float64) {
	fake.incrByFloatMutex.RLock()
	defer fake.incrByFloatMutex.RUnlock()
	argsForCall := fake.incrByFloatArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) IncrByFloatReturns(result1 *redisa.FloatCmd) {
	fake.incrByFloatMutex.Lock()
	defer fake.incrByFloatMutex.Unlock()
	fake.IncrByFloatStub = nil
	fake.incrByFloatReturns = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) IncrByFloatReturnsOnCall(i int, result1 *redisa.FloatCmd) {
	fake.incrByFloatMutex.Lock()
	defer fake.incrByFloatMutex.Unlock()
	fake.IncrByFloatStub = nil
	if fake.incrByFloatReturnsOnCall == nil {
		fake.incrByFloatReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatCmd
		})
	}
	fake.incrByFloatReturnsOnCall[i] = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) Info(arg1 context.Context, arg2 ...string) *redisa.StringCmd {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.InfoStub
	fakeReturns := fake.infoReturns
	fake.recordInvocation("Info", []interface{}{arg1, arg2})
	fake.infoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeClient) InfoCalls(stub func(context.Context, ...string) *redisa.StringCmd) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = stub
}

func (fake *FakeClient) InfoArgsForCall(i int) (context.Context, []string) {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	argsForCall := fake.infoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) InfoReturns(result1 *redisa.StringCmd) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) InfoReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) JSONArrAppend(arg1 context.Context, arg2 string, arg3 string, arg4 ...interface{}) *redisa.IntSliceCmd {
	fake.jSONArrAppendMutex.Lock()
	ret, specificReturn := fake.jSONArrAppendReturnsOnCall[len(fake.jSONArrAppendArgsForCall)]
	fake.jSONArrAppendArgsForCall = append(fake.jSONArrAppendArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.JSONArrAppendStub
	fakeReturns := fake.jSONArrAppendReturns
	fake.recordInvocation("JSONArrAppend", []interface{}{arg1, arg2, arg3, arg4})
	fake.jSONArrAppendMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONArrAppendCallCount() int {
	fake.jSONArrAppendMutex.RLock()
	defer fake.jSONArrAppendMutex.RUnlock()
	return len(fake.jSONArrAppendArgsForCall)
}

func (fake *FakeClient) JSONArrAppendCalls(stub func(context.Context, string, string, ...interface{}) *redisa.IntSliceCmd) {
	fake.jSONArrAppendMutex.Lock()
	defer fake.jSONArrAppendMutex.Unlock()
	fake.JSONArrAppendStub = stub
}

func (fake *FakeClient) JSONArrAppendArgsForCall(i int) (context.Context, string, string, []interface{}) {
	fake.jSONArrAppendMutex.RLock()
	defer fake.jSONArrAppendMutex.RUnlock()
	argsForCall := fake.jSONArrAppendArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) JSONArrAppendReturns(result1 *redisa.IntSliceCmd) {
	fake.jSONArrAppendMutex.Lock()
	defer fake.jSONArrAppendMutex.Unlock()
	fake.JSONArrAppendStub = nil
	fake.jSONArrAppendReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrAppendReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.jSONArrAppendMutex.Lock()
	defer fake.jSONArrAppendMutex.Unlock()
	fake.JSONArrAppendStub = nil
	if fake.jSONArrAppendReturnsOnCall == nil {
		fake.jSONArrAppendReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.jSONArrAppendReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrIndex(arg1 context.Context, arg2 string, arg3 string, arg4 ...interface{}) *redisa.IntSliceCmd {
	fake.jSONArrIndexMutex.Lock()
	ret, specificReturn := fake.jSONArrIndexReturnsOnCall[len(fake.jSONArrIndexArgsForCall)]
	fake.jSONArrIndexArgsForCall = append(fake.jSONArrIndexArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.JSONArrIndexStub
	fakeReturns := fake.jSONArrIndexReturns
	fake.recordInvocation("JSONArrIndex", []interface{}{arg1, arg2, arg3, arg4})
	fake.jSONArrIndexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONArrIndexCallCount() int {
	fake.jSONArrIndexMutex.RLock()
	defer fake.jSONArrIndexMutex.RUnlock()
	return len(fake.jSONArrIndexArgsForCall)
}

func (fake *FakeClient) JSONArrIndexCalls(stub func(context.Context, string, string, ...interface{}) *redisa.IntSliceCmd) {
	fake.jSONArrIndexMutex.Lock()
	defer fake.jSONArrIndexMutex.Unlock()
	fake.JSONArrIndexStub = stub
}

func (fake *FakeClient) JSONArrIndexArgsForCall(i int) (context.Context, string, string, []interface{}) {
	fake.jSONArrIndexMutex.RLock()
	defer fake.jSONArrIndexMutex.RUnlock()
	argsForCall := fake.jSONArrIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) JSONArrIndexReturns(result1 *redisa.IntSliceCmd) {
	fake.jSONArrIndexMutex.Lock()
	defer fake.jSONArrIndexMutex.Unlock()
	fake.JSONArrIndexStub = nil
	fake.jSONArrIndexReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrIndexReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.jSONArrIndexMutex.Lock()
	defer fake.jSONArrIndexMutex.Unlock()
	fake.JSONArrIndexStub = nil
	if fake.jSONArrIndexReturnsOnCall == nil {
		fake.jSONArrIndexReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.jSONArrIndexReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrIndexWithArgs(arg1 context.Context, arg2 string, arg3 string, arg4 *redisa.JSONArrIndexArgs, arg5 ...interface{}) *redisa.IntSliceCmd {
	fake.jSONArrIndexWithArgsMutex.Lock()
	ret, specificReturn := fake.jSONArrIndexWithArgsReturnsOnCall[len(fake.jSONArrIndexWithArgsArgsForCall)]
	fake.jSONArrIndexWithArgsArgsForCall = append(fake.jSONArrIndexWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.JSONArrIndexArgs
		arg5 []interface{}
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.JSONArrIndexWithArgsStub
	fakeReturns := fake.jSONArrIndexWithArgsReturns
	fake.recordInvocation("JSONArrIndexWithArgs", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.jSONArrIndexWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONArrIndexWithArgsCallCount() int {
	fake.jSONArrIndexWithArgsMutex.RLock()
	defer fake.jSONArrIndexWithArgsMutex.RUnlock()
	return len(fake.jSONArrIndexWithArgsArgsForCall)
}

func (fake *FakeClient) JSONArrIndexWithArgsCalls(stub func(context.Context, string, string, *redisa.JSONArrIndexArgs, ...interface{}) *redisa.IntSliceCmd) {
	fake.jSONArrIndexWithArgsMutex.Lock()
	defer fake.jSONArrIndexWithArgsMutex.Unlock()
	fake.JSONArrIndexWithArgsStub = stub
}

func (fake *FakeClient) JSONArrIndexWithArgsArgsForCall(i int) (context.Context, string, string, *redisa.JSONArrIndexArgs, []interface{}) {
	fake.jSONArrIndexWithArgsMutex.RLock()
	defer fake.jSONArrIndexWithArgsMutex.RUnlock()
	argsForCall := fake.jSONArrIndexWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) JSONArrIndexWithArgsReturns(result1 *redisa.IntSliceCmd) {
	fake.jSONArrIndexWithArgsMutex.Lock()
	defer fake.jSONArrIndexWithArgsMutex.Unlock()
	fake.JSONArrIndexWithArgsStub = nil
	fake.jSONArrIndexWithArgsReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrIndexWithArgsReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.jSONArrIndexWithArgsMutex.Lock()
	defer fake.jSONArrIndexWithArgsMutex.Unlock()
	fake.JSONArrIndexWithArgsStub = nil
	if fake.jSONArrIndexWithArgsReturnsOnCall == nil {
		fake.jSONArrIndexWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.jSONArrIndexWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrInsert(arg1 context.Context, arg2 string, arg3 string, arg4 int64, arg5 ...interface{}) *redisa.IntSliceCmd {
	fake.jSONArrInsertMutex.Lock()
	ret, specificReturn := fake.jSONArrInsertReturnsOnCall[len(fake.jSONArrInsertArgsForCall)]
	fake.jSONArrInsertArgsForCall = append(fake.jSONArrInsertArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 []interface{}
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.JSONArrInsertStub
	fakeReturns := fake.jSONArrInsertReturns
	fake.recordInvocation("JSONArrInsert", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.jSONArrInsertMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONArrInsertCallCount() int {
	fake.jSONArrInsertMutex.RLock()
	defer fake.jSONArrInsertMutex.RUnlock()
	return len(fake.jSONArrInsertArgsForCall)
}

func (fake *FakeClient) JSONArrInsertCalls(stub func(context.Context, string, string, int64, ...interface{}) *redisa.IntSliceCmd) {
	fake.jSONArrInsertMutex.Lock()
	defer fake.jSONArrInsertMutex.Unlock()
	fake.JSONArrInsertStub = stub
}

func (fake *FakeClient) JSONArrInsertArgsForCall(i int) (context.Context, string, string, int64, []interface{}) {
	fake.jSONArrInsertMutex.RLock()
	defer fake.jSONArrInsertMutex.RUnlock()
	argsForCall := fake.jSONArrInsertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) JSONArrInsertReturns(result1 *redisa.IntSliceCmd) {
	fake.jSONArrInsertMutex.Lock()
	defer fake.jSONArrInsertMutex.Unlock()
	fake.JSONArrInsertStub = nil
	fake.jSONArrInsertReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrInsertReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.jSONArrInsertMutex.Lock()
	defer fake.jSONArrInsertMutex.Unlock()
	fake.JSONArrInsertStub = nil
	if fake.jSONArrInsertReturnsOnCall == nil {
		fake.jSONArrInsertReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.jSONArrInsertReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrLen(arg1 context.Context, arg2 string, arg3 string) *redisa.IntSliceCmd {
	fake.jSONArrLenMutex.Lock()
	ret, specificReturn := fake.jSONArrLenReturnsOnCall[len(fake.jSONArrLenArgsForCall)]
	fake.jSONArrLenArgsForCall = append(fake.jSONArrLenArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.JSONArrLenStub
	fakeReturns := fake.jSONArrLenReturns
	fake.recordInvocation("JSONArrLen", []interface{}{arg1, arg2, arg3})
	fake.jSONArrLenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONArrLenCallCount() int {
	fake.jSONArrLenMutex.RLock()
	defer fake.jSONArrLenMutex.RUnlock()
	return len(fake.jSONArrLenArgsForCall)
}

func (fake *FakeClient) JSONArrLenCalls(stub func(context.Context, string, string) *redisa.IntSliceCmd) {
	fake.jSONArrLenMutex.Lock()
	defer fake.jSONArrLenMutex.Unlock()
	fake.JSONArrLenStub = stub
}

func (fake *FakeClient) JSONArrLenArgsForCall(i int) (context.Context, string, string) {
	fake.jSONArrLenMutex.RLock()
	defer fake.jSONArrLenMutex.RUnlock()
	argsForCall := fake.jSONArrLenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) JSONArrLenReturns(result1 *redisa.IntSliceCmd) {
	fake.jSONArrLenMutex.Lock()
	defer fake.jSONArrLenMutex.Unlock()
	fake.JSONArrLenStub = nil
	fake.jSONArrLenReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrLenReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.jSONArrLenMutex.Lock()
	defer fake.jSONArrLenMutex.Unlock()
	fake.JSONArrLenStub = nil
	if fake.jSONArrLenReturnsOnCall == nil {
		fake.jSONArrLenReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.jSONArrLenReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrPop(arg1 context.Context, arg2 string, arg3 string, arg4 int) *redisa.StringSliceCmd {
	fake.jSONArrPopMutex.Lock()
	ret, specificReturn := fake.jSONArrPopReturnsOnCall[len(fake.jSONArrPopArgsForCall)]
	fake.jSONArrPopArgsForCall = append(fake.jSONArrPopArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.JSONArrPopStub
	fakeReturns := fake.jSONArrPopReturns
	fake.recordInvocation("JSONArrPop", []interface{}{arg1, arg2, arg3, arg4})
	fake.jSONArrPopMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONArrPopCallCount() int {
	fake.jSONArrPopMutex.RLock()
	defer fake.jSONArrPopMutex.RUnlock()
	return len(fake.jSONArrPopArgsForCall)
}

func (fake *FakeClient) JSONArrPopCalls(stub func(context.Context, string, string, int) *redisa.StringSliceCmd) {
	fake.jSONArrPopMutex.Lock()
	defer fake.jSONArrPopMutex.Unlock()
	fake.JSONArrPopStub = stub
}

func (fake *FakeClient) JSONArrPopArgsForCall(i int) (context.Context, string, string, int) {
	fake.jSONArrPopMutex.RLock()
	defer fake.jSONArrPopMutex.RUnlock()
	argsForCall := fake.jSONArrPopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) JSONArrPopReturns(result1 *redisa.StringSliceCmd) {
	fake.jSONArrPopMutex.Lock()
	defer fake.jSONArrPopMutex.Unlock()
	fake.JSONArrPopStub = nil
	fake.jSONArrPopReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrPopReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.jSONArrPopMutex.Lock()
	defer fake.jSONArrPopMutex.Unlock()
	fake.JSONArrPopStub = nil
	if fake.jSONArrPopReturnsOnCall == nil {
		fake.jSONArrPopReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.jSONArrPopReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrTrim(arg1 context.Context, arg2 string, arg3 string) *redisa.IntSliceCmd {
	fake.jSONArrTrimMutex.Lock()
	ret, specificReturn := fake.jSONArrTrimReturnsOnCall[len(fake.jSONArrTrimArgsForCall)]
	fake.jSONArrTrimArgsForCall = append(fake.jSONArrTrimArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.JSONArrTrimStub
	fakeReturns := fake.jSONArrTrimReturns
	fake.recordInvocation("JSONArrTrim", []interface{}{arg1, arg2, arg3})
	fake.jSONArrTrimMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONArrTrimCallCount() int {
	fake.jSONArrTrimMutex.RLock()
	defer fake.jSONArrTrimMutex.RUnlock()
	return len(fake.jSONArrTrimArgsForCall)
}

func (fake *FakeClient) JSONArrTrimCalls(stub func(context.Context, string, string) *redisa.IntSliceCmd) {
	fake.jSONArrTrimMutex.Lock()
	defer fake.jSONArrTrimMutex.Unlock()
	fake.JSONArrTrimStub = stub
}

func (fake *FakeClient) JSONArrTrimArgsForCall(i int) (context.Context, string, string) {
	fake.jSONArrTrimMutex.RLock()
	defer fake.jSONArrTrimMutex.RUnlock()
	argsForCall := fake.jSONArrTrimArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) JSONArrTrimReturns(result1 *redisa.IntSliceCmd) {
	fake.jSONArrTrimMutex.Lock()
	defer fake.jSONArrTrimMutex.Unlock()
	fake.JSONArrTrimStub = nil
	fake.jSONArrTrimReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrTrimReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.jSONArrTrimMutex.Lock()
	defer fake.jSONArrTrimMutex.Unlock()
	fake.JSONArrTrimStub = nil
	if fake.jSONArrTrimReturnsOnCall == nil {
		fake.jSONArrTrimReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.jSONArrTrimReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrTrimWithArgs(arg1 context.Context, arg2 string, arg3 string, arg4 *redisa.JSONArrTrimArgs) *redisa.IntSliceCmd {
	fake.jSONArrTrimWithArgsMutex.Lock()
	ret, specificReturn := fake.jSONArrTrimWithArgsReturnsOnCall[len(fake.jSONArrTrimWithArgsArgsForCall)]
	fake.jSONArrTrimWithArgsArgsForCall = append(fake.jSONArrTrimWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.JSONArrTrimArgs
	}{arg1, arg2, arg3, arg4})
	stub := fake.JSONArrTrimWithArgsStub
	fakeReturns := fake.jSONArrTrimWithArgsReturns
	fake.recordInvocation("JSONArrTrimWithArgs", []interface{}{arg1, arg2, arg3, arg4})
	fake.jSONArrTrimWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONArrTrimWithArgsCallCount() int {
	fake.jSONArrTrimWithArgsMutex.RLock()
	defer fake.jSONArrTrimWithArgsMutex.RUnlock()
	return len(fake.jSONArrTrimWithArgsArgsForCall)
}

func (fake *FakeClient) JSONArrTrimWithArgsCalls(stub func(context.Context, string, string, *redisa.JSONArrTrimArgs) *redisa.IntSliceCmd) {
	fake.jSONArrTrimWithArgsMutex.Lock()
	defer fake.jSONArrTrimWithArgsMutex.Unlock()
	fake.JSONArrTrimWithArgsStub = stub
}

func (fake *FakeClient) JSONArrTrimWithArgsArgsForCall(i int) (context.Context, string, string, *redisa.JSONArrTrimArgs) {
	fake.jSONArrTrimWithArgsMutex.RLock()
	defer fake.jSONArrTrimWithArgsMutex.RUnlock()
	argsForCall := fake.jSONArrTrimWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) JSONArrTrimWithArgsReturns(result1 *redisa.IntSliceCmd) {
	fake.jSONArrTrimWithArgsMutex.Lock()
	defer fake.jSONArrTrimWithArgsMutex.Unlock()
	fake.JSONArrTrimWithArgsStub = nil
	fake.jSONArrTrimWithArgsReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONArrTrimWithArgsReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.jSONArrTrimWithArgsMutex.Lock()
	defer fake.jSONArrTrimWithArgsMutex.Unlock()
	fake.JSONArrTrimWithArgsStub = nil
	if fake.jSONArrTrimWithArgsReturnsOnCall == nil {
		fake.jSONArrTrimWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.jSONArrTrimWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONClear(arg1 context.Context, arg2 string, arg3 string) *redisa.IntCmd {
	fake.jSONClearMutex.Lock()
	ret, specificReturn := fake.jSONClearReturnsOnCall[len(fake.jSONClearArgsForCall)]
	fake.jSONClearArgsForCall = append(fake.jSONClearArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.JSONClearStub
	fakeReturns := fake.jSONClearReturns
	fake.recordInvocation("JSONClear", []interface{}{arg1, arg2, arg3})
	fake.jSONClearMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONClearCallCount() int {
	fake.jSONClearMutex.RLock()
	defer fake.jSONClearMutex.RUnlock()
	return len(fake.jSONClearArgsForCall)
}

func (fake *FakeClient) JSONClearCalls(stub func(context.Context, string, string) *redisa.IntCmd) {
	fake.jSONClearMutex.Lock()
	defer fake.jSONClearMutex.Unlock()
	fake.JSONClearStub = stub
}

func (fake *FakeClient) JSONClearArgsForCall(i int) (context.Context, string, string) {
	fake.jSONClearMutex.RLock()
	defer fake.jSONClearMutex.RUnlock()
	argsForCall := fake.jSONClearArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) JSONClearReturns(result1 *redisa.IntCmd) {
	fake.jSONClearMutex.Lock()
	defer fake.jSONClearMutex.Unlock()
	fake.JSONClearStub = nil
	fake.jSONClearReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) JSONClearReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.jSONClearMutex.Lock()
	defer fake.jSONClearMutex.Unlock()
	fake.JSONClearStub = nil
	if fake.jSONClearReturnsOnCall == nil {
		fake.jSONClearReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.jSONClearReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) JSONDebugMemory(arg1 context.Context, arg2 string, arg3 string) *redisa.IntCmd {
	fake.jSONDebugMemoryMutex.Lock()
	ret, specificReturn := fake.jSONDebugMemoryReturnsOnCall[len(fake.jSONDebugMemoryArgsForCall)]
	fake.jSONDebugMemoryArgsForCall = append(fake.jSONDebugMemoryArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.JSONDebugMemoryStub
	fakeReturns := fake.jSONDebugMemoryReturns
	fake.recordInvocation("JSONDebugMemory", []interface{}{arg1, arg2, arg3})
	fake.jSONDebugMemoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONDebugMemoryCallCount() int {
	fake.jSONDebugMemoryMutex.RLock()
	defer fake.jSONDebugMemoryMutex.RUnlock()
	return len(fake.jSONDebugMemoryArgsForCall)
}

func (fake *FakeClient) JSONDebugMemoryCalls(stub func(context.Context, string, string) *redisa.IntCmd) {
	fake.jSONDebugMemoryMutex.Lock()
	defer fake.jSONDebugMemoryMutex.Unlock()
	fake.JSONDebugMemoryStub = stub
}

func (fake *FakeClient) JSONDebugMemoryArgsForCall(i int) (context.Context, string, string) {
	fake.jSONDebugMemoryMutex.RLock()
	defer fake.jSONDebugMemoryMutex.RUnlock()
	argsForCall := fake.jSONDebugMemoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) JSONDebugMemoryReturns(result1 *redisa.IntCmd) {
	fake.jSONDebugMemoryMutex.Lock()
	defer fake.jSONDebugMemoryMutex.Unlock()
	fake.JSONDebugMemoryStub = nil
	fake.jSONDebugMemoryReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) JSONDebugMemoryReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.jSONDebugMemoryMutex.Lock()
	defer fake.jSONDebugMemoryMutex.Unlock()
	fake.JSONDebugMemoryStub = nil
	if fake.jSONDebugMemoryReturnsOnCall == nil {
		fake.jSONDebugMemoryReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.jSONDebugMemoryReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) JSONDel(arg1 context.Context, arg2 string, arg3 string) *redisa.IntCmd {
	fake.jSONDelMutex.Lock()
	ret, specificReturn := fake.jSONDelReturnsOnCall[len(fake.jSONDelArgsForCall)]
	fake.jSONDelArgsForCall = append(fake.jSONDelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.JSONDelStub
	fakeReturns := fake.jSONDelReturns
	fake.recordInvocation("JSONDel", []interface{}{arg1, arg2, arg3})
	fake.jSONDelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONDelCallCount() int {
	fake.jSONDelMutex.RLock()
	defer fake.jSONDelMutex.RUnlock()
	return len(fake.jSONDelArgsForCall)
}

func (fake *FakeClient) JSONDelCalls(stub func(context.Context, string, string) *redisa.IntCmd) {
	fake.jSONDelMutex.Lock()
	defer fake.jSONDelMutex.Unlock()
	fake.JSONDelStub = stub
}

func (fake *FakeClient) JSONDelArgsForCall(i int) (context.Context, string, string) {
	fake.jSONDelMutex.RLock()
	defer fake.jSONDelMutex.RUnlock()
	argsForCall := fake.jSONDelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) JSONDelReturns(result1 *redisa.IntCmd) {
	fake.jSONDelMutex.Lock()
	defer fake.jSONDelMutex.Unlock()
	fake.JSONDelStub = nil
	fake.jSONDelReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) JSONDelReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.jSONDelMutex.Lock()
	defer fake.jSONDelMutex.Unlock()
	fake.JSONDelStub = nil
	if fake.jSONDelReturnsOnCall == nil {
		fake.jSONDelReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.jSONDelReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) JSONForget(arg1 context.Context, arg2 string, arg3 string) *redisa.IntCmd {
	fake.jSONForgetMutex.Lock()
	ret, specificReturn := fake.jSONForgetReturnsOnCall[len(fake.jSONForgetArgsForCall)]
	fake.jSONForgetArgsForCall = append(fake.jSONForgetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.JSONForgetStub
	fakeReturns := fake.jSONForgetReturns
	fake.recordInvocation("JSONForget", []interface{}{arg1, arg2, arg3})
	fake.jSONForgetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONForgetCallCount() int {
	fake.jSONForgetMutex.RLock()
	defer fake.jSONForgetMutex.RUnlock()
	return len(fake.jSONForgetArgsForCall)
}

func (fake *FakeClient) JSONForgetCalls(stub func(context.Context, string, string) *redisa.IntCmd) {
	fake.jSONForgetMutex.Lock()
	defer fake.jSONForgetMutex.Unlock()
	fake.JSONForgetStub = stub
}

func (fake *FakeClient) JSONForgetArgsForCall(i int) (context.Context, string, string) {
	fake.jSONForgetMutex.RLock()
	defer fake.jSONForgetMutex.RUnlock()
	argsForCall := fake.jSONForgetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) JSONForgetReturns(result1 *redisa.IntCmd) {
	fake.jSONForgetMutex.Lock()
	defer fake.jSONForgetMutex.Unlock()
	fake.JSONForgetStub = nil
	fake.jSONForgetReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) JSONForgetReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.jSONForgetMutex.Lock()
	defer fake.jSONForgetMutex.Unlock()
	fake.JSONForgetStub = nil
	if fake.jSONForgetReturnsOnCall == nil {
		fake.jSONForgetReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.jSONForgetReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) JSONGet(arg1 context.Context, arg2 string, arg3 ...string) *redisa.JSONCmd {
	fake.jSONGetMutex.Lock()
	ret, specificReturn := fake.jSONGetReturnsOnCall[len(fake.jSONGetArgsForCall)]
	fake.jSONGetArgsForCall = append(fake.jSONGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.JSONGetStub
	fakeReturns := fake.jSONGetReturns
	fake.recordInvocation("JSONGet", []interface{}{arg1, arg2, arg3})
	fake.jSONGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONGetCallCount() int {
	fake.jSONGetMutex.RLock()
	defer fake.jSONGetMutex.RUnlock()
	return len(fake.jSONGetArgsForCall)
}

func (fake *FakeClient) JSONGetCalls(stub func(context.Context, string, ...string) *redisa.JSONCmd) {
	fake.jSONGetMutex.Lock()
	defer fake.jSONGetMutex.Unlock()
	fake.JSONGetStub = stub
}

func (fake *FakeClient) JSONGetArgsForCall(i int) (context.Context, string, []string) {
	fake.jSONGetMutex.RLock()
	defer fake.jSONGetMutex.RUnlock()
	argsForCall := fake.jSONGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) JSONGetReturns(result1 *redisa.JSONCmd) {
	fake.jSONGetMutex.Lock()
	defer fake.jSONGetMutex.Unlock()
	fake.JSONGetStub = nil
	fake.jSONGetReturns = struct {
		result1 *redisa.JSONCmd
	}{result1}
}

func (fake *FakeClient) JSONGetReturnsOnCall(i int, result1 *redisa.JSONCmd) {
	fake.jSONGetMutex.Lock()
	defer fake.jSONGetMutex.Unlock()
	fake.JSONGetStub = nil
	if fake.jSONGetReturnsOnCall == nil {
		fake.jSONGetReturnsOnCall = make(map[int]struct {
			result1 *redisa.JSONCmd
		})
	}
	fake.jSONGetReturnsOnCall[i] = struct {
		result1 *redisa.JSONCmd
	}{result1}
}

func (fake *FakeClient) JSONGetWithArgs(arg1 context.Context, arg2 string, arg3 *redisa.JSONGetArgs, arg4 ...string) *redisa.JSONCmd {
	fake.jSONGetWithArgsMutex.Lock()
	ret, specificReturn := fake.jSONGetWithArgsReturnsOnCall[len(fake.jSONGetWithArgsArgsForCall)]
	fake.jSONGetWithArgsArgsForCall = append(fake.jSONGetWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.JSONGetArgs
		arg4 []string
	}{arg1, arg2, arg3, arg4})
	stub := fake.JSONGetWithArgsStub
	fakeReturns := fake.jSONGetWithArgsReturns
	fake.recordInvocation("JSONGetWithArgs", []interface{}{arg1, arg2, arg3, arg4})
	fake.jSONGetWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONGetWithArgsCallCount() int {
	fake.jSONGetWithArgsMutex.RLock()
	defer fake.jSONGetWithArgsMutex.RUnlock()
	return len(fake.jSONGetWithArgsArgsForCall)
}

func (fake *FakeClient) JSONGetWithArgsCalls(stub func(context.Context, string, *redisa.JSONGetArgs, ...string) *redisa.JSONCmd) {
	fake.jSONGetWithArgsMutex.Lock()
	defer fake.jSONGetWithArgsMutex.Unlock()
	fake.JSONGetWithArgsStub = stub
}

func (fake *FakeClient) JSONGetWithArgsArgsForCall(i int) (context.Context, string, *redisa.JSONGetArgs, []string) {
	fake.jSONGetWithArgsMutex.RLock()
	defer fake.jSONGetWithArgsMutex.RUnlock()
	argsForCall := fake.jSONGetWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) JSONGetWithArgsReturns(result1 *redisa.JSONCmd) {
	fake.jSONGetWithArgsMutex.Lock()
	defer fake.jSONGetWithArgsMutex.Unlock()
	fake.JSONGetWithArgsStub = nil
	fake.jSONGetWithArgsReturns = struct {
		result1 *redisa.JSONCmd
	}{result1}
}

func (fake *FakeClient) JSONGetWithArgsReturnsOnCall(i int, result1 *redisa.JSONCmd) {
	fake.jSONGetWithArgsMutex.Lock()
	defer fake.jSONGetWithArgsMutex.Unlock()
	fake.JSONGetWithArgsStub = nil
	if fake.jSONGetWithArgsReturnsOnCall == nil {
		fake.jSONGetWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.JSONCmd
		})
	}
	fake.jSONGetWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.JSONCmd
	}{result1}
}

func (fake *FakeClient) JSONMGet(arg1 context.Context, arg2 string, arg3 ...string) *redisa.JSONSliceCmd {
	fake.jSONMGetMutex.Lock()
	ret, specificReturn := fake.jSONMGetReturnsOnCall[len(fake.jSONMGetArgsForCall)]
	fake.jSONMGetArgsForCall = append(fake.jSONMGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.JSONMGetStub
	fakeReturns := fake.jSONMGetReturns
	fake.recordInvocation("JSONMGet", []interface{}{arg1, arg2, arg3})
	fake.jSONMGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONMGetCallCount() int {
	fake.jSONMGetMutex.RLock()
	defer fake.jSONMGetMutex.RUnlock()
	return len(fake.jSONMGetArgsForCall)
}

func (fake *FakeClient) JSONMGetCalls(stub func(context.Context, string, ...string) *redisa.JSONSliceCmd) {
	fake.jSONMGetMutex.Lock()
	defer fake.jSONMGetMutex.Unlock()
	fake.JSONMGetStub = stub
}

func (fake *FakeClient) JSONMGetArgsForCall(i int) (context.Context, string, []string) {
	fake.jSONMGetMutex.RLock()
	defer fake.jSONMGetMutex.RUnlock()
	argsForCall := fake.jSONMGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) JSONMGetReturns(result1 *redisa.JSONSliceCmd) {
	fake.jSONMGetMutex.Lock()
	defer fake.jSONMGetMutex.Unlock()
	fake.JSONMGetStub = nil
	fake.jSONMGetReturns = struct {
		result1 *redisa.JSONSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONMGetReturnsOnCall(i int, result1 *redisa.JSONSliceCmd) {
	fake.jSONMGetMutex.Lock()
	defer fake.jSONMGetMutex.Unlock()
	fake.JSONMGetStub = nil
	if fake.jSONMGetReturnsOnCall == nil {
		fake.jSONMGetReturnsOnCall = make(map[int]struct {
			result1 *redisa.JSONSliceCmd
		})
	}
	fake.jSONMGetReturnsOnCall[i] = struct {
		result1 *redisa.JSONSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONMSet(arg1 context.Context, arg2 ...interface{}) *redisa.StatusCmd {
	fake.jSONMSetMutex.Lock()
	ret, specificReturn := fake.jSONMSetReturnsOnCall[len(fake.jSONMSetArgsForCall)]
	fake.jSONMSetArgsForCall = append(fake.jSONMSetArgsForCall, struct {
		arg1 context.Context
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.JSONMSetStub
	fakeReturns := fake.jSONMSetReturns
	fake.recordInvocation("JSONMSet", []interface{}{arg1, arg2})
	fake.jSONMSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONMSetCallCount() int {
	fake.jSONMSetMutex.RLock()
	defer fake.jSONMSetMutex.RUnlock()
	return len(fake.jSONMSetArgsForCall)
}

func (fake *FakeClient) JSONMSetCalls(stub func(context.Context, ...interface{}) *redisa.StatusCmd) {
	fake.jSONMSetMutex.Lock()
	defer fake.jSONMSetMutex.Unlock()
	fake.JSONMSetStub = stub
}

func (fake *FakeClient) JSONMSetArgsForCall(i int) (context.Context, []interface{}) {
	fake.jSONMSetMutex.RLock()
	defer fake.jSONMSetMutex.RUnlock()
	argsForCall := fake.jSONMSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) JSONMSetReturns(result1 *redisa.StatusCmd) {
	fake.jSONMSetMutex.Lock()
	defer fake.jSONMSetMutex.Unlock()
	fake.JSONMSetStub = nil
	fake.jSONMSetReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) JSONMSetReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.jSONMSetMutex.Lock()
	defer fake.jSONMSetMutex.Unlock()
	fake.JSONMSetStub = nil
	if fake.jSONMSetReturnsOnCall == nil {
		fake.jSONMSetReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.jSONMSetReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) JSONMSetArgs(arg1 context.Context, arg2 []redisa.JSONSetArgs) *redisa.StatusCmd {
	var arg2Copy []redisa.JSONSetArgs
	if arg2 != nil {
		arg2Copy = make([]redisa.JSONSetArgs, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.jSONMSetArgsMutex.Lock()
	ret, specificReturn := fake.jSONMSetArgsReturnsOnCall[len(fake.jSONMSetArgsArgsForCall)]
	fake.jSONMSetArgsArgsForCall = append(fake.jSONMSetArgsArgsForCall, struct {
		arg1 context.Context
		arg2 []redisa.JSONSetArgs
	}{arg1, arg2Copy})
	stub := fake.JSONMSetArgsStub
	fakeReturns := fake.jSONMSetArgsReturns
	fake.recordInvocation("JSONMSetArgs", []interface{}{arg1, arg2Copy})
	fake.jSONMSetArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONMSetArgsCallCount() int {
	fake.jSONMSetArgsMutex.RLock()
	defer fake.jSONMSetArgsMutex.RUnlock()
	return len(fake.jSONMSetArgsArgsForCall)
}

func (fake *FakeClient) JSONMSetArgsCalls(stub func(context.Context, []redisa.JSONSetArgs) *redisa.StatusCmd) {
	fake.jSONMSetArgsMutex.Lock()
	defer fake.jSONMSetArgsMutex.Unlock()
	fake.JSONMSetArgsStub = stub
}

func (fake *FakeClient) JSONMSetArgsArgsForCall(i int) (context.Context, []redisa.JSONSetArgs) {
	fake.jSONMSetArgsMutex.RLock()
	defer fake.jSONMSetArgsMutex.RUnlock()
	argsForCall := fake.jSONMSetArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) JSONMSetArgsReturns(result1 *redisa.StatusCmd) {
	fake.jSONMSetArgsMutex.Lock()
	defer fake.jSONMSetArgsMutex.Unlock()
	fake.JSONMSetArgsStub = nil
	fake.jSONMSetArgsReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) JSONMSetArgsReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.jSONMSetArgsMutex.Lock()
	defer fake.jSONMSetArgsMutex.Unlock()
	fake.JSONMSetArgsStub = nil
	if fake.jSONMSetArgsReturnsOnCall == nil {
		fake.jSONMSetArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.jSONMSetArgsReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) JSONMerge(arg1 context.Context, arg2 string, arg3 string, arg4 string) *redisa.StatusCmd {
	fake.jSONMergeMutex.Lock()
	ret, specificReturn := fake.jSONMergeReturnsOnCall[len(fake.jSONMergeArgsForCall)]
	fake.jSONMergeArgsForCall = append(fake.jSONMergeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.JSONMergeStub
	fakeReturns := fake.jSONMergeReturns
	fake.recordInvocation("JSONMerge", []interface{}{arg1, arg2, arg3, arg4})
	fake.jSONMergeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONMergeCallCount() int {
	fake.jSONMergeMutex.RLock()
	defer fake.jSONMergeMutex.RUnlock()
	return len(fake.jSONMergeArgsForCall)
}

func (fake *FakeClient) JSONMergeCalls(stub func(context.Context, string, string, string) *redisa.StatusCmd) {
	fake.jSONMergeMutex.Lock()
	defer fake.jSONMergeMutex.Unlock()
	fake.JSONMergeStub = stub
}

func (fake *FakeClient) JSONMergeArgsForCall(i int) (context.Context, string, string, string) {
	fake.jSONMergeMutex.RLock()
	defer fake.jSONMergeMutex.RUnlock()
	argsForCall := fake.jSONMergeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) JSONMergeReturns(result1 *redisa.StatusCmd) {
	fake.jSONMergeMutex.Lock()
	defer fake.jSONMergeMutex.Unlock()
	fake.JSONMergeStub = nil
	fake.jSONMergeReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) JSONMergeReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.jSONMergeMutex.Lock()
	defer fake.jSONMergeMutex.Unlock()
	fake.JSONMergeStub = nil
	if fake.jSONMergeReturnsOnCall == nil {
		fake.jSONMergeReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.jSONMergeReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) JSONNumIncrBy(arg1 context.Context, arg2 string, arg3 string, arg4 float64) *redisa.JSONCmd {
	fake.jSONNumIncrByMutex.Lock()
	ret, specificReturn := fake.jSONNumIncrByReturnsOnCall[len(fake.jSONNumIncrByArgsForCall)]
	fake.jSONNumIncrByArgsForCall = append(fake.jSONNumIncrByArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 float64
	}{arg1, arg2, arg3, arg4})
	stub := fake.JSONNumIncrByStub
	fakeReturns := fake.jSONNumIncrByReturns
	fake.recordInvocation("JSONNumIncrBy", []interface{}{arg1, arg2, arg3, arg4})
	fake.jSONNumIncrByMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONNumIncrByCallCount() int {
	fake.jSONNumIncrByMutex.RLock()
	defer fake.jSONNumIncrByMutex.RUnlock()
	return len(fake.jSONNumIncrByArgsForCall)
}

func (fake *FakeClient) JSONNumIncrByCalls(stub func(context.Context, string, string, float64) *redisa.JSONCmd) {
	fake.jSONNumIncrByMutex.Lock()
	defer fake.jSONNumIncrByMutex.Unlock()
	fake.JSONNumIncrByStub = stub
}

func (fake *FakeClient) JSONNumIncrByArgsForCall(i int) (context.Context, string, string, float64) {
	fake.jSONNumIncrByMutex.RLock()
	defer fake.jSONNumIncrByMutex.RUnlock()
	argsForCall := fake.jSONNumIncrByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) JSONNumIncrByReturns(result1 *redisa.JSONCmd) {
	fake.jSONNumIncrByMutex.Lock()
	defer fake.jSONNumIncrByMutex.Unlock()
	fake.JSONNumIncrByStub = nil
	fake.jSONNumIncrByReturns = struct {
		result1 *redisa.JSONCmd
	}{result1}
}

func (fake *FakeClient) JSONNumIncrByReturnsOnCall(i int, result1 *redisa.JSONCmd) {
	fake.jSONNumIncrByMutex.Lock()
	defer fake.jSONNumIncrByMutex.Unlock()
	fake.JSONNumIncrByStub = nil
	if fake.jSONNumIncrByReturnsOnCall == nil {
		fake.jSONNumIncrByReturnsOnCall = make(map[int]struct {
			result1 *redisa.JSONCmd
		})
	}
	fake.jSONNumIncrByReturnsOnCall[i] = struct {
		result1 *redisa.JSONCmd
	}{result1}
}

func (fake *FakeClient) JSONObjKeys(arg1 context.Context, arg2 string, arg3 string) *redisa.SliceCmd {
	fake.jSONObjKeysMutex.Lock()
	ret, specificReturn := fake.jSONObjKeysReturnsOnCall[len(fake.jSONObjKeysArgsForCall)]
	fake.jSONObjKeysArgsForCall = append(fake.jSONObjKeysArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.JSONObjKeysStub
	fakeReturns := fake.jSONObjKeysReturns
	fake.recordInvocation("JSONObjKeys", []interface{}{arg1, arg2, arg3})
	fake.jSONObjKeysMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONObjKeysCallCount() int {
	fake.jSONObjKeysMutex.RLock()
	defer fake.jSONObjKeysMutex.RUnlock()
	return len(fake.jSONObjKeysArgsForCall)
}

func (fake *FakeClient) JSONObjKeysCalls(stub func(context.Context, string, string) *redisa.SliceCmd) {
	fake.jSONObjKeysMutex.Lock()
	defer fake.jSONObjKeysMutex.Unlock()
	fake.JSONObjKeysStub = stub
}

func (fake *FakeClient) JSONObjKeysArgsForCall(i int) (context.Context, string, string) {
	fake.jSONObjKeysMutex.RLock()
	defer fake.jSONObjKeysMutex.RUnlock()
	argsForCall := fake.jSONObjKeysArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) JSONObjKeysReturns(result1 *redisa.SliceCmd) {
	fake.jSONObjKeysMutex.Lock()
	defer fake.jSONObjKeysMutex.Unlock()
	fake.JSONObjKeysStub = nil
	fake.jSONObjKeysReturns = struct {
		result1 *redisa.SliceCmd
	}{result1}
}

func (fake *FakeClient) JSONObjKeysReturnsOnCall(i int, result1 *redisa.SliceCmd) {
	fake.jSONObjKeysMutex.Lock()
	defer fake.jSONObjKeysMutex.Unlock()
	fake.JSONObjKeysStub = nil
	if fake.jSONObjKeysReturnsOnCall == nil {
		fake.jSONObjKeysReturnsOnCall = make(map[int]struct {
			result1 *redisa.SliceCmd
		})
	}
	fake.jSONObjKeysReturnsOnCall[i] = struct {
		result1 *redisa.SliceCmd
	}{result1}
}

func (fake *FakeClient) JSONObjLen(arg1 context.Context, arg2 string, arg3 string) *redisa.IntPointerSliceCmd {
	fake.jSONObjLenMutex.Lock()
	ret, specificReturn := fake.jSONObjLenReturnsOnCall[len(fake.jSONObjLenArgsForCall)]
	fake.jSONObjLenArgsForCall = append(fake.jSONObjLenArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.JSONObjLenStub
	fakeReturns := fake.jSONObjLenReturns
	fake.recordInvocation("JSONObjLen", []interface{}{arg1, arg2, arg3})
	fake.jSONObjLenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONObjLenCallCount() int {
	fake.jSONObjLenMutex.RLock()
	defer fake.jSONObjLenMutex.RUnlock()
	return len(fake.jSONObjLenArgsForCall)
}

func (fake *FakeClient) JSONObjLenCalls(stub func(context.Context, string, string) *redisa.IntPointerSliceCmd) {
	fake.jSONObjLenMutex.Lock()
	defer fake.jSONObjLenMutex.Unlock()
	fake.JSONObjLenStub = stub
}

func (fake *FakeClient) JSONObjLenArgsForCall(i int) (context.Context, string, string) {
	fake.jSONObjLenMutex.RLock()
	defer fake.jSONObjLenMutex.RUnlock()
	argsForCall := fake.jSONObjLenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) JSONObjLenReturns(result1 *redisa.IntPointerSliceCmd) {
	fake.jSONObjLenMutex.Lock()
	defer fake.jSONObjLenMutex.Unlock()
	fake.JSONObjLenStub = nil
	fake.jSONObjLenReturns = struct {
		result1 *redisa.IntPointerSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONObjLenReturnsOnCall(i int, result1 *redisa.IntPointerSliceCmd) {
	fake.jSONObjLenMutex.Lock()
	defer fake.jSONObjLenMutex.Unlock()
	fake.JSONObjLenStub = nil
	if fake.jSONObjLenReturnsOnCall == nil {
		fake.jSONObjLenReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntPointerSliceCmd
		})
	}
	fake.jSONObjLenReturnsOnCall[i] = struct {
		result1 *redisa.IntPointerSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONSet(arg1 context.Context, arg2 string, arg3 string, arg4 interface{}) *redisa.StatusCmd {
	fake.jSONSetMutex.Lock()
	ret, specificReturn := fake.jSONSetReturnsOnCall[len(fake.jSONSetArgsForCall)]
	fake.jSONSetArgsForCall = append(fake.jSONSetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.JSONSetStub
	fakeReturns := fake.jSONSetReturns
	fake.recordInvocation("JSONSet", []interface{}{arg1, arg2, arg3, arg4})
	fake.jSONSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONSetCallCount() int {
	fake.jSONSetMutex.RLock()
	defer fake.jSONSetMutex.RUnlock()
	return len(fake.jSONSetArgsForCall)
}

func (fake *FakeClient) JSONSetCalls(stub func(context.Context, string, string, interface{}) *redisa.StatusCmd) {
	fake.jSONSetMutex.Lock()
	defer fake.jSONSetMutex.Unlock()
	fake.JSONSetStub = stub
}

func (fake *FakeClient) JSONSetArgsForCall(i int) (context.Context, string, string, interface{}) {
	fake.jSONSetMutex.RLock()
	defer fake.jSONSetMutex.RUnlock()
	argsForCall := fake.jSONSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) JSONSetReturns(result1 *redisa.StatusCmd) {
	fake.jSONSetMutex.Lock()
	defer fake.jSONSetMutex.Unlock()
	fake.JSONSetStub = nil
	fake.jSONSetReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) JSONSetReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.jSONSetMutex.Lock()
	defer fake.jSONSetMutex.Unlock()
	fake.JSONSetStub = nil
	if fake.jSONSetReturnsOnCall == nil {
		fake.jSONSetReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.jSONSetReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) JSONSetMode(arg1 context.Context, arg2 string, arg3 string, arg4 interface{}, arg5 string) *redisa.StatusCmd {
	fake.jSONSetModeMutex.Lock()
	ret, specificReturn := fake.jSONSetModeReturnsOnCall[len(fake.jSONSetModeArgsForCall)]
	fake.jSONSetModeArgsForCall = append(fake.jSONSetModeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 interface{}
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.JSONSetModeStub
	fakeReturns := fake.jSONSetModeReturns
	fake.recordInvocation("JSONSetMode", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.jSONSetModeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONSetModeCallCount() int {
	fake.jSONSetModeMutex.RLock()
	defer fake.jSONSetModeMutex.RUnlock()
	return len(fake.jSONSetModeArgsForCall)
}

func (fake *FakeClient) JSONSetModeCalls(stub func(context.Context, string, string, interface{}, string) *redisa.StatusCmd) {
	fake.jSONSetModeMutex.Lock()
	defer fake.jSONSetModeMutex.Unlock()
	fake.JSONSetModeStub = stub
}

func (fake *FakeClient) JSONSetModeArgsForCall(i int) (context.Context, string, string, interface{}, string) {
	fake.jSONSetModeMutex.RLock()
	defer fake.jSONSetModeMutex.RUnlock()
	argsForCall := fake.jSONSetModeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) JSONSetModeReturns(result1 *redisa.StatusCmd) {
	fake.jSONSetModeMutex.Lock()
	defer fake.jSONSetModeMutex.Unlock()
	fake.JSONSetModeStub = nil
	fake.jSONSetModeReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) JSONSetModeReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.jSONSetModeMutex.Lock()
	defer fake.jSONSetModeMutex.Unlock()
	fake.JSONSetModeStub = nil
	if fake.jSONSetModeReturnsOnCall == nil {
		fake.jSONSetModeReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.jSONSetModeReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) JSONStrAppend(arg1 context.Context, arg2 string, arg3 string, arg4 string) *redisa.IntPointerSliceCmd {
	fake.jSONStrAppendMutex.Lock()
	ret, specificReturn := fake.jSONStrAppendReturnsOnCall[len(fake.jSONStrAppendArgsForCall)]
	fake.jSONStrAppendArgsForCall = append(fake.jSONStrAppendArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.JSONStrAppendStub
	fakeReturns := fake.jSONStrAppendReturns
	fake.recordInvocation("JSONStrAppend", []interface{}{arg1, arg2, arg3, arg4})
	fake.jSONStrAppendMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONStrAppendCallCount() int {
	fake.jSONStrAppendMutex.RLock()
	defer fake.jSONStrAppendMutex.RUnlock()
	return len(fake.jSONStrAppendArgsForCall)
}

func (fake *FakeClient) JSONStrAppendCalls(stub func(context.Context, string, string, string) *redisa.IntPointerSliceCmd) {
	fake.jSONStrAppendMutex.Lock()
	defer fake.jSONStrAppendMutex.Unlock()
	fake.JSONStrAppendStub = stub
}

func (fake *FakeClient) JSONStrAppendArgsForCall(i int) (context.Context, string, string, string) {
	fake.jSONStrAppendMutex.RLock()
	defer fake.jSONStrAppendMutex.RUnlock()
	argsForCall := fake.jSONStrAppendArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) JSONStrAppendReturns(result1 *redisa.IntPointerSliceCmd) {
	fake.jSONStrAppendMutex.Lock()
	defer fake.jSONStrAppendMutex.Unlock()
	fake.JSONStrAppendStub = nil
	fake.jSONStrAppendReturns = struct {
		result1 *redisa.IntPointerSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONStrAppendReturnsOnCall(i int, result1 *redisa.IntPointerSliceCmd) {
	fake.jSONStrAppendMutex.Lock()
	defer fake.jSONStrAppendMutex.Unlock()
	fake.JSONStrAppendStub = nil
	if fake.jSONStrAppendReturnsOnCall == nil {
		fake.jSONStrAppendReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntPointerSliceCmd
		})
	}
	fake.jSONStrAppendReturnsOnCall[i] = struct {
		result1 *redisa.IntPointerSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONStrLen(arg1 context.Context, arg2 string, arg3 string) *redisa.IntPointerSliceCmd {
	fake.jSONStrLenMutex.Lock()
	ret, specificReturn := fake.jSONStrLenReturnsOnCall[len(fake.jSONStrLenArgsForCall)]
	fake.jSONStrLenArgsForCall = append(fake.jSONStrLenArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.JSONStrLenStub
	fakeReturns := fake.jSONStrLenReturns
	fake.recordInvocation("JSONStrLen", []interface{}{arg1, arg2, arg3})
	fake.jSONStrLenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONStrLenCallCount() int {
	fake.jSONStrLenMutex.RLock()
	defer fake.jSONStrLenMutex.RUnlock()
	return len(fake.jSONStrLenArgsForCall)
}

func (fake *FakeClient) JSONStrLenCalls(stub func(context.Context, string, string) *redisa.IntPointerSliceCmd) {
	fake.jSONStrLenMutex.Lock()
	defer fake.jSONStrLenMutex.Unlock()
	fake.JSONStrLenStub = stub
}

func (fake *FakeClient) JSONStrLenArgsForCall(i int) (context.Context, string, string) {
	fake.jSONStrLenMutex.RLock()
	defer fake.jSONStrLenMutex.RUnlock()
	argsForCall := fake.jSONStrLenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) JSONStrLenReturns(result1 *redisa.IntPointerSliceCmd) {
	fake.jSONStrLenMutex.Lock()
	defer fake.jSONStrLenMutex.Unlock()
	fake.JSONStrLenStub = nil
	fake.jSONStrLenReturns = struct {
		result1 *redisa.IntPointerSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONStrLenReturnsOnCall(i int, result1 *redisa.IntPointerSliceCmd) {
	fake.jSONStrLenMutex.Lock()
	defer fake.jSONStrLenMutex.Unlock()
	fake.JSONStrLenStub = nil
	if fake.jSONStrLenReturnsOnCall == nil {
		fake.jSONStrLenReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntPointerSliceCmd
		})
	}
	fake.jSONStrLenReturnsOnCall[i] = struct {
		result1 *redisa.IntPointerSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONToggle(arg1 context.Context, arg2 string, arg3 string) *redisa.IntPointerSliceCmd {
	fake.jSONToggleMutex.Lock()
	ret, specificReturn := fake.jSONToggleReturnsOnCall[len(fake.jSONToggleArgsForCall)]
	fake.jSONToggleArgsForCall = append(fake.jSONToggleArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.JSONToggleStub
	fakeReturns := fake.jSONToggleReturns
	fake.recordInvocation("JSONToggle", []interface{}{arg1, arg2, arg3})
	fake.jSONToggleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONToggleCallCount() int {
	fake.jSONToggleMutex.RLock()
	defer fake.jSONToggleMutex.RUnlock()
	return len(fake.jSONToggleArgsForCall)
}

func (fake *FakeClient) JSONToggleCalls(stub func(context.Context, string, string) *redisa.IntPointerSliceCmd) {
	fake.jSONToggleMutex.Lock()
	defer fake.jSONToggleMutex.Unlock()
	fake.JSONToggleStub = stub
}

func (fake *FakeClient) JSONToggleArgsForCall(i int) (context.Context, string, string) {
	fake.jSONToggleMutex.RLock()
	defer fake.jSONToggleMutex.RUnlock()
	argsForCall := fake.jSONToggleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) JSONToggleReturns(result1 *redisa.IntPointerSliceCmd) {
	fake.jSONToggleMutex.Lock()
	defer fake.jSONToggleMutex.Unlock()
	fake.JSONToggleStub = nil
	fake.jSONToggleReturns = struct {
		result1 *redisa.IntPointerSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONToggleReturnsOnCall(i int, result1 *redisa.IntPointerSliceCmd) {
	fake.jSONToggleMutex.Lock()
	defer fake.jSONToggleMutex.Unlock()
	fake.JSONToggleStub = nil
	if fake.jSONToggleReturnsOnCall == nil {
		fake.jSONToggleReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntPointerSliceCmd
		})
	}
	fake.jSONToggleReturnsOnCall[i] = struct {
		result1 *redisa.IntPointerSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONType(arg1 context.Context, arg2 string, arg3 string) *redisa.JSONSliceCmd {
	fake.jSONTypeMutex.Lock()
	ret, specificReturn := fake.jSONTypeReturnsOnCall[len(fake.jSONTypeArgsForCall)]
	fake.jSONTypeArgsForCall = append(fake.jSONTypeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.JSONTypeStub
	fakeReturns := fake.jSONTypeReturns
	fake.recordInvocation("JSONType", []interface{}{arg1, arg2, arg3})
	fake.jSONTypeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONTypeCallCount() int {
	fake.jSONTypeMutex.RLock()
	defer fake.jSONTypeMutex.RUnlock()
	return len(fake.jSONTypeArgsForCall)
}

func (fake *FakeClient) JSONTypeCalls(stub func(context.Context, string, string) *redisa.JSONSliceCmd) {
	fake.jSONTypeMutex.Lock()
	defer fake.jSONTypeMutex.Unlock()
	fake.JSONTypeStub = stub
}

func (fake *FakeClient) JSONTypeArgsForCall(i int) (context.Context, string, string) {
	fake.jSONTypeMutex.RLock()
	defer fake.jSONTypeMutex.RUnlock()
	argsForCall := fake.jSONTypeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) JSONTypeReturns(result1 *redisa.JSONSliceCmd) {
	fake.jSONTypeMutex.Lock()
	defer fake.jSONTypeMutex.Unlock()
	fake.JSONTypeStub = nil
	fake.jSONTypeReturns = struct {
		result1 *redisa.JSONSliceCmd
	}{result1}
}

func (fake *FakeClient) JSONTypeReturnsOnCall(i int, result1 *redisa.JSONSliceCmd) {
	fake.jSONTypeMutex.Lock()
	defer fake.jSONTypeMutex.Unlock()
	fake.JSONTypeStub = nil
	if fake.jSONTypeReturnsOnCall == nil {
		fake.jSONTypeReturnsOnCall = make(map[int]struct {
			result1 *redisa.JSONSliceCmd
		})
	}
	fake.jSONTypeReturnsOnCall[i] = struct {
		result1 *redisa.JSONSliceCmd
	}{result1}
}

func (fake *FakeClient) Keys(arg1 context.Context, arg2 string) *redisa.StringSliceCmd {
	fake.keysMutex.Lock()
	ret, specificReturn := fake.keysReturnsOnCall[len(fake.keysArgsForCall)]
	fake.keysArgsForCall = append(fake.keysArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.KeysStub
	fakeReturns := fake.keysReturns
	fake.recordInvocation("Keys", []interface{}{arg1, arg2})
	fake.keysMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) KeysCallCount() int {
	fake.keysMutex.RLock()
	defer fake.keysMutex.RUnlock()
	return len(fake.keysArgsForCall)
}

func (fake *FakeClient) KeysCalls(stub func(context.Context, string) *redisa.StringSliceCmd) {
	fake.keysMutex.Lock()
	defer fake.keysMutex.Unlock()
	fake.KeysStub = stub
}

func (fake *FakeClient) KeysArgsForCall(i int) (context.Context, string) {
	fake.keysMutex.RLock()
	defer fake.keysMutex.RUnlock()
	argsForCall := fake.keysArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) KeysReturns(result1 *redisa.StringSliceCmd) {
	fake.keysMutex.Lock()
	defer fake.keysMutex.Unlock()
	fake.KeysStub = nil
	fake.keysReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) KeysReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.keysMutex.Lock()
	defer fake.keysMutex.Unlock()
	fake.KeysStub = nil
	if fake.keysReturnsOnCall == nil {
		fake.keysReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.keysReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) LCS(arg1 context.Context, arg2 *redisa.LCSQuery) *redisa.LCSCmd {
	fake.lCSMutex.Lock()
	ret, specificReturn := fake.lCSReturnsOnCall[len(fake.lCSArgsForCall)]
	fake.lCSArgsForCall = append(fake.lCSArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.LCSQuery
	}{arg1, arg2})
	stub := fake.LCSStub
	fakeReturns := fake.lCSReturns
	fake.recordInvocation("LCS", []interface{}{arg1, arg2})
	fake.lCSMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LCSCallCount() int {
	fake.lCSMutex.RLock()
	defer fake.lCSMutex.RUnlock()
	return len(fake.lCSArgsForCall)
}

func (fake *FakeClient) LCSCalls(stub func(context.Context, *redisa.LCSQuery) *redisa.LCSCmd) {
	fake.lCSMutex.Lock()
	defer fake.lCSMutex.Unlock()
	fake.LCSStub = stub
}

func (fake *FakeClient) LCSArgsForCall(i int) (context.Context, *redisa.LCSQuery) {
	fake.lCSMutex.RLock()
	defer fake.lCSMutex.RUnlock()
	argsForCall := fake.lCSArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) LCSReturns(result1 *redisa.LCSCmd) {
	fake.lCSMutex.Lock()
	defer fake.lCSMutex.Unlock()
	fake.LCSStub = nil
	fake.lCSReturns = struct {
		result1 *redisa.LCSCmd
	}{result1}
}

func (fake *FakeClient) LCSReturnsOnCall(i int, result1 *redisa.LCSCmd) {
	fake.lCSMutex.Lock()
	defer fake.lCSMutex.Unlock()
	fake.LCSStub = nil
	if fake.lCSReturnsOnCall == nil {
		fake.lCSReturnsOnCall = make(map[int]struct {
			result1 *redisa.LCSCmd
		})
	}
	fake.lCSReturnsOnCall[i] = struct {
		result1 *redisa.LCSCmd
	}{result1}
}

func (fake *FakeClient) LIndex(arg1 context.Context, arg2 string, arg3 int64) *redisa.StringCmd {
	fake.lIndexMutex.Lock()
	ret, specificReturn := fake.lIndexReturnsOnCall[len(fake.lIndexArgsForCall)]
	fake.lIndexArgsForCall = append(fake.lIndexArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.LIndexStub
	fakeReturns := fake.lIndexReturns
	fake.recordInvocation("LIndex", []interface{}{arg1, arg2, arg3})
	fake.lIndexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LIndexCallCount() int {
	fake.lIndexMutex.RLock()
	defer fake.lIndexMutex.RUnlock()
	return len(fake.lIndexArgsForCall)
}

func (fake *FakeClient) LIndexCalls(stub func(context.Context, string, int64) *redisa.StringCmd) {
	fake.lIndexMutex.Lock()
	defer fake.lIndexMutex.Unlock()
	fake.LIndexStub = stub
}

func (fake *FakeClient) LIndexArgsForCall(i int) (context.Context, string, int64) {
	fake.lIndexMutex.RLock()
	defer fake.lIndexMutex.RUnlock()
	argsForCall := fake.lIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) LIndexReturns(result1 *redisa.StringCmd) {
	fake.lIndexMutex.Lock()
	defer fake.lIndexMutex.Unlock()
	fake.LIndexStub = nil
	fake.lIndexReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) LIndexReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.lIndexMutex.Lock()
	defer fake.lIndexMutex.Unlock()
	fake.LIndexStub = nil
	if fake.lIndexReturnsOnCall == nil {
		fake.lIndexReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.lIndexReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) LInsert(arg1 context.Context, arg2 string, arg3 string, arg4 interface{}, arg5 interface{}) *redisa.IntCmd {
	fake.lInsertMutex.Lock()
	ret, specificReturn := fake.lInsertReturnsOnCall[len(fake.lInsertArgsForCall)]
	fake.lInsertArgsForCall = append(fake.lInsertArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 interface{}
		arg5 interface{}
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.LInsertStub
	fakeReturns := fake.lInsertReturns
	fake.recordInvocation("LInsert", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.lInsertMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LInsertCallCount() int {
	fake.lInsertMutex.RLock()
	defer fake.lInsertMutex.RUnlock()
	return len(fake.lInsertArgsForCall)
}

func (fake *FakeClient) LInsertCalls(stub func(context.Context, string, string, interface{}, interface{}) *redisa.IntCmd) {
	fake.lInsertMutex.Lock()
	defer fake.lInsertMutex.Unlock()
	fake.LInsertStub = stub
}

func (fake *FakeClient) LInsertArgsForCall(i int) (context.Context, string, string, interface{}, interface{}) {
	fake.lInsertMutex.RLock()
	defer fake.lInsertMutex.RUnlock()
	argsForCall := fake.lInsertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) LInsertReturns(result1 *redisa.IntCmd) {
	fake.lInsertMutex.Lock()
	defer fake.lInsertMutex.Unlock()
	fake.LInsertStub = nil
	fake.lInsertReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LInsertReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.lInsertMutex.Lock()
	defer fake.lInsertMutex.Unlock()
	fake.LInsertStub = nil
	if fake.lInsertReturnsOnCall == nil {
		fake.lInsertReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.lInsertReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LInsertAfter(arg1 context.Context, arg2 string, arg3 interface{}, arg4 interface{}) *redisa.IntCmd {
	fake.lInsertAfterMutex.Lock()
	ret, specificReturn := fake.lInsertAfterReturnsOnCall[len(fake.lInsertAfterArgsForCall)]
	fake.lInsertAfterArgsForCall = append(fake.lInsertAfterArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.LInsertAfterStub
	fakeReturns := fake.lInsertAfterReturns
	fake.recordInvocation("LInsertAfter", []interface{}{arg1, arg2, arg3, arg4})
	fake.lInsertAfterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LInsertAfterCallCount() int {
	fake.lInsertAfterMutex.RLock()
	defer fake.lInsertAfterMutex.RUnlock()
	return len(fake.lInsertAfterArgsForCall)
}

func (fake *FakeClient) LInsertAfterCalls(stub func(context.Context, string, interface{}, interface{}) *redisa.IntCmd) {
	fake.lInsertAfterMutex.Lock()
	defer fake.lInsertAfterMutex.Unlock()
	fake.LInsertAfterStub = stub
}

func (fake *FakeClient) LInsertAfterArgsForCall(i int) (context.Context, string, interface{}, interface{}) {
	fake.lInsertAfterMutex.RLock()
	defer fake.lInsertAfterMutex.RUnlock()
	argsForCall := fake.lInsertAfterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) LInsertAfterReturns(result1 *redisa.IntCmd) {
	fake.lInsertAfterMutex.Lock()
	defer fake.lInsertAfterMutex.Unlock()
	fake.LInsertAfterStub = nil
	fake.lInsertAfterReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LInsertAfterReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.lInsertAfterMutex.Lock()
	defer fake.lInsertAfterMutex.Unlock()
	fake.LInsertAfterStub = nil
	if fake.lInsertAfterReturnsOnCall == nil {
		fake.lInsertAfterReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.lInsertAfterReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LInsertBefore(arg1 context.Context, arg2 string, arg3 interface{}, arg4 interface{}) *redisa.IntCmd {
	fake.lInsertBeforeMutex.Lock()
	ret, specificReturn := fake.lInsertBeforeReturnsOnCall[len(fake.lInsertBeforeArgsForCall)]
	fake.lInsertBeforeArgsForCall = append(fake.lInsertBeforeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.LInsertBeforeStub
	fakeReturns := fake.lInsertBeforeReturns
	fake.recordInvocation("LInsertBefore", []interface{}{arg1, arg2, arg3, arg4})
	fake.lInsertBeforeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LInsertBeforeCallCount() int {
	fake.lInsertBeforeMutex.RLock()
	defer fake.lInsertBeforeMutex.RUnlock()
	return len(fake.lInsertBeforeArgsForCall)
}

func (fake *FakeClient) LInsertBeforeCalls(stub func(context.Context, string, interface{}, interface{}) *redisa.IntCmd) {
	fake.lInsertBeforeMutex.Lock()
	defer fake.lInsertBeforeMutex.Unlock()
	fake.LInsertBeforeStub = stub
}

func (fake *FakeClient) LInsertBeforeArgsForCall(i int) (context.Context, string, interface{}, interface{}) {
	fake.lInsertBeforeMutex.RLock()
	defer fake.lInsertBeforeMutex.RUnlock()
	argsForCall := fake.lInsertBeforeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) LInsertBeforeReturns(result1 *redisa.IntCmd) {
	fake.lInsertBeforeMutex.Lock()
	defer fake.lInsertBeforeMutex.Unlock()
	fake.LInsertBeforeStub = nil
	fake.lInsertBeforeReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LInsertBeforeReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.lInsertBeforeMutex.Lock()
	defer fake.lInsertBeforeMutex.Unlock()
	fake.LInsertBeforeStub = nil
	if fake.lInsertBeforeReturnsOnCall == nil {
		fake.lInsertBeforeReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.lInsertBeforeReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LLen(arg1 context.Context, arg2 string) *redisa.IntCmd {
	fake.lLenMutex.Lock()
	ret, specificReturn := fake.lLenReturnsOnCall[len(fake.lLenArgsForCall)]
	fake.lLenArgsForCall = append(fake.lLenArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.LLenStub
	fakeReturns := fake.lLenReturns
	fake.recordInvocation("LLen", []interface{}{arg1, arg2})
	fake.lLenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LLenCallCount() int {
	fake.lLenMutex.RLock()
	defer fake.lLenMutex.RUnlock()
	return len(fake.lLenArgsForCall)
}

func (fake *FakeClient) LLenCalls(stub func(context.Context, string) *redisa.IntCmd) {
	fake.lLenMutex.Lock()
	defer fake.lLenMutex.Unlock()
	fake.LLenStub = stub
}

func (fake *FakeClient) LLenArgsForCall(i int) (context.Context, string) {
	fake.lLenMutex.RLock()
	defer fake.lLenMutex.RUnlock()
	argsForCall := fake.lLenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) LLenReturns(result1 *redisa.IntCmd) {
	fake.lLenMutex.Lock()
	defer fake.lLenMutex.Unlock()
	fake.LLenStub = nil
	fake.lLenReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LLenReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.lLenMutex.Lock()
	defer fake.lLenMutex.Unlock()
	fake.LLenStub = nil
	if fake.lLenReturnsOnCall == nil {
		fake.lLenReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.lLenReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LMPop(arg1 context.Context, arg2 string, arg3 int64, arg4 ...string) *redisa.KeyValuesCmd {
	fake.lMPopMutex.Lock()
	ret, specificReturn := fake.lMPopReturnsOnCall[len(fake.lMPopArgsForCall)]
	fake.lMPopArgsForCall = append(fake.lMPopArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 []string
	}{arg1, arg2, arg3, arg4})
	stub := fake.LMPopStub
	fakeReturns := fake.lMPopReturns
	fake.recordInvocation("LMPop", []interface{}{arg1, arg2, arg3, arg4})
	fake.lMPopMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LMPopCallCount() int {
	fake.lMPopMutex.RLock()
	defer fake.lMPopMutex.RUnlock()
	return len(fake.lMPopArgsForCall)
}

func (fake *FakeClient) LMPopCalls(stub func(context.Context, string, int64, ...string) *redisa.KeyValuesCmd) {
	fake.lMPopMutex.Lock()
	defer fake.lMPopMutex.Unlock()
	fake.LMPopStub = stub
}

func (fake *FakeClient) LMPopArgsForCall(i int) (context.Context, string, int64, []string) {
	fake.lMPopMutex.RLock()
	defer fake.lMPopMutex.RUnlock()
	argsForCall := fake.lMPopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) LMPopReturns(result1 *redisa.KeyValuesCmd) {
	fake.lMPopMutex.Lock()
	defer fake.lMPopMutex.Unlock()
	fake.LMPopStub = nil
	fake.lMPopReturns = struct {
		result1 *redisa.KeyValuesCmd
	}{result1}
}

func (fake *FakeClient) LMPopReturnsOnCall(i int, result1 *redisa.KeyValuesCmd) {
	fake.lMPopMutex.Lock()
	defer fake.lMPopMutex.Unlock()
	fake.LMPopStub = nil
	if fake.lMPopReturnsOnCall == nil {
		fake.lMPopReturnsOnCall = make(map[int]struct {
			result1 *redisa.KeyValuesCmd
		})
	}
	fake.lMPopReturnsOnCall[i] = struct {
		result1 *redisa.KeyValuesCmd
	}{result1}
}

func (fake *FakeClient) LMove(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string) *redisa.StringCmd {
	fake.lMoveMutex.Lock()
	ret, specificReturn := fake.lMoveReturnsOnCall[len(fake.lMoveArgsForCall)]
	fake.lMoveArgsForCall = append(fake.lMoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.LMoveStub
	fakeReturns := fake.lMoveReturns
	fake.recordInvocation("LMove", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.lMoveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LMoveCallCount() int {
	fake.lMoveMutex.RLock()
	defer fake.lMoveMutex.RUnlock()
	return len(fake.lMoveArgsForCall)
}

func (fake *FakeClient) LMoveCalls(stub func(context.Context, string, string, string, string) *redisa.StringCmd) {
	fake.lMoveMutex.Lock()
	defer fake.lMoveMutex.Unlock()
	fake.LMoveStub = stub
}

func (fake *FakeClient) LMoveArgsForCall(i int) (context.Context, string, string, string, string) {
	fake.lMoveMutex.RLock()
	defer fake.lMoveMutex.RUnlock()
	argsForCall := fake.lMoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) LMoveReturns(result1 *redisa.StringCmd) {
	fake.lMoveMutex.Lock()
	defer fake.lMoveMutex.Unlock()
	fake.LMoveStub = nil
	fake.lMoveReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) LMoveReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.lMoveMutex.Lock()
	defer fake.lMoveMutex.Unlock()
	fake.LMoveStub = nil
	if fake.lMoveReturnsOnCall == nil {
		fake.lMoveReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.lMoveReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) LPop(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.lPopMutex.Lock()
	ret, specificReturn := fake.lPopReturnsOnCall[len(fake.lPopArgsForCall)]
	fake.lPopArgsForCall = append(fake.lPopArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.LPopStub
	fakeReturns := fake.lPopReturns
	fake.recordInvocation("LPop", []interface{}{arg1, arg2})
	fake.lPopMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LPopCallCount() int {
	fake.lPopMutex.RLock()
	defer fake.lPopMutex.RUnlock()
	return len(fake.lPopArgsForCall)
}

func (fake *FakeClient) LPopCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.lPopMutex.Lock()
	defer fake.lPopMutex.Unlock()
	fake.LPopStub = stub
}

func (fake *FakeClient) LPopArgsForCall(i int) (context.Context, string) {
	fake.lPopMutex.RLock()
	defer fake.lPopMutex.RUnlock()
	argsForCall := fake.lPopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) LPopReturns(result1 *redisa.StringCmd) {
	fake.lPopMutex.Lock()
	defer fake.lPopMutex.Unlock()
	fake.LPopStub = nil
	fake.lPopReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) LPopReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.lPopMutex.Lock()
	defer fake.lPopMutex.Unlock()
	fake.LPopStub = nil
	if fake.lPopReturnsOnCall == nil {
		fake.lPopReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.lPopReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) LPopCount(arg1 context.Context, arg2 string, arg3 int) *redisa.StringSliceCmd {
	fake.lPopCountMutex.Lock()
	ret, specificReturn := fake.lPopCountReturnsOnCall[len(fake.lPopCountArgsForCall)]
	fake.lPopCountArgsForCall = append(fake.lPopCountArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.LPopCountStub
	fakeReturns := fake.lPopCountReturns
	fake.recordInvocation("LPopCount", []interface{}{arg1, arg2, arg3})
	fake.lPopCountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LPopCountCallCount() int {
	fake.lPopCountMutex.RLock()
	defer fake.lPopCountMutex.RUnlock()
	return len(fake.lPopCountArgsForCall)
}

func (fake *FakeClient) LPopCountCalls(stub func(context.Context, string, int) *redisa.StringSliceCmd) {
	fake.lPopCountMutex.Lock()
	defer fake.lPopCountMutex.Unlock()
	fake.LPopCountStub = stub
}

func (fake *FakeClient) LPopCountArgsForCall(i int) (context.Context, string, int) {
	fake.lPopCountMutex.RLock()
	defer fake.lPopCountMutex.RUnlock()
	argsForCall := fake.lPopCountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) LPopCountReturns(result1 *redisa.StringSliceCmd) {
	fake.lPopCountMutex.Lock()
	defer fake.lPopCountMutex.Unlock()
	fake.LPopCountStub = nil
	fake.lPopCountReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) LPopCountReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.lPopCountMutex.Lock()
	defer fake.lPopCountMutex.Unlock()
	fake.LPopCountStub = nil
	if fake.lPopCountReturnsOnCall == nil {
		fake.lPopCountReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.lPopCountReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) LPos(arg1 context.Context, arg2 string, arg3 string, arg4 redisa.LPosArgs) *redisa.IntCmd {
	fake.lPosMutex.Lock()
	ret, specificReturn := fake.lPosReturnsOnCall[len(fake.lPosArgsForCall)]
	fake.lPosArgsForCall = append(fake.lPosArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 redisa.LPosArgs
	}{arg1, arg2, arg3, arg4})
	stub := fake.LPosStub
	fakeReturns := fake.lPosReturns
	fake.recordInvocation("LPos", []interface{}{arg1, arg2, arg3, arg4})
	fake.lPosMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LPosCallCount() int {
	fake.lPosMutex.RLock()
	defer fake.lPosMutex.RUnlock()
	return len(fake.lPosArgsForCall)
}

func (fake *FakeClient) LPosCalls(stub func(context.Context, string, string, redisa.LPosArgs) *redisa.IntCmd) {
	fake.lPosMutex.Lock()
	defer fake.lPosMutex.Unlock()
	fake.LPosStub = stub
}

func (fake *FakeClient) LPosArgsForCall(i int) (context.Context, string, string, redisa.LPosArgs) {
	fake.lPosMutex.RLock()
	defer fake.lPosMutex.RUnlock()
	argsForCall := fake.lPosArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) LPosReturns(result1 *redisa.IntCmd) {
	fake.lPosMutex.Lock()
	defer fake.lPosMutex.Unlock()
	fake.LPosStub = nil
	fake.lPosReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LPosReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.lPosMutex.Lock()
	defer fake.lPosMutex.Unlock()
	fake.LPosStub = nil
	if fake.lPosReturnsOnCall == nil {
		fake.lPosReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.lPosReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LPosCount(arg1 context.Context, arg2 string, arg3 string, arg4 int64, arg5 redisa.LPosArgs) *redisa.IntSliceCmd {
	fake.lPosCountMutex.Lock()
	ret, specificReturn := fake.lPosCountReturnsOnCall[len(fake.lPosCountArgsForCall)]
	fake.lPosCountArgsForCall = append(fake.lPosCountArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 redisa.LPosArgs
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.LPosCountStub
	fakeReturns := fake.lPosCountReturns
	fake.recordInvocation("LPosCount", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.lPosCountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LPosCountCallCount() int {
	fake.lPosCountMutex.RLock()
	defer fake.lPosCountMutex.RUnlock()
	return len(fake.lPosCountArgsForCall)
}

func (fake *FakeClient) LPosCountCalls(stub func(context.Context, string, string, int64, redisa.LPosArgs) *redisa.IntSliceCmd) {
	fake.lPosCountMutex.Lock()
	defer fake.lPosCountMutex.Unlock()
	fake.LPosCountStub = stub
}

func (fake *FakeClient) LPosCountArgsForCall(i int) (context.Context, string, string, int64, redisa.LPosArgs) {
	fake.lPosCountMutex.RLock()
	defer fake.lPosCountMutex.RUnlock()
	argsForCall := fake.lPosCountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) LPosCountReturns(result1 *redisa.IntSliceCmd) {
	fake.lPosCountMutex.Lock()
	defer fake.lPosCountMutex.Unlock()
	fake.LPosCountStub = nil
	fake.lPosCountReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) LPosCountReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.lPosCountMutex.Lock()
	defer fake.lPosCountMutex.Unlock()
	fake.LPosCountStub = nil
	if fake.lPosCountReturnsOnCall == nil {
		fake.lPosCountReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.lPosCountReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) LPush(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntCmd {
	fake.lPushMutex.Lock()
	ret, specificReturn := fake.lPushReturnsOnCall[len(fake.lPushArgsForCall)]
	fake.lPushArgsForCall = append(fake.lPushArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.LPushStub
	fakeReturns := fake.lPushReturns
	fake.recordInvocation("LPush", []interface{}{arg1, arg2, arg3})
	fake.lPushMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LPushCallCount() int {
	fake.lPushMutex.RLock()
	defer fake.lPushMutex.RUnlock()
	return len(fake.lPushArgsForCall)
}

func (fake *FakeClient) LPushCalls(stub func(context.Context, string, ...interface{}) *redisa.IntCmd) {
	fake.lPushMutex.Lock()
	defer fake.lPushMutex.Unlock()
	fake.LPushStub = stub
}

func (fake *FakeClient) LPushArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.lPushMutex.RLock()
	defer fake.lPushMutex.RUnlock()
	argsForCall := fake.lPushArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) LPushReturns(result1 *redisa.IntCmd) {
	fake.lPushMutex.Lock()
	defer fake.lPushMutex.Unlock()
	fake.LPushStub = nil
	fake.lPushReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LPushReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.lPushMutex.Lock()
	defer fake.lPushMutex.Unlock()
	fake.LPushStub = nil
	if fake.lPushReturnsOnCall == nil {
		fake.lPushReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.lPushReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LPushX(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntCmd {
	fake.lPushXMutex.Lock()
	ret, specificReturn := fake.lPushXReturnsOnCall[len(fake.lPushXArgsForCall)]
	fake.lPushXArgsForCall = append(fake.lPushXArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.LPushXStub
	fakeReturns := fake.lPushXReturns
	fake.recordInvocation("LPushX", []interface{}{arg1, arg2, arg3})
	fake.lPushXMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LPushXCallCount() int {
	fake.lPushXMutex.RLock()
	defer fake.lPushXMutex.RUnlock()
	return len(fake.lPushXArgsForCall)
}

func (fake *FakeClient) LPushXCalls(stub func(context.Context, string, ...interface{}) *redisa.IntCmd) {
	fake.lPushXMutex.Lock()
	defer fake.lPushXMutex.Unlock()
	fake.LPushXStub = stub
}

func (fake *FakeClient) LPushXArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.lPushXMutex.RLock()
	defer fake.lPushXMutex.RUnlock()
	argsForCall := fake.lPushXArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) LPushXReturns(result1 *redisa.IntCmd) {
	fake.lPushXMutex.Lock()
	defer fake.lPushXMutex.Unlock()
	fake.LPushXStub = nil
	fake.lPushXReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LPushXReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.lPushXMutex.Lock()
	defer fake.lPushXMutex.Unlock()
	fake.LPushXStub = nil
	if fake.lPushXReturnsOnCall == nil {
		fake.lPushXReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.lPushXReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LRange(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) *redisa.StringSliceCmd {
	fake.lRangeMutex.Lock()
	ret, specificReturn := fake.lRangeReturnsOnCall[len(fake.lRangeArgsForCall)]
	fake.lRangeArgsForCall = append(fake.lRangeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.LRangeStub
	fakeReturns := fake.lRangeReturns
	fake.recordInvocation("LRange", []interface{}{arg1, arg2, arg3, arg4})
	fake.lRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LRangeCallCount() int {
	fake.lRangeMutex.RLock()
	defer fake.lRangeMutex.RUnlock()
	return len(fake.lRangeArgsForCall)
}

func (fake *FakeClient) LRangeCalls(stub func(context.Context, string, int64, int64) *redisa.StringSliceCmd) {
	fake.lRangeMutex.Lock()
	defer fake.lRangeMutex.Unlock()
	fake.LRangeStub = stub
}

func (fake *FakeClient) LRangeArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.lRangeMutex.RLock()
	defer fake.lRangeMutex.RUnlock()
	argsForCall := fake.lRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) LRangeReturns(result1 *redisa.StringSliceCmd) {
	fake.lRangeMutex.Lock()
	defer fake.lRangeMutex.Unlock()
	fake.LRangeStub = nil
	fake.lRangeReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) LRangeReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.lRangeMutex.Lock()
	defer fake.lRangeMutex.Unlock()
	fake.LRangeStub = nil
	if fake.lRangeReturnsOnCall == nil {
		fake.lRangeReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.lRangeReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) LRem(arg1 context.Context, arg2 string, arg3 int64, arg4 interface{}) *redisa.IntCmd {
	fake.lRemMutex.Lock()
	ret, specificReturn := fake.lRemReturnsOnCall[len(fake.lRemArgsForCall)]
	fake.lRemArgsForCall = append(fake.lRemArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.LRemStub
	fakeReturns := fake.lRemReturns
	fake.recordInvocation("LRem", []interface{}{arg1, arg2, arg3, arg4})
	fake.lRemMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LRemCallCount() int {
	fake.lRemMutex.RLock()
	defer fake.lRemMutex.RUnlock()
	return len(fake.lRemArgsForCall)
}

func (fake *FakeClient) LRemCalls(stub func(context.Context, string, int64, interface{}) *redisa.IntCmd) {
	fake.lRemMutex.Lock()
	defer fake.lRemMutex.Unlock()
	fake.LRemStub = stub
}

func (fake *FakeClient) LRemArgsForCall(i int) (context.Context, string, int64, interface{}) {
	fake.lRemMutex.RLock()
	defer fake.lRemMutex.RUnlock()
	argsForCall := fake.lRemArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) LRemReturns(result1 *redisa.IntCmd) {
	fake.lRemMutex.Lock()
	defer fake.lRemMutex.Unlock()
	fake.LRemStub = nil
	fake.lRemReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LRemReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.lRemMutex.Lock()
	defer fake.lRemMutex.Unlock()
	fake.LRemStub = nil
	if fake.lRemReturnsOnCall == nil {
		fake.lRemReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.lRemReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LSet(arg1 context.Context, arg2 string, arg3 int64, arg4 interface{}) *redisa.StatusCmd {
	fake.lSetMutex.Lock()
	ret, specificReturn := fake.lSetReturnsOnCall[len(fake.lSetArgsForCall)]
	fake.lSetArgsForCall = append(fake.lSetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.LSetStub
	fakeReturns := fake.lSetReturns
	fake.recordInvocation("LSet", []interface{}{arg1, arg2, arg3, arg4})
	fake.lSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LSetCallCount() int {
	fake.lSetMutex.RLock()
	defer fake.lSetMutex.RUnlock()
	return len(fake.lSetArgsForCall)
}

func (fake *FakeClient) LSetCalls(stub func(context.Context, string, int64, interface{}) *redisa.StatusCmd) {
	fake.lSetMutex.Lock()
	defer fake.lSetMutex.Unlock()
	fake.LSetStub = stub
}

func (fake *FakeClient) LSetArgsForCall(i int) (context.Context, string, int64, interface{}) {
	fake.lSetMutex.RLock()
	defer fake.lSetMutex.RUnlock()
	argsForCall := fake.lSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) LSetReturns(result1 *redisa.StatusCmd) {
	fake.lSetMutex.Lock()
	defer fake.lSetMutex.Unlock()
	fake.LSetStub = nil
	fake.lSetReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) LSetReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.lSetMutex.Lock()
	defer fake.lSetMutex.Unlock()
	fake.LSetStub = nil
	if fake.lSetReturnsOnCall == nil {
		fake.lSetReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.lSetReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) LTrim(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) *redisa.StatusCmd {
	fake.lTrimMutex.Lock()
	ret, specificReturn := fake.lTrimReturnsOnCall[len(fake.lTrimArgsForCall)]
	fake.lTrimArgsForCall = append(fake.lTrimArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.LTrimStub
	fakeReturns := fake.lTrimReturns
	fake.recordInvocation("LTrim", []interface{}{arg1, arg2, arg3, arg4})
	fake.lTrimMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LTrimCallCount() int {
	fake.lTrimMutex.RLock()
	defer fake.lTrimMutex.RUnlock()
	return len(fake.lTrimArgsForCall)
}

func (fake *FakeClient) LTrimCalls(stub func(context.Context, string, int64, int64) *redisa.StatusCmd) {
	fake.lTrimMutex.Lock()
	defer fake.lTrimMutex.Unlock()
	fake.LTrimStub = stub
}

func (fake *FakeClient) LTrimArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.lTrimMutex.RLock()
	defer fake.lTrimMutex.RUnlock()
	argsForCall := fake.lTrimArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) LTrimReturns(result1 *redisa.StatusCmd) {
	fake.lTrimMutex.Lock()
	defer fake.lTrimMutex.Unlock()
	fake.LTrimStub = nil
	fake.lTrimReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) LTrimReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.lTrimMutex.Lock()
	defer fake.lTrimMutex.Unlock()
	fake.LTrimStub = nil
	if fake.lTrimReturnsOnCall == nil {
		fake.lTrimReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.lTrimReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) LastSave(arg1 context.Context) *redisa.IntCmd {
	fake.lastSaveMutex.Lock()
	ret, specificReturn := fake.lastSaveReturnsOnCall[len(fake.lastSaveArgsForCall)]
	fake.lastSaveArgsForCall = append(fake.lastSaveArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.LastSaveStub
	fakeReturns := fake.lastSaveReturns
	fake.recordInvocation("LastSave", []interface{}{arg1})
	fake.lastSaveMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) LastSaveCallCount() int {
	fake.lastSaveMutex.RLock()
	defer fake.lastSaveMutex.RUnlock()
	return len(fake.lastSaveArgsForCall)
}

func (fake *FakeClient) LastSaveCalls(stub func(context.Context) *redisa.IntCmd) {
	fake.lastSaveMutex.Lock()
	defer fake.lastSaveMutex.Unlock()
	fake.LastSaveStub = stub
}

func (fake *FakeClient) LastSaveArgsForCall(i int) context.Context {
	fake.lastSaveMutex.RLock()
	defer fake.lastSaveMutex.RUnlock()
	argsForCall := fake.lastSaveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) LastSaveReturns(result1 *redisa.IntCmd) {
	fake.lastSaveMutex.Lock()
	defer fake.lastSaveMutex.Unlock()
	fake.LastSaveStub = nil
	fake.lastSaveReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) LastSaveReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.lastSaveMutex.Lock()
	defer fake.lastSaveMutex.Unlock()
	fake.LastSaveStub = nil
	if fake.lastSaveReturnsOnCall == nil {
		fake.lastSaveReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.lastSaveReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) MGet(arg1 context.Context, arg2 ...string) *redisa.SliceCmd {
	fake.mGetMutex.Lock()
	ret, specificReturn := fake.mGetReturnsOnCall[len(fake.mGetArgsForCall)]
	fake.mGetArgsForCall = append(fake.mGetArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.MGetStub
	fakeReturns := fake.mGetReturns
	fake.recordInvocation("MGet", []interface{}{arg1, arg2})
	fake.mGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) MGetCallCount() int {
	fake.mGetMutex.RLock()
	defer fake.mGetMutex.RUnlock()
	return len(fake.mGetArgsForCall)
}

func (fake *FakeClient) MGetCalls(stub func(context.Context, ...string) *redisa.SliceCmd) {
	fake.mGetMutex.Lock()
	defer fake.mGetMutex.Unlock()
	fake.MGetStub = stub
}

func (fake *FakeClient) MGetArgsForCall(i int) (context.Context, []string) {
	fake.mGetMutex.RLock()
	defer fake.mGetMutex.RUnlock()
	argsForCall := fake.mGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) MGetReturns(result1 *redisa.SliceCmd) {
	fake.mGetMutex.Lock()
	defer fake.mGetMutex.Unlock()
	fake.MGetStub = nil
	fake.mGetReturns = struct {
		result1 *redisa.SliceCmd
	}{result1}
}

func (fake *FakeClient) MGetReturnsOnCall(i int, result1 *redisa.SliceCmd) {
	fake.mGetMutex.Lock()
	defer fake.mGetMutex.Unlock()
	fake.MGetStub = nil
	if fake.mGetReturnsOnCall == nil {
		fake.mGetReturnsOnCall = make(map[int]struct {
			result1 *redisa.SliceCmd
		})
	}
	fake.mGetReturnsOnCall[i] = struct {
		result1 *redisa.SliceCmd
	}{result1}
}

func (fake *FakeClient) MSet(arg1 context.Context, arg2 ...interface{}) *redisa.StatusCmd {
	fake.mSetMutex.Lock()
	ret, specificReturn := fake.mSetReturnsOnCall[len(fake.mSetArgsForCall)]
	fake.mSetArgsForCall = append(fake.mSetArgsForCall, struct {
		arg1 context.Context
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.MSetStub
	fakeReturns := fake.mSetReturns
	fake.recordInvocation("MSet", []interface{}{arg1, arg2})
	fake.mSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) MSetCallCount() int {
	fake.mSetMutex.RLock()
	defer fake.mSetMutex.RUnlock()
	return len(fake.mSetArgsForCall)
}

func (fake *FakeClient) MSetCalls(stub func(context.Context, ...interface{}) *redisa.StatusCmd) {
	fake.mSetMutex.Lock()
	defer fake.mSetMutex.Unlock()
	fake.MSetStub = stub
}

func (fake *FakeClient) MSetArgsForCall(i int) (context.Context, []interface{}) {
	fake.mSetMutex.RLock()
	defer fake.mSetMutex.RUnlock()
	argsForCall := fake.mSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) MSetReturns(result1 *redisa.StatusCmd) {
	fake.mSetMutex.Lock()
	defer fake.mSetMutex.Unlock()
	fake.MSetStub = nil
	fake.mSetReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) MSetReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.mSetMutex.Lock()
	defer fake.mSetMutex.Unlock()
	fake.MSetStub = nil
	if fake.mSetReturnsOnCall == nil {
		fake.mSetReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.mSetReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) MSetNX(arg1 context.Context, arg2 ...interface{}) *redisa.BoolCmd {
	fake.mSetNXMutex.Lock()
	ret, specificReturn := fake.mSetNXReturnsOnCall[len(fake.mSetNXArgsForCall)]
	fake.mSetNXArgsForCall = append(fake.mSetNXArgsForCall, struct {
		arg1 context.Context
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.MSetNXStub
	fakeReturns := fake.mSetNXReturns
	fake.recordInvocation("MSetNX", []interface{}{arg1, arg2})
	fake.mSetNXMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) MSetNXCallCount() int {
	fake.mSetNXMutex.RLock()
	defer fake.mSetNXMutex.RUnlock()
	return len(fake.mSetNXArgsForCall)
}

func (fake *FakeClient) MSetNXCalls(stub func(context.Context, ...interface{}) *redisa.BoolCmd) {
	fake.mSetNXMutex.Lock()
	defer fake.mSetNXMutex.Unlock()
	fake.MSetNXStub = stub
}

func (fake *FakeClient) MSetNXArgsForCall(i int) (context.Context, []interface{}) {
	fake.mSetNXMutex.RLock()
	defer fake.mSetNXMutex.RUnlock()
	argsForCall := fake.mSetNXArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) MSetNXReturns(result1 *redisa.BoolCmd) {
	fake.mSetNXMutex.Lock()
	defer fake.mSetNXMutex.Unlock()
	fake.MSetNXStub = nil
	fake.mSetNXReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) MSetNXReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.mSetNXMutex.Lock()
	defer fake.mSetNXMutex.Unlock()
	fake.MSetNXStub = nil
	if fake.mSetNXReturnsOnCall == nil {
		fake.mSetNXReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.mSetNXReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) MemoryUsage(arg1 context.Context, arg2 string, arg3 ...int) *redisa.IntCmd {
	fake.memoryUsageMutex.Lock()
	ret, specificReturn := fake.memoryUsageReturnsOnCall[len(fake.memoryUsageArgsForCall)]
	fake.memoryUsageArgsForCall = append(fake.memoryUsageArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []int
	}{arg1, arg2, arg3})
	stub := fake.MemoryUsageStub
	fakeReturns := fake.memoryUsageReturns
	fake.recordInvocation("MemoryUsage", []interface{}{arg1, arg2, arg3})
	fake.memoryUsageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) MemoryUsageCallCount() int {
	fake.memoryUsageMutex.RLock()
	defer fake.memoryUsageMutex.RUnlock()
	return len(fake.memoryUsageArgsForCall)
}

func (fake *FakeClient) MemoryUsageCalls(stub func(context.Context, string, ...int) *redisa.IntCmd) {
	fake.memoryUsageMutex.Lock()
	defer fake.memoryUsageMutex.Unlock()
	fake.MemoryUsageStub = stub
}

func (fake *FakeClient) MemoryUsageArgsForCall(i int) (context.Context, string, []int) {
	fake.memoryUsageMutex.RLock()
	defer fake.memoryUsageMutex.RUnlock()
	argsForCall := fake.memoryUsageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) MemoryUsageReturns(result1 *redisa.IntCmd) {
	fake.memoryUsageMutex.Lock()
	defer fake.memoryUsageMutex.Unlock()
	fake.MemoryUsageStub = nil
	fake.memoryUsageReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) MemoryUsageReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.memoryUsageMutex.Lock()
	defer fake.memoryUsageMutex.Unlock()
	fake.MemoryUsageStub = nil
	if fake.memoryUsageReturnsOnCall == nil {
		fake.memoryUsageReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.memoryUsageReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) Migrate(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 int, arg6 time.Duration) *redisa.StatusCmd {
	fake.migrateMutex.Lock()
	ret, specificReturn := fake.migrateReturnsOnCall[len(fake.migrateArgsForCall)]
	fake.migrateArgsForCall = append(fake.migrateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 int
		arg6 time.Duration
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.MigrateStub
	fakeReturns := fake.migrateReturns
	fake.recordInvocation("Migrate", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.migrateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) MigrateCallCount() int {
	fake.migrateMutex.RLock()
	defer fake.migrateMutex.RUnlock()
	return len(fake.migrateArgsForCall)
}

func (fake *FakeClient) MigrateCalls(stub func(context.Context, string, string, string, int, time.Duration) *redisa.StatusCmd) {
	fake.migrateMutex.Lock()
	defer fake.migrateMutex.Unlock()
	fake.MigrateStub = stub
}

func (fake *FakeClient) MigrateArgsForCall(i int) (context.Context, string, string, string, int, time.Duration) {
	fake.migrateMutex.RLock()
	defer fake.migrateMutex.RUnlock()
	argsForCall := fake.migrateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeClient) MigrateReturns(result1 *redisa.StatusCmd) {
	fake.migrateMutex.Lock()
	defer fake.migrateMutex.Unlock()
	fake.MigrateStub = nil
	fake.migrateReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) MigrateReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.migrateMutex.Lock()
	defer fake.migrateMutex.Unlock()
	fake.MigrateStub = nil
	if fake.migrateReturnsOnCall == nil {
		fake.migrateReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.migrateReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ModuleLoadex(arg1 context.Context, arg2 *redisa.ModuleLoadexConfig) *redisa.StringCmd {
	fake.moduleLoadexMutex.Lock()
	ret, specificReturn := fake.moduleLoadexReturnsOnCall[len(fake.moduleLoadexArgsForCall)]
	fake.moduleLoadexArgsForCall = append(fake.moduleLoadexArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.ModuleLoadexConfig
	}{arg1, arg2})
	stub := fake.ModuleLoadexStub
	fakeReturns := fake.moduleLoadexReturns
	fake.recordInvocation("ModuleLoadex", []interface{}{arg1, arg2})
	fake.moduleLoadexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ModuleLoadexCallCount() int {
	fake.moduleLoadexMutex.RLock()
	defer fake.moduleLoadexMutex.RUnlock()
	return len(fake.moduleLoadexArgsForCall)
}

func (fake *FakeClient) ModuleLoadexCalls(stub func(context.Context, *redisa.ModuleLoadexConfig) *redisa.StringCmd) {
	fake.moduleLoadexMutex.Lock()
	defer fake.moduleLoadexMutex.Unlock()
	fake.ModuleLoadexStub = stub
}

func (fake *FakeClient) ModuleLoadexArgsForCall(i int) (context.Context, *redisa.ModuleLoadexConfig) {
	fake.moduleLoadexMutex.RLock()
	defer fake.moduleLoadexMutex.RUnlock()
	argsForCall := fake.moduleLoadexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ModuleLoadexReturns(result1 *redisa.StringCmd) {
	fake.moduleLoadexMutex.Lock()
	defer fake.moduleLoadexMutex.Unlock()
	fake.ModuleLoadexStub = nil
	fake.moduleLoadexReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ModuleLoadexReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.moduleLoadexMutex.Lock()
	defer fake.moduleLoadexMutex.Unlock()
	fake.ModuleLoadexStub = nil
	if fake.moduleLoadexReturnsOnCall == nil {
		fake.moduleLoadexReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.moduleLoadexReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) Move(arg1 context.Context, arg2 string, arg3 int) *redisa.BoolCmd {
	fake.moveMutex.Lock()
	ret, specificReturn := fake.moveReturnsOnCall[len(fake.moveArgsForCall)]
	fake.moveArgsForCall = append(fake.moveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.MoveStub
	fakeReturns := fake.moveReturns
	fake.recordInvocation("Move", []interface{}{arg1, arg2, arg3})
	fake.moveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) MoveCallCount() int {
	fake.moveMutex.RLock()
	defer fake.moveMutex.RUnlock()
	return len(fake.moveArgsForCall)
}

func (fake *FakeClient) MoveCalls(stub func(context.Context, string, int) *redisa.BoolCmd) {
	fake.moveMutex.Lock()
	defer fake.moveMutex.Unlock()
	fake.MoveStub = stub
}

func (fake *FakeClient) MoveArgsForCall(i int) (context.Context, string, int) {
	fake.moveMutex.RLock()
	defer fake.moveMutex.RUnlock()
	argsForCall := fake.moveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) MoveReturns(result1 *redisa.BoolCmd) {
	fake.moveMutex.Lock()
	defer fake.moveMutex.Unlock()
	fake.MoveStub = nil
	fake.moveReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) MoveReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.moveMutex.Lock()
	defer fake.moveMutex.Unlock()
	fake.MoveStub = nil
	if fake.moveReturnsOnCall == nil {
		fake.moveReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.moveReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) ObjectEncoding(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.objectEncodingMutex.Lock()
	ret, specificReturn := fake.objectEncodingReturnsOnCall[len(fake.objectEncodingArgsForCall)]
	fake.objectEncodingArgsForCall = append(fake.objectEncodingArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ObjectEncodingStub
	fakeReturns := fake.objectEncodingReturns
	fake.recordInvocation("ObjectEncoding", []interface{}{arg1, arg2})
	fake.objectEncodingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ObjectEncodingCallCount() int {
	fake.objectEncodingMutex.RLock()
	defer fake.objectEncodingMutex.RUnlock()
	return len(fake.objectEncodingArgsForCall)
}

func (fake *FakeClient) ObjectEncodingCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.objectEncodingMutex.Lock()
	defer fake.objectEncodingMutex.Unlock()
	fake.ObjectEncodingStub = stub
}

func (fake *FakeClient) ObjectEncodingArgsForCall(i int) (context.Context, string) {
	fake.objectEncodingMutex.RLock()
	defer fake.objectEncodingMutex.RUnlock()
	argsForCall := fake.objectEncodingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ObjectEncodingReturns(result1 *redisa.StringCmd) {
	fake.objectEncodingMutex.Lock()
	defer fake.objectEncodingMutex.Unlock()
	fake.ObjectEncodingStub = nil
	fake.objectEncodingReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ObjectEncodingReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.objectEncodingMutex.Lock()
	defer fake.objectEncodingMutex.Unlock()
	fake.ObjectEncodingStub = nil
	if fake.objectEncodingReturnsOnCall == nil {
		fake.objectEncodingReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.objectEncodingReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ObjectFreq(arg1 context.Context, arg2 string) *redisa.IntCmd {
	fake.objectFreqMutex.Lock()
	ret, specificReturn := fake.objectFreqReturnsOnCall[len(fake.objectFreqArgsForCall)]
	fake.objectFreqArgsForCall = append(fake.objectFreqArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ObjectFreqStub
	fakeReturns := fake.objectFreqReturns
	fake.recordInvocation("ObjectFreq", []interface{}{arg1, arg2})
	fake.objectFreqMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ObjectFreqCallCount() int {
	fake.objectFreqMutex.RLock()
	defer fake.objectFreqMutex.RUnlock()
	return len(fake.objectFreqArgsForCall)
}

func (fake *FakeClient) ObjectFreqCalls(stub func(context.Context, string) *redisa.IntCmd) {
	fake.objectFreqMutex.Lock()
	defer fake.objectFreqMutex.Unlock()
	fake.ObjectFreqStub = stub
}

func (fake *FakeClient) ObjectFreqArgsForCall(i int) (context.Context, string) {
	fake.objectFreqMutex.RLock()
	defer fake.objectFreqMutex.RUnlock()
	argsForCall := fake.objectFreqArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ObjectFreqReturns(result1 *redisa.IntCmd) {
	fake.objectFreqMutex.Lock()
	defer fake.objectFreqMutex.Unlock()
	fake.ObjectFreqStub = nil
	fake.objectFreqReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ObjectFreqReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.objectFreqMutex.Lock()
	defer fake.objectFreqMutex.Unlock()
	fake.ObjectFreqStub = nil
	if fake.objectFreqReturnsOnCall == nil {
		fake.objectFreqReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.objectFreqReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ObjectIdleTime(arg1 context.Context, arg2 string) *redisa.DurationCmd {
	fake.objectIdleTimeMutex.Lock()
	ret, specificReturn := fake.objectIdleTimeReturnsOnCall[len(fake.objectIdleTimeArgsForCall)]
	fake.objectIdleTimeArgsForCall = append(fake.objectIdleTimeArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ObjectIdleTimeStub
	fakeReturns := fake.objectIdleTimeReturns
	fake.recordInvocation("ObjectIdleTime", []interface{}{arg1, arg2})
	fake.objectIdleTimeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ObjectIdleTimeCallCount() int {
	fake.objectIdleTimeMutex.RLock()
	defer fake.objectIdleTimeMutex.RUnlock()
	return len(fake.objectIdleTimeArgsForCall)
}

func (fake *FakeClient) ObjectIdleTimeCalls(stub func(context.Context, string) *redisa.DurationCmd) {
	fake.objectIdleTimeMutex.Lock()
	defer fake.objectIdleTimeMutex.Unlock()
	fake.ObjectIdleTimeStub = stub
}

func (fake *FakeClient) ObjectIdleTimeArgsForCall(i int) (context.Context, string) {
	fake.objectIdleTimeMutex.RLock()
	defer fake.objectIdleTimeMutex.RUnlock()
	argsForCall := fake.objectIdleTimeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ObjectIdleTimeReturns(result1 *redisa.DurationCmd) {
	fake.objectIdleTimeMutex.Lock()
	defer fake.objectIdleTimeMutex.Unlock()
	fake.ObjectIdleTimeStub = nil
	fake.objectIdleTimeReturns = struct {
		result1 *redisa.DurationCmd
	}{result1}
}

func (fake *FakeClient) ObjectIdleTimeReturnsOnCall(i int, result1 *redisa.DurationCmd) {
	fake.objectIdleTimeMutex.Lock()
	defer fake.objectIdleTimeMutex.Unlock()
	fake.ObjectIdleTimeStub = nil
	if fake.objectIdleTimeReturnsOnCall == nil {
		fake.objectIdleTimeReturnsOnCall = make(map[int]struct {
			result1 *redisa.DurationCmd
		})
	}
	fake.objectIdleTimeReturnsOnCall[i] = struct {
		result1 *redisa.DurationCmd
	}{result1}
}

func (fake *FakeClient) ObjectRefCount(arg1 context.Context, arg2 string) *redisa.IntCmd {
	fake.objectRefCountMutex.Lock()
	ret, specificReturn := fake.objectRefCountReturnsOnCall[len(fake.objectRefCountArgsForCall)]
	fake.objectRefCountArgsForCall = append(fake.objectRefCountArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ObjectRefCountStub
	fakeReturns := fake.objectRefCountReturns
	fake.recordInvocation("ObjectRefCount", []interface{}{arg1, arg2})
	fake.objectRefCountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ObjectRefCountCallCount() int {
	fake.objectRefCountMutex.RLock()
	defer fake.objectRefCountMutex.RUnlock()
	return len(fake.objectRefCountArgsForCall)
}

func (fake *FakeClient) ObjectRefCountCalls(stub func(context.Context, string) *redisa.IntCmd) {
	fake.objectRefCountMutex.Lock()
	defer fake.objectRefCountMutex.Unlock()
	fake.ObjectRefCountStub = stub
}

func (fake *FakeClient) ObjectRefCountArgsForCall(i int) (context.Context, string) {
	fake.objectRefCountMutex.RLock()
	defer fake.objectRefCountMutex.RUnlock()
	argsForCall := fake.objectRefCountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ObjectRefCountReturns(result1 *redisa.IntCmd) {
	fake.objectRefCountMutex.Lock()
	defer fake.objectRefCountMutex.Unlock()
	fake.ObjectRefCountStub = nil
	fake.objectRefCountReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ObjectRefCountReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.objectRefCountMutex.Lock()
	defer fake.objectRefCountMutex.Unlock()
	fake.ObjectRefCountStub = nil
	if fake.objectRefCountReturnsOnCall == nil {
		fake.objectRefCountReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.objectRefCountReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) PExpire(arg1 context.Context, arg2 string, arg3 time.Duration) *redisa.BoolCmd {
	fake.pExpireMutex.Lock()
	ret, specificReturn := fake.pExpireReturnsOnCall[len(fake.pExpireArgsForCall)]
	fake.pExpireArgsForCall = append(fake.pExpireArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
	}{arg1, arg2, arg3})
	stub := fake.PExpireStub
	fakeReturns := fake.pExpireReturns
	fake.recordInvocation("PExpire", []interface{}{arg1, arg2, arg3})
	fake.pExpireMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PExpireCallCount() int {
	fake.pExpireMutex.RLock()
	defer fake.pExpireMutex.RUnlock()
	return len(fake.pExpireArgsForCall)
}

func (fake *FakeClient) PExpireCalls(stub func(context.Context, string, time.Duration) *redisa.BoolCmd) {
	fake.pExpireMutex.Lock()
	defer fake.pExpireMutex.Unlock()
	fake.PExpireStub = stub
}

func (fake *FakeClient) PExpireArgsForCall(i int) (context.Context, string, time.Duration) {
	fake.pExpireMutex.RLock()
	defer fake.pExpireMutex.RUnlock()
	argsForCall := fake.pExpireArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) PExpireReturns(result1 *redisa.BoolCmd) {
	fake.pExpireMutex.Lock()
	defer fake.pExpireMutex.Unlock()
	fake.PExpireStub = nil
	fake.pExpireReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) PExpireReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.pExpireMutex.Lock()
	defer fake.pExpireMutex.Unlock()
	fake.PExpireStub = nil
	if fake.pExpireReturnsOnCall == nil {
		fake.pExpireReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.pExpireReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) PExpireAt(arg1 context.Context, arg2 string, arg3 time.Time) *redisa.BoolCmd {
	fake.pExpireAtMutex.Lock()
	ret, specificReturn := fake.pExpireAtReturnsOnCall[len(fake.pExpireAtArgsForCall)]
	fake.pExpireAtArgsForCall = append(fake.pExpireAtArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Time
	}{arg1, arg2, arg3})
	stub := fake.PExpireAtStub
	fakeReturns := fake.pExpireAtReturns
	fake.recordInvocation("PExpireAt", []interface{}{arg1, arg2, arg3})
	fake.pExpireAtMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PExpireAtCallCount() int {
	fake.pExpireAtMutex.RLock()
	defer fake.pExpireAtMutex.RUnlock()
	return len(fake.pExpireAtArgsForCall)
}

func (fake *FakeClient) PExpireAtCalls(stub func(context.Context, string, time.Time) *redisa.BoolCmd) {
	fake.pExpireAtMutex.Lock()
	defer fake.pExpireAtMutex.Unlock()
	fake.PExpireAtStub = stub
}

func (fake *FakeClient) PExpireAtArgsForCall(i int) (context.Context, string, time.Time) {
	fake.pExpireAtMutex.RLock()
	defer fake.pExpireAtMutex.RUnlock()
	argsForCall := fake.pExpireAtArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) PExpireAtReturns(result1 *redisa.BoolCmd) {
	fake.pExpireAtMutex.Lock()
	defer fake.pExpireAtMutex.Unlock()
	fake.PExpireAtStub = nil
	fake.pExpireAtReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) PExpireAtReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.pExpireAtMutex.Lock()
	defer fake.pExpireAtMutex.Unlock()
	fake.PExpireAtStub = nil
	if fake.pExpireAtReturnsOnCall == nil {
		fake.pExpireAtReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.pExpireAtReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) PExpireTime(arg1 context.Context, arg2 string) *redisa.DurationCmd {
	fake.pExpireTimeMutex.Lock()
	ret, specificReturn := fake.pExpireTimeReturnsOnCall[len(fake.pExpireTimeArgsForCall)]
	fake.pExpireTimeArgsForCall = append(fake.pExpireTimeArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.PExpireTimeStub
	fakeReturns := fake.pExpireTimeReturns
	fake.recordInvocation("PExpireTime", []interface{}{arg1, arg2})
	fake.pExpireTimeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PExpireTimeCallCount() int {
	fake.pExpireTimeMutex.RLock()
	defer fake.pExpireTimeMutex.RUnlock()
	return len(fake.pExpireTimeArgsForCall)
}

func (fake *FakeClient) PExpireTimeCalls(stub func(context.Context, string) *redisa.DurationCmd) {
	fake.pExpireTimeMutex.Lock()
	defer fake.pExpireTimeMutex.Unlock()
	fake.PExpireTimeStub = stub
}

func (fake *FakeClient) PExpireTimeArgsForCall(i int) (context.Context, string) {
	fake.pExpireTimeMutex.RLock()
	defer fake.pExpireTimeMutex.RUnlock()
	argsForCall := fake.pExpireTimeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PExpireTimeReturns(result1 *redisa.DurationCmd) {
	fake.pExpireTimeMutex.Lock()
	defer fake.pExpireTimeMutex.Unlock()
	fake.PExpireTimeStub = nil
	fake.pExpireTimeReturns = struct {
		result1 *redisa.DurationCmd
	}{result1}
}

func (fake *FakeClient) PExpireTimeReturnsOnCall(i int, result1 *redisa.DurationCmd) {
	fake.pExpireTimeMutex.Lock()
	defer fake.pExpireTimeMutex.Unlock()
	fake.PExpireTimeStub = nil
	if fake.pExpireTimeReturnsOnCall == nil {
		fake.pExpireTimeReturnsOnCall = make(map[int]struct {
			result1 *redisa.DurationCmd
		})
	}
	fake.pExpireTimeReturnsOnCall[i] = struct {
		result1 *redisa.DurationCmd
	}{result1}
}

func (fake *FakeClient) PFAdd(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntCmd {
	fake.pFAddMutex.Lock()
	ret, specificReturn := fake.pFAddReturnsOnCall[len(fake.pFAddArgsForCall)]
	fake.pFAddArgsForCall = append(fake.pFAddArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.PFAddStub
	fakeReturns := fake.pFAddReturns
	fake.recordInvocation("PFAdd", []interface{}{arg1, arg2, arg3})
	fake.pFAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PFAddCallCount() int {
	fake.pFAddMutex.RLock()
	defer fake.pFAddMutex.RUnlock()
	return len(fake.pFAddArgsForCall)
}

func (fake *FakeClient) PFAddCalls(stub func(context.Context, string, ...interface{}) *redisa.IntCmd) {
	fake.pFAddMutex.Lock()
	defer fake.pFAddMutex.Unlock()
	fake.PFAddStub = stub
}

func (fake *FakeClient) PFAddArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.pFAddMutex.RLock()
	defer fake.pFAddMutex.RUnlock()
	argsForCall := fake.pFAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) PFAddReturns(result1 *redisa.IntCmd) {
	fake.pFAddMutex.Lock()
	defer fake.pFAddMutex.Unlock()
	fake.PFAddStub = nil
	fake.pFAddReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) PFAddReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.pFAddMutex.Lock()
	defer fake.pFAddMutex.Unlock()
	fake.PFAddStub = nil
	if fake.pFAddReturnsOnCall == nil {
		fake.pFAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.pFAddReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) PFCount(arg1 context.Context, arg2 ...string) *redisa.IntCmd {
	fake.pFCountMutex.Lock()
	ret, specificReturn := fake.pFCountReturnsOnCall[len(fake.pFCountArgsForCall)]
	fake.pFCountArgsForCall = append(fake.pFCountArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.PFCountStub
	fakeReturns := fake.pFCountReturns
	fake.recordInvocation("PFCount", []interface{}{arg1, arg2})
	fake.pFCountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PFCountCallCount() int {
	fake.pFCountMutex.RLock()
	defer fake.pFCountMutex.RUnlock()
	return len(fake.pFCountArgsForCall)
}

func (fake *FakeClient) PFCountCalls(stub func(context.Context, ...string) *redisa.IntCmd) {
	fake.pFCountMutex.Lock()
	defer fake.pFCountMutex.Unlock()
	fake.PFCountStub = stub
}

func (fake *FakeClient) PFCountArgsForCall(i int) (context.Context, []string) {
	fake.pFCountMutex.RLock()
	defer fake.pFCountMutex.RUnlock()
	argsForCall := fake.pFCountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PFCountReturns(result1 *redisa.IntCmd) {
	fake.pFCountMutex.Lock()
	defer fake.pFCountMutex.Unlock()
	fake.PFCountStub = nil
	fake.pFCountReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) PFCountReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.pFCountMutex.Lock()
	defer fake.pFCountMutex.Unlock()
	fake.PFCountStub = nil
	if fake.pFCountReturnsOnCall == nil {
		fake.pFCountReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.pFCountReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) PFMerge(arg1 context.Context, arg2 string, arg3 ...string) *redisa.StatusCmd {
	fake.pFMergeMutex.Lock()
	ret, specificReturn := fake.pFMergeReturnsOnCall[len(fake.pFMergeArgsForCall)]
	fake.pFMergeArgsForCall = append(fake.pFMergeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.PFMergeStub
	fakeReturns := fake.pFMergeReturns
	fake.recordInvocation("PFMerge", []interface{}{arg1, arg2, arg3})
	fake.pFMergeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PFMergeCallCount() int {
	fake.pFMergeMutex.RLock()
	defer fake.pFMergeMutex.RUnlock()
	return len(fake.pFMergeArgsForCall)
}

func (fake *FakeClient) PFMergeCalls(stub func(context.Context, string, ...string) *redisa.StatusCmd) {
	fake.pFMergeMutex.Lock()
	defer fake.pFMergeMutex.Unlock()
	fake.PFMergeStub = stub
}

func (fake *FakeClient) PFMergeArgsForCall(i int) (context.Context, string, []string) {
	fake.pFMergeMutex.RLock()
	defer fake.pFMergeMutex.RUnlock()
	argsForCall := fake.pFMergeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) PFMergeReturns(result1 *redisa.StatusCmd) {
	fake.pFMergeMutex.Lock()
	defer fake.pFMergeMutex.Unlock()
	fake.PFMergeStub = nil
	fake.pFMergeReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) PFMergeReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.pFMergeMutex.Lock()
	defer fake.pFMergeMutex.Unlock()
	fake.PFMergeStub = nil
	if fake.pFMergeReturnsOnCall == nil {
		fake.pFMergeReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.pFMergeReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) PTTL(arg1 context.Context, arg2 string) *redisa.DurationCmd {
	fake.pTTLMutex.Lock()
	ret, specificReturn := fake.pTTLReturnsOnCall[len(fake.pTTLArgsForCall)]
	fake.pTTLArgsForCall = append(fake.pTTLArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.PTTLStub
	fakeReturns := fake.pTTLReturns
	fake.recordInvocation("PTTL", []interface{}{arg1, arg2})
	fake.pTTLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PTTLCallCount() int {
	fake.pTTLMutex.RLock()
	defer fake.pTTLMutex.RUnlock()
	return len(fake.pTTLArgsForCall)
}

func (fake *FakeClient) PTTLCalls(stub func(context.Context, string) *redisa.DurationCmd) {
	fake.pTTLMutex.Lock()
	defer fake.pTTLMutex.Unlock()
	fake.PTTLStub = stub
}

func (fake *FakeClient) PTTLArgsForCall(i int) (context.Context, string) {
	fake.pTTLMutex.RLock()
	defer fake.pTTLMutex.RUnlock()
	argsForCall := fake.pTTLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PTTLReturns(result1 *redisa.DurationCmd) {
	fake.pTTLMutex.Lock()
	defer fake.pTTLMutex.Unlock()
	fake.PTTLStub = nil
	fake.pTTLReturns = struct {
		result1 *redisa.DurationCmd
	}{result1}
}

func (fake *FakeClient) PTTLReturnsOnCall(i int, result1 *redisa.DurationCmd) {
	fake.pTTLMutex.Lock()
	defer fake.pTTLMutex.Unlock()
	fake.PTTLStub = nil
	if fake.pTTLReturnsOnCall == nil {
		fake.pTTLReturnsOnCall = make(map[int]struct {
			result1 *redisa.DurationCmd
		})
	}
	fake.pTTLReturnsOnCall[i] = struct {
		result1 *redisa.DurationCmd
	}{result1}
}

func (fake *FakeClient) Persist(arg1 context.Context, arg2 string) *redisa.BoolCmd {
	fake.persistMutex.Lock()
	ret, specificReturn := fake.persistReturnsOnCall[len(fake.persistArgsForCall)]
	fake.persistArgsForCall = append(fake.persistArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.PersistStub
	fakeReturns := fake.persistReturns
	fake.recordInvocation("Persist", []interface{}{arg1, arg2})
	fake.persistMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PersistCallCount() int {
	fake.persistMutex.RLock()
	defer fake.persistMutex.RUnlock()
	return len(fake.persistArgsForCall)
}

func (fake *FakeClient) PersistCalls(stub func(context.Context, string) *redisa.BoolCmd) {
	fake.persistMutex.Lock()
	defer fake.persistMutex.Unlock()
	fake.PersistStub = stub
}

func (fake *FakeClient) PersistArgsForCall(i int) (context.Context, string) {
	fake.persistMutex.RLock()
	defer fake.persistMutex.RUnlock()
	argsForCall := fake.persistArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PersistReturns(result1 *redisa.BoolCmd) {
	fake.persistMutex.Lock()
	defer fake.persistMutex.Unlock()
	fake.PersistStub = nil
	fake.persistReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) PersistReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.persistMutex.Lock()
	defer fake.persistMutex.Unlock()
	fake.PersistStub = nil
	if fake.persistReturnsOnCall == nil {
		fake.persistReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.persistReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) Ping(arg1 context.Context) *redisa.StatusCmd {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.PingStub
	fakeReturns := fake.pingReturns
	fake.recordInvocation("Ping", []interface{}{arg1})
	fake.pingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeClient) PingCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = stub
}

func (fake *FakeClient) PingArgsForCall(i int) context.Context {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	argsForCall := fake.pingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PingReturns(result1 *redisa.StatusCmd) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) PingReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) Pipeline() redisa.Pipeliner {
	fake.pipelineMutex.Lock()
	ret, specificReturn := fake.pipelineReturnsOnCall[len(fake.pipelineArgsForCall)]
	fake.pipelineArgsForCall = append(fake.pipelineArgsForCall, struct {
	}{})
	stub := fake.PipelineStub
	fakeReturns := fake.pipelineReturns
	fake.recordInvocation("Pipeline", []interface{}{})
	fake.pipelineMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PipelineCallCount() int {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	return len(fake.pipelineArgsForCall)
}

func (fake *FakeClient) PipelineCalls(stub func() redisa.Pipeliner) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = stub
}

func (fake *FakeClient) PipelineReturns(result1 redisa.Pipeliner) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	fake.pipelineReturns = struct {
		result1 redisa.Pipeliner
	}{result1}
}

func (fake *FakeClient) PipelineReturnsOnCall(i int, result1 redisa.Pipeliner) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	if fake.pipelineReturnsOnCall == nil {
		fake.pipelineReturnsOnCall = make(map[int]struct {
			result1 redisa.Pipeliner
		})
	}
	fake.pipelineReturnsOnCall[i] = struct {
		result1 redisa.Pipeliner
	}{result1}
}

func (fake *FakeClient) Pipelined(arg1 context.Context, arg2 func(redisa.Pipeliner) error) ([]redisa.Cmder, error) {
	fake.pipelinedMutex.Lock()
	ret, specificReturn := fake.pipelinedReturnsOnCall[len(fake.pipelinedArgsForCall)]
	fake.pipelinedArgsForCall = append(fake.pipelinedArgsForCall, struct {
		arg1 context.Context
		arg2 func(redisa.Pipeliner) error
	}{arg1, arg2})
	stub := fake.PipelinedStub
	fakeReturns := fake.pipelinedReturns
	fake.recordInvocation("Pipelined", []interface{}{arg1, arg2})
	fake.pipelinedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PipelinedCallCount() int {
	fake.pipelinedMutex.RLock()
	defer fake.pipelinedMutex.RUnlock()
	return len(fake.pipelinedArgsForCall)
}

func (fake *FakeClient) PipelinedCalls(stub func(context.Context, func(redisa.Pipeliner) error) ([]redisa.Cmder, error)) {
	fake.pipelinedMutex.Lock()
	defer fake.pipelinedMutex.Unlock()
	fake.PipelinedStub = stub
}

func (fake *FakeClient) PipelinedArgsForCall(i int) (context.Context, func(redisa.Pipeliner) error) {
	fake.pipelinedMutex.RLock()
	defer fake.pipelinedMutex.RUnlock()
	argsForCall := fake.pipelinedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PipelinedReturns(result1 []redisa.Cmder, result2 error) {
	fake.pipelinedMutex.Lock()
	defer fake.pipelinedMutex.Unlock()
	fake.PipelinedStub = nil
	fake.pipelinedReturns = struct {
		result1 []redisa.Cmder
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PipelinedReturnsOnCall(i int, result1 []redisa.Cmder, result2 error) {
	fake.pipelinedMutex.Lock()
	defer fake.pipelinedMutex.Unlock()
	fake.PipelinedStub = nil
	if fake.pipelinedReturnsOnCall == nil {
		fake.pipelinedReturnsOnCall = make(map[int]struct {
			result1 []redisa.Cmder
			result2 error
		})
	}
	fake.pipelinedReturnsOnCall[i] = struct {
		result1 []redisa.Cmder
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PubSubChannels(arg1 context.Context, arg2 string) *redisa.StringSliceCmd {
	fake.pubSubChannelsMutex.Lock()
	ret, specificReturn := fake.pubSubChannelsReturnsOnCall[len(fake.pubSubChannelsArgsForCall)]
	fake.pubSubChannelsArgsForCall = append(fake.pubSubChannelsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.PubSubChannelsStub
	fakeReturns := fake.pubSubChannelsReturns
	fake.recordInvocation("PubSubChannels", []interface{}{arg1, arg2})
	fake.pubSubChannelsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PubSubChannelsCallCount() int {
	fake.pubSubChannelsMutex.RLock()
	defer fake.pubSubChannelsMutex.RUnlock()
	return len(fake.pubSubChannelsArgsForCall)
}

func (fake *FakeClient) PubSubChannelsCalls(stub func(context.Context, string) *redisa.StringSliceCmd) {
	fake.pubSubChannelsMutex.Lock()
	defer fake.pubSubChannelsMutex.Unlock()
	fake.PubSubChannelsStub = stub
}

func (fake *FakeClient) PubSubChannelsArgsForCall(i int) (context.Context, string) {
	fake.pubSubChannelsMutex.RLock()
	defer fake.pubSubChannelsMutex.RUnlock()
	argsForCall := fake.pubSubChannelsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PubSubChannelsReturns(result1 *redisa.StringSliceCmd) {
	fake.pubSubChannelsMutex.Lock()
	defer fake.pubSubChannelsMutex.Unlock()
	fake.PubSubChannelsStub = nil
	fake.pubSubChannelsReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) PubSubChannelsReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.pubSubChannelsMutex.Lock()
	defer fake.pubSubChannelsMutex.Unlock()
	fake.PubSubChannelsStub = nil
	if fake.pubSubChannelsReturnsOnCall == nil {
		fake.pubSubChannelsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.pubSubChannelsReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) PubSubNumPat(arg1 context.Context) *redisa.IntCmd {
	fake.pubSubNumPatMutex.Lock()
	ret, specificReturn := fake.pubSubNumPatReturnsOnCall[len(fake.pubSubNumPatArgsForCall)]
	fake.pubSubNumPatArgsForCall = append(fake.pubSubNumPatArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.PubSubNumPatStub
	fakeReturns := fake.pubSubNumPatReturns
	fake.recordInvocation("PubSubNumPat", []interface{}{arg1})
	fake.pubSubNumPatMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PubSubNumPatCallCount() int {
	fake.pubSubNumPatMutex.RLock()
	defer fake.pubSubNumPatMutex.RUnlock()
	return len(fake.pubSubNumPatArgsForCall)
}

func (fake *FakeClient) PubSubNumPatCalls(stub func(context.Context) *redisa.IntCmd) {
	fake.pubSubNumPatMutex.Lock()
	defer fake.pubSubNumPatMutex.Unlock()
	fake.PubSubNumPatStub = stub
}

func (fake *FakeClient) PubSubNumPatArgsForCall(i int) context.Context {
	fake.pubSubNumPatMutex.RLock()
	defer fake.pubSubNumPatMutex.RUnlock()
	argsForCall := fake.pubSubNumPatArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PubSubNumPatReturns(result1 *redisa.IntCmd) {
	fake.pubSubNumPatMutex.Lock()
	defer fake.pubSubNumPatMutex.Unlock()
	fake.PubSubNumPatStub = nil
	fake.pubSubNumPatReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) PubSubNumPatReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.pubSubNumPatMutex.Lock()
	defer fake.pubSubNumPatMutex.Unlock()
	fake.PubSubNumPatStub = nil
	if fake.pubSubNumPatReturnsOnCall == nil {
		fake.pubSubNumPatReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.pubSubNumPatReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) PubSubNumSub(arg1 context.Context, arg2 ...string) *redisa.MapStringIntCmd {
	fake.pubSubNumSubMutex.Lock()
	ret, specificReturn := fake.pubSubNumSubReturnsOnCall[len(fake.pubSubNumSubArgsForCall)]
	fake.pubSubNumSubArgsForCall = append(fake.pubSubNumSubArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.PubSubNumSubStub
	fakeReturns := fake.pubSubNumSubReturns
	fake.recordInvocation("PubSubNumSub", []interface{}{arg1, arg2})
	fake.pubSubNumSubMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PubSubNumSubCallCount() int {
	fake.pubSubNumSubMutex.RLock()
	defer fake.pubSubNumSubMutex.RUnlock()
	return len(fake.pubSubNumSubArgsForCall)
}

func (fake *FakeClient) PubSubNumSubCalls(stub func(context.Context, ...string) *redisa.MapStringIntCmd) {
	fake.pubSubNumSubMutex.Lock()
	defer fake.pubSubNumSubMutex.Unlock()
	fake.PubSubNumSubStub = stub
}

func (fake *FakeClient) PubSubNumSubArgsForCall(i int) (context.Context, []string) {
	fake.pubSubNumSubMutex.RLock()
	defer fake.pubSubNumSubMutex.RUnlock()
	argsForCall := fake.pubSubNumSubArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PubSubNumSubReturns(result1 *redisa.MapStringIntCmd) {
	fake.pubSubNumSubMutex.Lock()
	defer fake.pubSubNumSubMutex.Unlock()
	fake.PubSubNumSubStub = nil
	fake.pubSubNumSubReturns = struct {
		result1 *redisa.MapStringIntCmd
	}{result1}
}

func (fake *FakeClient) PubSubNumSubReturnsOnCall(i int, result1 *redisa.MapStringIntCmd) {
	fake.pubSubNumSubMutex.Lock()
	defer fake.pubSubNumSubMutex.Unlock()
	fake.PubSubNumSubStub = nil
	if fake.pubSubNumSubReturnsOnCall == nil {
		fake.pubSubNumSubReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringIntCmd
		})
	}
	fake.pubSubNumSubReturnsOnCall[i] = struct {
		result1 *redisa.MapStringIntCmd
	}{result1}
}

func (fake *FakeClient) PubSubShardChannels(arg1 context.Context, arg2 string) *redisa.StringSliceCmd {
	fake.pubSubShardChannelsMutex.Lock()
	ret, specificReturn := fake.pubSubShardChannelsReturnsOnCall[len(fake.pubSubShardChannelsArgsForCall)]
	fake.pubSubShardChannelsArgsForCall = append(fake.pubSubShardChannelsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.PubSubShardChannelsStub
	fakeReturns := fake.pubSubShardChannelsReturns
	fake.recordInvocation("PubSubShardChannels", []interface{}{arg1, arg2})
	fake.pubSubShardChannelsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PubSubShardChannelsCallCount() int {
	fake.pubSubShardChannelsMutex.RLock()
	defer fake.pubSubShardChannelsMutex.RUnlock()
	return len(fake.pubSubShardChannelsArgsForCall)
}

func (fake *FakeClient) PubSubShardChannelsCalls(stub func(context.Context, string) *redisa.StringSliceCmd) {
	fake.pubSubShardChannelsMutex.Lock()
	defer fake.pubSubShardChannelsMutex.Unlock()
	fake.PubSubShardChannelsStub = stub
}

func (fake *FakeClient) PubSubShardChannelsArgsForCall(i int) (context.Context, string) {
	fake.pubSubShardChannelsMutex.RLock()
	defer fake.pubSubShardChannelsMutex.RUnlock()
	argsForCall := fake.pubSubShardChannelsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PubSubShardChannelsReturns(result1 *redisa.StringSliceCmd) {
	fake.pubSubShardChannelsMutex.Lock()
	defer fake.pubSubShardChannelsMutex.Unlock()
	fake.PubSubShardChannelsStub = nil
	fake.pubSubShardChannelsReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) PubSubShardChannelsReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.pubSubShardChannelsMutex.Lock()
	defer fake.pubSubShardChannelsMutex.Unlock()
	fake.PubSubShardChannelsStub = nil
	if fake.pubSubShardChannelsReturnsOnCall == nil {
		fake.pubSubShardChannelsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.pubSubShardChannelsReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) PubSubShardNumSub(arg1 context.Context, arg2 ...string) *redisa.MapStringIntCmd {
	fake.pubSubShardNumSubMutex.Lock()
	ret, specificReturn := fake.pubSubShardNumSubReturnsOnCall[len(fake.pubSubShardNumSubArgsForCall)]
	fake.pubSubShardNumSubArgsForCall = append(fake.pubSubShardNumSubArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.PubSubShardNumSubStub
	fakeReturns := fake.pubSubShardNumSubReturns
	fake.recordInvocation("PubSubShardNumSub", []interface{}{arg1, arg2})
	fake.pubSubShardNumSubMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PubSubShardNumSubCallCount() int {
	fake.pubSubShardNumSubMutex.RLock()
	defer fake.pubSubShardNumSubMutex.RUnlock()
	return len(fake.pubSubShardNumSubArgsForCall)
}

func (fake *FakeClient) PubSubShardNumSubCalls(stub func(context.Context, ...string) *redisa.MapStringIntCmd) {
	fake.pubSubShardNumSubMutex.Lock()
	defer fake.pubSubShardNumSubMutex.Unlock()
	fake.PubSubShardNumSubStub = stub
}

func (fake *FakeClient) PubSubShardNumSubArgsForCall(i int) (context.Context, []string) {
	fake.pubSubShardNumSubMutex.RLock()
	defer fake.pubSubShardNumSubMutex.RUnlock()
	argsForCall := fake.pubSubShardNumSubArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PubSubShardNumSubReturns(result1 *redisa.MapStringIntCmd) {
	fake.pubSubShardNumSubMutex.Lock()
	defer fake.pubSubShardNumSubMutex.Unlock()
	fake.PubSubShardNumSubStub = nil
	fake.pubSubShardNumSubReturns = struct {
		result1 *redisa.MapStringIntCmd
	}{result1}
}

func (fake *FakeClient) PubSubShardNumSubReturnsOnCall(i int, result1 *redisa.MapStringIntCmd) {
	fake.pubSubShardNumSubMutex.Lock()
	defer fake.pubSubShardNumSubMutex.Unlock()
	fake.PubSubShardNumSubStub = nil
	if fake.pubSubShardNumSubReturnsOnCall == nil {
		fake.pubSubShardNumSubReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringIntCmd
		})
	}
	fake.pubSubShardNumSubReturnsOnCall[i] = struct {
		result1 *redisa.MapStringIntCmd
	}{result1}
}

func (fake *FakeClient) Publish(arg1 context.Context, arg2 string, arg3 interface{}) *redisa.IntCmd {
	fake.publishMutex.Lock()
	ret, specificReturn := fake.publishReturnsOnCall[len(fake.publishArgsForCall)]
	fake.publishArgsForCall = append(fake.publishArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.PublishStub
	fakeReturns := fake.publishReturns
	fake.recordInvocation("Publish", []interface{}{arg1, arg2, arg3})
	fake.publishMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PublishCallCount() int {
	fake.publishMutex.RLock()
	defer fake.publishMutex.RUnlock()
	return len(fake.publishArgsForCall)
}

func (fake *FakeClient) PublishCalls(stub func(context.Context, string, interface{}) *redisa.IntCmd) {
	fake.publishMutex.Lock()
	defer fake.publishMutex.Unlock()
	fake.PublishStub = stub
}

func (fake *FakeClient) PublishArgsForCall(i int) (context.Context, string, interface{}) {
	fake.publishMutex.RLock()
	defer fake.publishMutex.RUnlock()
	argsForCall := fake.publishArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) PublishReturns(result1 *redisa.IntCmd) {
	fake.publishMutex.Lock()
	defer fake.publishMutex.Unlock()
	fake.PublishStub = nil
	fake.publishReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) PublishReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.publishMutex.Lock()
	defer fake.publishMutex.Unlock()
	fake.PublishStub = nil
	if fake.publishReturnsOnCall == nil {
		fake.publishReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.publishReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) Quit(arg1 context.Context) *redisa.StatusCmd {
	fake.quitMutex.Lock()
	ret, specificReturn := fake.quitReturnsOnCall[len(fake.quitArgsForCall)]
	fake.quitArgsForCall = append(fake.quitArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.QuitStub
	fakeReturns := fake.quitReturns
	fake.recordInvocation("Quit", []interface{}{arg1})
	fake.quitMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) QuitCallCount() int {
	fake.quitMutex.RLock()
	defer fake.quitMutex.RUnlock()
	return len(fake.quitArgsForCall)
}

func (fake *FakeClient) QuitCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.quitMutex.Lock()
	defer fake.quitMutex.Unlock()
	fake.QuitStub = stub
}

func (fake *FakeClient) QuitArgsForCall(i int) context.Context {
	fake.quitMutex.RLock()
	defer fake.quitMutex.RUnlock()
	argsForCall := fake.quitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) QuitReturns(result1 *redisa.StatusCmd) {
	fake.quitMutex.Lock()
	defer fake.quitMutex.Unlock()
	fake.QuitStub = nil
	fake.quitReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) QuitReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.quitMutex.Lock()
	defer fake.quitMutex.Unlock()
	fake.QuitStub = nil
	if fake.quitReturnsOnCall == nil {
		fake.quitReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.quitReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) RPop(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.rPopMutex.Lock()
	ret, specificReturn := fake.rPopReturnsOnCall[len(fake.rPopArgsForCall)]
	fake.rPopArgsForCall = append(fake.rPopArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.RPopStub
	fakeReturns := fake.rPopReturns
	fake.recordInvocation("RPop", []interface{}{arg1, arg2})
	fake.rPopMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RPopCallCount() int {
	fake.rPopMutex.RLock()
	defer fake.rPopMutex.RUnlock()
	return len(fake.rPopArgsForCall)
}

func (fake *FakeClient) RPopCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.rPopMutex.Lock()
	defer fake.rPopMutex.Unlock()
	fake.RPopStub = stub
}

func (fake *FakeClient) RPopArgsForCall(i int) (context.Context, string) {
	fake.rPopMutex.RLock()
	defer fake.rPopMutex.RUnlock()
	argsForCall := fake.rPopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) RPopReturns(result1 *redisa.StringCmd) {
	fake.rPopMutex.Lock()
	defer fake.rPopMutex.Unlock()
	fake.RPopStub = nil
	fake.rPopReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) RPopReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.rPopMutex.Lock()
	defer fake.rPopMutex.Unlock()
	fake.RPopStub = nil
	if fake.rPopReturnsOnCall == nil {
		fake.rPopReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.rPopReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) RPopCount(arg1 context.Context, arg2 string, arg3 int) *redisa.StringSliceCmd {
	fake.rPopCountMutex.Lock()
	ret, specificReturn := fake.rPopCountReturnsOnCall[len(fake.rPopCountArgsForCall)]
	fake.rPopCountArgsForCall = append(fake.rPopCountArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.RPopCountStub
	fakeReturns := fake.rPopCountReturns
	fake.recordInvocation("RPopCount", []interface{}{arg1, arg2, arg3})
	fake.rPopCountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RPopCountCallCount() int {
	fake.rPopCountMutex.RLock()
	defer fake.rPopCountMutex.RUnlock()
	return len(fake.rPopCountArgsForCall)
}

func (fake *FakeClient) RPopCountCalls(stub func(context.Context, string, int) *redisa.StringSliceCmd) {
	fake.rPopCountMutex.Lock()
	defer fake.rPopCountMutex.Unlock()
	fake.RPopCountStub = stub
}

func (fake *FakeClient) RPopCountArgsForCall(i int) (context.Context, string, int) {
	fake.rPopCountMutex.RLock()
	defer fake.rPopCountMutex.RUnlock()
	argsForCall := fake.rPopCountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) RPopCountReturns(result1 *redisa.StringSliceCmd) {
	fake.rPopCountMutex.Lock()
	defer fake.rPopCountMutex.Unlock()
	fake.RPopCountStub = nil
	fake.rPopCountReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) RPopCountReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.rPopCountMutex.Lock()
	defer fake.rPopCountMutex.Unlock()
	fake.RPopCountStub = nil
	if fake.rPopCountReturnsOnCall == nil {
		fake.rPopCountReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.rPopCountReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) RPopLPush(arg1 context.Context, arg2 string, arg3 string) *redisa.StringCmd {
	fake.rPopLPushMutex.Lock()
	ret, specificReturn := fake.rPopLPushReturnsOnCall[len(fake.rPopLPushArgsForCall)]
	fake.rPopLPushArgsForCall = append(fake.rPopLPushArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RPopLPushStub
	fakeReturns := fake.rPopLPushReturns
	fake.recordInvocation("RPopLPush", []interface{}{arg1, arg2, arg3})
	fake.rPopLPushMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RPopLPushCallCount() int {
	fake.rPopLPushMutex.RLock()
	defer fake.rPopLPushMutex.RUnlock()
	return len(fake.rPopLPushArgsForCall)
}

func (fake *FakeClient) RPopLPushCalls(stub func(context.Context, string, string) *redisa.StringCmd) {
	fake.rPopLPushMutex.Lock()
	defer fake.rPopLPushMutex.Unlock()
	fake.RPopLPushStub = stub
}

func (fake *FakeClient) RPopLPushArgsForCall(i int) (context.Context, string, string) {
	fake.rPopLPushMutex.RLock()
	defer fake.rPopLPushMutex.RUnlock()
	argsForCall := fake.rPopLPushArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) RPopLPushReturns(result1 *redisa.StringCmd) {
	fake.rPopLPushMutex.Lock()
	defer fake.rPopLPushMutex.Unlock()
	fake.RPopLPushStub = nil
	fake.rPopLPushReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) RPopLPushReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.rPopLPushMutex.Lock()
	defer fake.rPopLPushMutex.Unlock()
	fake.RPopLPushStub = nil
	if fake.rPopLPushReturnsOnCall == nil {
		fake.rPopLPushReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.rPopLPushReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) RPush(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntCmd {
	fake.rPushMutex.Lock()
	ret, specificReturn := fake.rPushReturnsOnCall[len(fake.rPushArgsForCall)]
	fake.rPushArgsForCall = append(fake.rPushArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.RPushStub
	fakeReturns := fake.rPushReturns
	fake.recordInvocation("RPush", []interface{}{arg1, arg2, arg3})
	fake.rPushMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RPushCallCount() int {
	fake.rPushMutex.RLock()
	defer fake.rPushMutex.RUnlock()
	return len(fake.rPushArgsForCall)
}

func (fake *FakeClient) RPushCalls(stub func(context.Context, string, ...interface{}) *redisa.IntCmd) {
	fake.rPushMutex.Lock()
	defer fake.rPushMutex.Unlock()
	fake.RPushStub = stub
}

func (fake *FakeClient) RPushArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.rPushMutex.RLock()
	defer fake.rPushMutex.RUnlock()
	argsForCall := fake.rPushArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) RPushReturns(result1 *redisa.IntCmd) {
	fake.rPushMutex.Lock()
	defer fake.rPushMutex.Unlock()
	fake.RPushStub = nil
	fake.rPushReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) RPushReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.rPushMutex.Lock()
	defer fake.rPushMutex.Unlock()
	fake.RPushStub = nil
	if fake.rPushReturnsOnCall == nil {
		fake.rPushReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.rPushReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) RPushX(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntCmd {
	fake.rPushXMutex.Lock()
	ret, specificReturn := fake.rPushXReturnsOnCall[len(fake.rPushXArgsForCall)]
	fake.rPushXArgsForCall = append(fake.rPushXArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.RPushXStub
	fakeReturns := fake.rPushXReturns
	fake.recordInvocation("RPushX", []interface{}{arg1, arg2, arg3})
	fake.rPushXMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RPushXCallCount() int {
	fake.rPushXMutex.RLock()
	defer fake.rPushXMutex.RUnlock()
	return len(fake.rPushXArgsForCall)
}

func (fake *FakeClient) RPushXCalls(stub func(context.Context, string, ...interface{}) *redisa.IntCmd) {
	fake.rPushXMutex.Lock()
	defer fake.rPushXMutex.Unlock()
	fake.RPushXStub = stub
}

func (fake *FakeClient) RPushXArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.rPushXMutex.RLock()
	defer fake.rPushXMutex.RUnlock()
	argsForCall := fake.rPushXArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) RPushXReturns(result1 *redisa.IntCmd) {
	fake.rPushXMutex.Lock()
	defer fake.rPushXMutex.Unlock()
	fake.RPushXStub = nil
	fake.rPushXReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) RPushXReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.rPushXMutex.Lock()
	defer fake.rPushXMutex.Unlock()
	fake.RPushXStub = nil
	if fake.rPushXReturnsOnCall == nil {
		fake.rPushXReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.rPushXReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) RandomKey(arg1 context.Context) *redisa.StringCmd {
	fake.randomKeyMutex.Lock()
	ret, specificReturn := fake.randomKeyReturnsOnCall[len(fake.randomKeyArgsForCall)]
	fake.randomKeyArgsForCall = append(fake.randomKeyArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.RandomKeyStub
	fakeReturns := fake.randomKeyReturns
	fake.recordInvocation("RandomKey", []interface{}{arg1})
	fake.randomKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RandomKeyCallCount() int {
	fake.randomKeyMutex.RLock()
	defer fake.randomKeyMutex.RUnlock()
	return len(fake.randomKeyArgsForCall)
}

func (fake *FakeClient) RandomKeyCalls(stub func(context.Context) *redisa.StringCmd) {
	fake.randomKeyMutex.Lock()
	defer fake.randomKeyMutex.Unlock()
	fake.RandomKeyStub = stub
}

func (fake *FakeClient) RandomKeyArgsForCall(i int) context.Context {
	fake.randomKeyMutex.RLock()
	defer fake.randomKeyMutex.RUnlock()
	argsForCall := fake.randomKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) RandomKeyReturns(result1 *redisa.StringCmd) {
	fake.randomKeyMutex.Lock()
	defer fake.randomKeyMutex.Unlock()
	fake.RandomKeyStub = nil
	fake.randomKeyReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) RandomKeyReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.randomKeyMutex.Lock()
	defer fake.randomKeyMutex.Unlock()
	fake.RandomKeyStub = nil
	if fake.randomKeyReturnsOnCall == nil {
		fake.randomKeyReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.randomKeyReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ReadOnly(arg1 context.Context) *redisa.StatusCmd {
	fake.readOnlyMutex.Lock()
	ret, specificReturn := fake.readOnlyReturnsOnCall[len(fake.readOnlyArgsForCall)]
	fake.readOnlyArgsForCall = append(fake.readOnlyArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ReadOnlyStub
	fakeReturns := fake.readOnlyReturns
	fake.recordInvocation("ReadOnly", []interface{}{arg1})
	fake.readOnlyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ReadOnlyCallCount() int {
	fake.readOnlyMutex.RLock()
	defer fake.readOnlyMutex.RUnlock()
	return len(fake.readOnlyArgsForCall)
}

func (fake *FakeClient) ReadOnlyCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.readOnlyMutex.Lock()
	defer fake.readOnlyMutex.Unlock()
	fake.ReadOnlyStub = stub
}

func (fake *FakeClient) ReadOnlyArgsForCall(i int) context.Context {
	fake.readOnlyMutex.RLock()
	defer fake.readOnlyMutex.RUnlock()
	argsForCall := fake.readOnlyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ReadOnlyReturns(result1 *redisa.StatusCmd) {
	fake.readOnlyMutex.Lock()
	defer fake.readOnlyMutex.Unlock()
	fake.ReadOnlyStub = nil
	fake.readOnlyReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ReadOnlyReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.readOnlyMutex.Lock()
	defer fake.readOnlyMutex.Unlock()
	fake.ReadOnlyStub = nil
	if fake.readOnlyReturnsOnCall == nil {
		fake.readOnlyReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.readOnlyReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ReadWrite(arg1 context.Context) *redisa.StatusCmd {
	fake.readWriteMutex.Lock()
	ret, specificReturn := fake.readWriteReturnsOnCall[len(fake.readWriteArgsForCall)]
	fake.readWriteArgsForCall = append(fake.readWriteArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ReadWriteStub
	fakeReturns := fake.readWriteReturns
	fake.recordInvocation("ReadWrite", []interface{}{arg1})
	fake.readWriteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ReadWriteCallCount() int {
	fake.readWriteMutex.RLock()
	defer fake.readWriteMutex.RUnlock()
	return len(fake.readWriteArgsForCall)
}

func (fake *FakeClient) ReadWriteCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.readWriteMutex.Lock()
	defer fake.readWriteMutex.Unlock()
	fake.ReadWriteStub = stub
}

func (fake *FakeClient) ReadWriteArgsForCall(i int) context.Context {
	fake.readWriteMutex.RLock()
	defer fake.readWriteMutex.RUnlock()
	argsForCall := fake.readWriteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ReadWriteReturns(result1 *redisa.StatusCmd) {
	fake.readWriteMutex.Lock()
	defer fake.readWriteMutex.Unlock()
	fake.ReadWriteStub = nil
	fake.readWriteReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ReadWriteReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.readWriteMutex.Lock()
	defer fake.readWriteMutex.Unlock()
	fake.ReadWriteStub = nil
	if fake.readWriteReturnsOnCall == nil {
		fake.readWriteReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.readWriteReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) Rename(arg1 context.Context, arg2 string, arg3 string) *redisa.StatusCmd {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RenameStub
	fakeReturns := fake.renameReturns
	fake.recordInvocation("Rename", []interface{}{arg1, arg2, arg3})
	fake.renameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakeClient) RenameCalls(stub func(context.Context, string, string) *redisa.StatusCmd) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = stub
}

func (fake *FakeClient) RenameArgsForCall(i int) (context.Context, string, string) {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	argsForCall := fake.renameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) RenameReturns(result1 *redisa.StatusCmd) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) RenameReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) RenameNX(arg1 context.Context, arg2 string, arg3 string) *redisa.BoolCmd {
	fake.renameNXMutex.Lock()
	ret, specificReturn := fake.renameNXReturnsOnCall[len(fake.renameNXArgsForCall)]
	fake.renameNXArgsForCall = append(fake.renameNXArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RenameNXStub
	fakeReturns := fake.renameNXReturns
	fake.recordInvocation("RenameNX", []interface{}{arg1, arg2, arg3})
	fake.renameNXMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RenameNXCallCount() int {
	fake.renameNXMutex.RLock()
	defer fake.renameNXMutex.RUnlock()
	return len(fake.renameNXArgsForCall)
}

func (fake *FakeClient) RenameNXCalls(stub func(context.Context, string, string) *redisa.BoolCmd) {
	fake.renameNXMutex.Lock()
	defer fake.renameNXMutex.Unlock()
	fake.RenameNXStub = stub
}

func (fake *FakeClient) RenameNXArgsForCall(i int) (context.Context, string, string) {
	fake.renameNXMutex.RLock()
	defer fake.renameNXMutex.RUnlock()
	argsForCall := fake.renameNXArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) RenameNXReturns(result1 *redisa.BoolCmd) {
	fake.renameNXMutex.Lock()
	defer fake.renameNXMutex.Unlock()
	fake.RenameNXStub = nil
	fake.renameNXReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) RenameNXReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.renameNXMutex.Lock()
	defer fake.renameNXMutex.Unlock()
	fake.RenameNXStub = nil
	if fake.renameNXReturnsOnCall == nil {
		fake.renameNXReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.renameNXReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) Restore(arg1 context.Context, arg2 string, arg3 time.Duration, arg4 string) *redisa.StatusCmd {
	fake.restoreMutex.Lock()
	ret, specificReturn := fake.restoreReturnsOnCall[len(fake.restoreArgsForCall)]
	fake.restoreArgsForCall = append(fake.restoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RestoreStub
	fakeReturns := fake.restoreReturns
	fake.recordInvocation("Restore", []interface{}{arg1, arg2, arg3, arg4})
	fake.restoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RestoreCallCount() int {
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	return len(fake.restoreArgsForCall)
}

func (fake *FakeClient) RestoreCalls(stub func(context.Context, string, time.Duration, string) *redisa.StatusCmd) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = stub
}

func (fake *FakeClient) RestoreArgsForCall(i int) (context.Context, string, time.Duration, string) {
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	argsForCall := fake.restoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) RestoreReturns(result1 *redisa.StatusCmd) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = nil
	fake.restoreReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) RestoreReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.restoreMutex.Lock()
	defer fake.restoreMutex.Unlock()
	fake.RestoreStub = nil
	if fake.restoreReturnsOnCall == nil {
		fake.restoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.restoreReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) RestoreReplace(arg1 context.Context, arg2 string, arg3 time.Duration, arg4 string) *redisa.StatusCmd {
	fake.restoreReplaceMutex.Lock()
	ret, specificReturn := fake.restoreReplaceReturnsOnCall[len(fake.restoreReplaceArgsForCall)]
	fake.restoreReplaceArgsForCall = append(fake.restoreReplaceArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 time.Duration
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RestoreReplaceStub
	fakeReturns := fake.restoreReplaceReturns
	fake.recordInvocation("RestoreReplace", []interface{}{arg1, arg2, arg3, arg4})
	fake.restoreReplaceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RestoreReplaceCallCount() int {
	fake.restoreReplaceMutex.RLock()
	defer fake.restoreReplaceMutex.RUnlock()
	return len(fake.restoreReplaceArgsForCall)
}

func (fake *FakeClient) RestoreReplaceCalls(stub func(context.Context, string, time.Duration, string) *redisa.StatusCmd) {
	fake.restoreReplaceMutex.Lock()
	defer fake.restoreReplaceMutex.Unlock()
	fake.RestoreReplaceStub = stub
}

func (fake *FakeClient) RestoreReplaceArgsForCall(i int) (context.Context, string, time.Duration, string) {
	fake.restoreReplaceMutex.RLock()
	defer fake.restoreReplaceMutex.RUnlock()
	argsForCall := fake.restoreReplaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) RestoreReplaceReturns(result1 *redisa.StatusCmd) {
	fake.restoreReplaceMutex.Lock()
	defer fake.restoreReplaceMutex.Unlock()
	fake.RestoreReplaceStub = nil
	fake.restoreReplaceReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) RestoreReplaceReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.restoreReplaceMutex.Lock()
	defer fake.restoreReplaceMutex.Unlock()
	fake.RestoreReplaceStub = nil
	if fake.restoreReplaceReturnsOnCall == nil {
		fake.restoreReplaceReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.restoreReplaceReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) SAdd(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntCmd {
	fake.sAddMutex.Lock()
	ret, specificReturn := fake.sAddReturnsOnCall[len(fake.sAddArgsForCall)]
	fake.sAddArgsForCall = append(fake.sAddArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.SAddStub
	fakeReturns := fake.sAddReturns
	fake.recordInvocation("SAdd", []interface{}{arg1, arg2, arg3})
	fake.sAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SAddCallCount() int {
	fake.sAddMutex.RLock()
	defer fake.sAddMutex.RUnlock()
	return len(fake.sAddArgsForCall)
}

func (fake *FakeClient) SAddCalls(stub func(context.Context, string, ...interface{}) *redisa.IntCmd) {
	fake.sAddMutex.Lock()
	defer fake.sAddMutex.Unlock()
	fake.SAddStub = stub
}

func (fake *FakeClient) SAddArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.sAddMutex.RLock()
	defer fake.sAddMutex.RUnlock()
	argsForCall := fake.sAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SAddReturns(result1 *redisa.IntCmd) {
	fake.sAddMutex.Lock()
	defer fake.sAddMutex.Unlock()
	fake.SAddStub = nil
	fake.sAddReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SAddReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.sAddMutex.Lock()
	defer fake.sAddMutex.Unlock()
	fake.SAddStub = nil
	if fake.sAddReturnsOnCall == nil {
		fake.sAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.sAddReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SCard(arg1 context.Context, arg2 string) *redisa.IntCmd {
	fake.sCardMutex.Lock()
	ret, specificReturn := fake.sCardReturnsOnCall[len(fake.sCardArgsForCall)]
	fake.sCardArgsForCall = append(fake.sCardArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.SCardStub
	fakeReturns := fake.sCardReturns
	fake.recordInvocation("SCard", []interface{}{arg1, arg2})
	fake.sCardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SCardCallCount() int {
	fake.sCardMutex.RLock()
	defer fake.sCardMutex.RUnlock()
	return len(fake.sCardArgsForCall)
}

func (fake *FakeClient) SCardCalls(stub func(context.Context, string) *redisa.IntCmd) {
	fake.sCardMutex.Lock()
	defer fake.sCardMutex.Unlock()
	fake.SCardStub = stub
}

func (fake *FakeClient) SCardArgsForCall(i int) (context.Context, string) {
	fake.sCardMutex.RLock()
	defer fake.sCardMutex.RUnlock()
	argsForCall := fake.sCardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SCardReturns(result1 *redisa.IntCmd) {
	fake.sCardMutex.Lock()
	defer fake.sCardMutex.Unlock()
	fake.SCardStub = nil
	fake.sCardReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SCardReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.sCardMutex.Lock()
	defer fake.sCardMutex.Unlock()
	fake.SCardStub = nil
	if fake.sCardReturnsOnCall == nil {
		fake.sCardReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.sCardReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SDiff(arg1 context.Context, arg2 ...string) *redisa.StringSliceCmd {
	fake.sDiffMutex.Lock()
	ret, specificReturn := fake.sDiffReturnsOnCall[len(fake.sDiffArgsForCall)]
	fake.sDiffArgsForCall = append(fake.sDiffArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.SDiffStub
	fakeReturns := fake.sDiffReturns
	fake.recordInvocation("SDiff", []interface{}{arg1, arg2})
	fake.sDiffMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SDiffCallCount() int {
	fake.sDiffMutex.RLock()
	defer fake.sDiffMutex.RUnlock()
	return len(fake.sDiffArgsForCall)
}

func (fake *FakeClient) SDiffCalls(stub func(context.Context, ...string) *redisa.StringSliceCmd) {
	fake.sDiffMutex.Lock()
	defer fake.sDiffMutex.Unlock()
	fake.SDiffStub = stub
}

func (fake *FakeClient) SDiffArgsForCall(i int) (context.Context, []string) {
	fake.sDiffMutex.RLock()
	defer fake.sDiffMutex.RUnlock()
	argsForCall := fake.sDiffArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SDiffReturns(result1 *redisa.StringSliceCmd) {
	fake.sDiffMutex.Lock()
	defer fake.sDiffMutex.Unlock()
	fake.SDiffStub = nil
	fake.sDiffReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SDiffReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.sDiffMutex.Lock()
	defer fake.sDiffMutex.Unlock()
	fake.SDiffStub = nil
	if fake.sDiffReturnsOnCall == nil {
		fake.sDiffReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.sDiffReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SDiffStore(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntCmd {
	fake.sDiffStoreMutex.Lock()
	ret, specificReturn := fake.sDiffStoreReturnsOnCall[len(fake.sDiffStoreArgsForCall)]
	fake.sDiffStoreArgsForCall = append(fake.sDiffStoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.SDiffStoreStub
	fakeReturns := fake.sDiffStoreReturns
	fake.recordInvocation("SDiffStore", []interface{}{arg1, arg2, arg3})
	fake.sDiffStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SDiffStoreCallCount() int {
	fake.sDiffStoreMutex.RLock()
	defer fake.sDiffStoreMutex.RUnlock()
	return len(fake.sDiffStoreArgsForCall)
}

func (fake *FakeClient) SDiffStoreCalls(stub func(context.Context, string, ...string) *redisa.IntCmd) {
	fake.sDiffStoreMutex.Lock()
	defer fake.sDiffStoreMutex.Unlock()
	fake.SDiffStoreStub = stub
}

func (fake *FakeClient) SDiffStoreArgsForCall(i int) (context.Context, string, []string) {
	fake.sDiffStoreMutex.RLock()
	defer fake.sDiffStoreMutex.RUnlock()
	argsForCall := fake.sDiffStoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SDiffStoreReturns(result1 *redisa.IntCmd) {
	fake.sDiffStoreMutex.Lock()
	defer fake.sDiffStoreMutex.Unlock()
	fake.SDiffStoreStub = nil
	fake.sDiffStoreReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SDiffStoreReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.sDiffStoreMutex.Lock()
	defer fake.sDiffStoreMutex.Unlock()
	fake.SDiffStoreStub = nil
	if fake.sDiffStoreReturnsOnCall == nil {
		fake.sDiffStoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.sDiffStoreReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SInter(arg1 context.Context, arg2 ...string) *redisa.StringSliceCmd {
	fake.sInterMutex.Lock()
	ret, specificReturn := fake.sInterReturnsOnCall[len(fake.sInterArgsForCall)]
	fake.sInterArgsForCall = append(fake.sInterArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.SInterStub
	fakeReturns := fake.sInterReturns
	fake.recordInvocation("SInter", []interface{}{arg1, arg2})
	fake.sInterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SInterCallCount() int {
	fake.sInterMutex.RLock()
	defer fake.sInterMutex.RUnlock()
	return len(fake.sInterArgsForCall)
}

func (fake *FakeClient) SInterCalls(stub func(context.Context, ...string) *redisa.StringSliceCmd) {
	fake.sInterMutex.Lock()
	defer fake.sInterMutex.Unlock()
	fake.SInterStub = stub
}

func (fake *FakeClient) SInterArgsForCall(i int) (context.Context, []string) {
	fake.sInterMutex.RLock()
	defer fake.sInterMutex.RUnlock()
	argsForCall := fake.sInterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SInterReturns(result1 *redisa.StringSliceCmd) {
	fake.sInterMutex.Lock()
	defer fake.sInterMutex.Unlock()
	fake.SInterStub = nil
	fake.sInterReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SInterReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.sInterMutex.Lock()
	defer fake.sInterMutex.Unlock()
	fake.SInterStub = nil
	if fake.sInterReturnsOnCall == nil {
		fake.sInterReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.sInterReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SInterCard(arg1 context.Context, arg2 int64, arg3 ...string) *redisa.IntCmd {
	fake.sInterCardMutex.Lock()
	ret, specificReturn := fake.sInterCardReturnsOnCall[len(fake.sInterCardArgsForCall)]
	fake.sInterCardArgsForCall = append(fake.sInterCardArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.SInterCardStub
	fakeReturns := fake.sInterCardReturns
	fake.recordInvocation("SInterCard", []interface{}{arg1, arg2, arg3})
	fake.sInterCardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SInterCardCallCount() int {
	fake.sInterCardMutex.RLock()
	defer fake.sInterCardMutex.RUnlock()
	return len(fake.sInterCardArgsForCall)
}

func (fake *FakeClient) SInterCardCalls(stub func(context.Context, int64, ...string) *redisa.IntCmd) {
	fake.sInterCardMutex.Lock()
	defer fake.sInterCardMutex.Unlock()
	fake.SInterCardStub = stub
}

func (fake *FakeClient) SInterCardArgsForCall(i int) (context.Context, int64, []string) {
	fake.sInterCardMutex.RLock()
	defer fake.sInterCardMutex.RUnlock()
	argsForCall := fake.sInterCardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SInterCardReturns(result1 *redisa.IntCmd) {
	fake.sInterCardMutex.Lock()
	defer fake.sInterCardMutex.Unlock()
	fake.SInterCardStub = nil
	fake.sInterCardReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SInterCardReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.sInterCardMutex.Lock()
	defer fake.sInterCardMutex.Unlock()
	fake.SInterCardStub = nil
	if fake.sInterCardReturnsOnCall == nil {
		fake.sInterCardReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.sInterCardReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SInterStore(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntCmd {
	fake.sInterStoreMutex.Lock()
	ret, specificReturn := fake.sInterStoreReturnsOnCall[len(fake.sInterStoreArgsForCall)]
	fake.sInterStoreArgsForCall = append(fake.sInterStoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.SInterStoreStub
	fakeReturns := fake.sInterStoreReturns
	fake.recordInvocation("SInterStore", []interface{}{arg1, arg2, arg3})
	fake.sInterStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SInterStoreCallCount() int {
	fake.sInterStoreMutex.RLock()
	defer fake.sInterStoreMutex.RUnlock()
	return len(fake.sInterStoreArgsForCall)
}

func (fake *FakeClient) SInterStoreCalls(stub func(context.Context, string, ...string) *redisa.IntCmd) {
	fake.sInterStoreMutex.Lock()
	defer fake.sInterStoreMutex.Unlock()
	fake.SInterStoreStub = stub
}

func (fake *FakeClient) SInterStoreArgsForCall(i int) (context.Context, string, []string) {
	fake.sInterStoreMutex.RLock()
	defer fake.sInterStoreMutex.RUnlock()
	argsForCall := fake.sInterStoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SInterStoreReturns(result1 *redisa.IntCmd) {
	fake.sInterStoreMutex.Lock()
	defer fake.sInterStoreMutex.Unlock()
	fake.SInterStoreStub = nil
	fake.sInterStoreReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SInterStoreReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.sInterStoreMutex.Lock()
	defer fake.sInterStoreMutex.Unlock()
	fake.SInterStoreStub = nil
	if fake.sInterStoreReturnsOnCall == nil {
		fake.sInterStoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.sInterStoreReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SIsMember(arg1 context.Context, arg2 string, arg3 interface{}) *redisa.BoolCmd {
	fake.sIsMemberMutex.Lock()
	ret, specificReturn := fake.sIsMemberReturnsOnCall[len(fake.sIsMemberArgsForCall)]
	fake.sIsMemberArgsForCall = append(fake.sIsMemberArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.SIsMemberStub
	fakeReturns := fake.sIsMemberReturns
	fake.recordInvocation("SIsMember", []interface{}{arg1, arg2, arg3})
	fake.sIsMemberMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SIsMemberCallCount() int {
	fake.sIsMemberMutex.RLock()
	defer fake.sIsMemberMutex.RUnlock()
	return len(fake.sIsMemberArgsForCall)
}

func (fake *FakeClient) SIsMemberCalls(stub func(context.Context, string, interface{}) *redisa.BoolCmd) {
	fake.sIsMemberMutex.Lock()
	defer fake.sIsMemberMutex.Unlock()
	fake.SIsMemberStub = stub
}

func (fake *FakeClient) SIsMemberArgsForCall(i int) (context.Context, string, interface{}) {
	fake.sIsMemberMutex.RLock()
	defer fake.sIsMemberMutex.RUnlock()
	argsForCall := fake.sIsMemberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SIsMemberReturns(result1 *redisa.BoolCmd) {
	fake.sIsMemberMutex.Lock()
	defer fake.sIsMemberMutex.Unlock()
	fake.SIsMemberStub = nil
	fake.sIsMemberReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) SIsMemberReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.sIsMemberMutex.Lock()
	defer fake.sIsMemberMutex.Unlock()
	fake.SIsMemberStub = nil
	if fake.sIsMemberReturnsOnCall == nil {
		fake.sIsMemberReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.sIsMemberReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) SMIsMember(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.BoolSliceCmd {
	fake.sMIsMemberMutex.Lock()
	ret, specificReturn := fake.sMIsMemberReturnsOnCall[len(fake.sMIsMemberArgsForCall)]
	fake.sMIsMemberArgsForCall = append(fake.sMIsMemberArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.SMIsMemberStub
	fakeReturns := fake.sMIsMemberReturns
	fake.recordInvocation("SMIsMember", []interface{}{arg1, arg2, arg3})
	fake.sMIsMemberMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SMIsMemberCallCount() int {
	fake.sMIsMemberMutex.RLock()
	defer fake.sMIsMemberMutex.RUnlock()
	return len(fake.sMIsMemberArgsForCall)
}

func (fake *FakeClient) SMIsMemberCalls(stub func(context.Context, string, ...interface{}) *redisa.BoolSliceCmd) {
	fake.sMIsMemberMutex.Lock()
	defer fake.sMIsMemberMutex.Unlock()
	fake.SMIsMemberStub = stub
}

func (fake *FakeClient) SMIsMemberArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.sMIsMemberMutex.RLock()
	defer fake.sMIsMemberMutex.RUnlock()
	argsForCall := fake.sMIsMemberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SMIsMemberReturns(result1 *redisa.BoolSliceCmd) {
	fake.sMIsMemberMutex.Lock()
	defer fake.sMIsMemberMutex.Unlock()
	fake.SMIsMemberStub = nil
	fake.sMIsMemberReturns = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) SMIsMemberReturnsOnCall(i int, result1 *redisa.BoolSliceCmd) {
	fake.sMIsMemberMutex.Lock()
	defer fake.sMIsMemberMutex.Unlock()
	fake.SMIsMemberStub = nil
	if fake.sMIsMemberReturnsOnCall == nil {
		fake.sMIsMemberReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolSliceCmd
		})
	}
	fake.sMIsMemberReturnsOnCall[i] = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) SMembers(arg1 context.Context, arg2 string) *redisa.StringSliceCmd {
	fake.sMembersMutex.Lock()
	ret, specificReturn := fake.sMembersReturnsOnCall[len(fake.sMembersArgsForCall)]
	fake.sMembersArgsForCall = append(fake.sMembersArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.SMembersStub
	fakeReturns := fake.sMembersReturns
	fake.recordInvocation("SMembers", []interface{}{arg1, arg2})
	fake.sMembersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SMembersCallCount() int {
	fake.sMembersMutex.RLock()
	defer fake.sMembersMutex.RUnlock()
	return len(fake.sMembersArgsForCall)
}

func (fake *FakeClient) SMembersCalls(stub func(context.Context, string) *redisa.StringSliceCmd) {
	fake.sMembersMutex.Lock()
	defer fake.sMembersMutex.Unlock()
	fake.SMembersStub = stub
}

func (fake *FakeClient) SMembersArgsForCall(i int) (context.Context, string) {
	fake.sMembersMutex.RLock()
	defer fake.sMembersMutex.RUnlock()
	argsForCall := fake.sMembersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SMembersReturns(result1 *redisa.StringSliceCmd) {
	fake.sMembersMutex.Lock()
	defer fake.sMembersMutex.Unlock()
	fake.SMembersStub = nil
	fake.sMembersReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SMembersReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.sMembersMutex.Lock()
	defer fake.sMembersMutex.Unlock()
	fake.SMembersStub = nil
	if fake.sMembersReturnsOnCall == nil {
		fake.sMembersReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.sMembersReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SMembersMap(arg1 context.Context, arg2 string) *redisa.StringStructMapCmd {
	fake.sMembersMapMutex.Lock()
	ret, specificReturn := fake.sMembersMapReturnsOnCall[len(fake.sMembersMapArgsForCall)]
	fake.sMembersMapArgsForCall = append(fake.sMembersMapArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.SMembersMapStub
	fakeReturns := fake.sMembersMapReturns
	fake.recordInvocation("SMembersMap", []interface{}{arg1, arg2})
	fake.sMembersMapMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SMembersMapCallCount() int {
	fake.sMembersMapMutex.RLock()
	defer fake.sMembersMapMutex.RUnlock()
	return len(fake.sMembersMapArgsForCall)
}

func (fake *FakeClient) SMembersMapCalls(stub func(context.Context, string) *redisa.StringStructMapCmd) {
	fake.sMembersMapMutex.Lock()
	defer fake.sMembersMapMutex.Unlock()
	fake.SMembersMapStub = stub
}

func (fake *FakeClient) SMembersMapArgsForCall(i int) (context.Context, string) {
	fake.sMembersMapMutex.RLock()
	defer fake.sMembersMapMutex.RUnlock()
	argsForCall := fake.sMembersMapArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SMembersMapReturns(result1 *redisa.StringStructMapCmd) {
	fake.sMembersMapMutex.Lock()
	defer fake.sMembersMapMutex.Unlock()
	fake.SMembersMapStub = nil
	fake.sMembersMapReturns = struct {
		result1 *redisa.StringStructMapCmd
	}{result1}
}

func (fake *FakeClient) SMembersMapReturnsOnCall(i int, result1 *redisa.StringStructMapCmd) {
	fake.sMembersMapMutex.Lock()
	defer fake.sMembersMapMutex.Unlock()
	fake.SMembersMapStub = nil
	if fake.sMembersMapReturnsOnCall == nil {
		fake.sMembersMapReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringStructMapCmd
		})
	}
	fake.sMembersMapReturnsOnCall[i] = struct {
		result1 *redisa.StringStructMapCmd
	}{result1}
}

func (fake *FakeClient) SMove(arg1 context.Context, arg2 string, arg3 string, arg4 interface{}) *redisa.BoolCmd {
	fake.sMoveMutex.Lock()
	ret, specificReturn := fake.sMoveReturnsOnCall[len(fake.sMoveArgsForCall)]
	fake.sMoveArgsForCall = append(fake.sMoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.SMoveStub
	fakeReturns := fake.sMoveReturns
	fake.recordInvocation("SMove", []interface{}{arg1, arg2, arg3, arg4})
	fake.sMoveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SMoveCallCount() int {
	fake.sMoveMutex.RLock()
	defer fake.sMoveMutex.RUnlock()
	return len(fake.sMoveArgsForCall)
}

func (fake *FakeClient) SMoveCalls(stub func(context.Context, string, string, interface{}) *redisa.BoolCmd) {
	fake.sMoveMutex.Lock()
	defer fake.sMoveMutex.Unlock()
	fake.SMoveStub = stub
}

func (fake *FakeClient) SMoveArgsForCall(i int) (context.Context, string, string, interface{}) {
	fake.sMoveMutex.RLock()
	defer fake.sMoveMutex.RUnlock()
	argsForCall := fake.sMoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) SMoveReturns(result1 *redisa.BoolCmd) {
	fake.sMoveMutex.Lock()
	defer fake.sMoveMutex.Unlock()
	fake.SMoveStub = nil
	fake.sMoveReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) SMoveReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.sMoveMutex.Lock()
	defer fake.sMoveMutex.Unlock()
	fake.SMoveStub = nil
	if fake.sMoveReturnsOnCall == nil {
		fake.sMoveReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.sMoveReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) SPop(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.sPopMutex.Lock()
	ret, specificReturn := fake.sPopReturnsOnCall[len(fake.sPopArgsForCall)]
	fake.sPopArgsForCall = append(fake.sPopArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.SPopStub
	fakeReturns := fake.sPopReturns
	fake.recordInvocation("SPop", []interface{}{arg1, arg2})
	fake.sPopMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SPopCallCount() int {
	fake.sPopMutex.RLock()
	defer fake.sPopMutex.RUnlock()
	return len(fake.sPopArgsForCall)
}

func (fake *FakeClient) SPopCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.sPopMutex.Lock()
	defer fake.sPopMutex.Unlock()
	fake.SPopStub = stub
}

func (fake *FakeClient) SPopArgsForCall(i int) (context.Context, string) {
	fake.sPopMutex.RLock()
	defer fake.sPopMutex.RUnlock()
	argsForCall := fake.sPopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SPopReturns(result1 *redisa.StringCmd) {
	fake.sPopMutex.Lock()
	defer fake.sPopMutex.Unlock()
	fake.SPopStub = nil
	fake.sPopReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) SPopReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.sPopMutex.Lock()
	defer fake.sPopMutex.Unlock()
	fake.SPopStub = nil
	if fake.sPopReturnsOnCall == nil {
		fake.sPopReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.sPopReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) SPopN(arg1 context.Context, arg2 string, arg3 int64) *redisa.StringSliceCmd {
	fake.sPopNMutex.Lock()
	ret, specificReturn := fake.sPopNReturnsOnCall[len(fake.sPopNArgsForCall)]
	fake.sPopNArgsForCall = append(fake.sPopNArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.SPopNStub
	fakeReturns := fake.sPopNReturns
	fake.recordInvocation("SPopN", []interface{}{arg1, arg2, arg3})
	fake.sPopNMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SPopNCallCount() int {
	fake.sPopNMutex.RLock()
	defer fake.sPopNMutex.RUnlock()
	return len(fake.sPopNArgsForCall)
}

func (fake *FakeClient) SPopNCalls(stub func(context.Context, string, int64) *redisa.StringSliceCmd) {
	fake.sPopNMutex.Lock()
	defer fake.sPopNMutex.Unlock()
	fake.SPopNStub = stub
}

func (fake *FakeClient) SPopNArgsForCall(i int) (context.Context, string, int64) {
	fake.sPopNMutex.RLock()
	defer fake.sPopNMutex.RUnlock()
	argsForCall := fake.sPopNArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SPopNReturns(result1 *redisa.StringSliceCmd) {
	fake.sPopNMutex.Lock()
	defer fake.sPopNMutex.Unlock()
	fake.SPopNStub = nil
	fake.sPopNReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SPopNReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.sPopNMutex.Lock()
	defer fake.sPopNMutex.Unlock()
	fake.SPopNStub = nil
	if fake.sPopNReturnsOnCall == nil {
		fake.sPopNReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.sPopNReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SPublish(arg1 context.Context, arg2 string, arg3 interface{}) *redisa.IntCmd {
	fake.sPublishMutex.Lock()
	ret, specificReturn := fake.sPublishReturnsOnCall[len(fake.sPublishArgsForCall)]
	fake.sPublishArgsForCall = append(fake.sPublishArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.SPublishStub
	fakeReturns := fake.sPublishReturns
	fake.recordInvocation("SPublish", []interface{}{arg1, arg2, arg3})
	fake.sPublishMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SPublishCallCount() int {
	fake.sPublishMutex.RLock()
	defer fake.sPublishMutex.RUnlock()
	return len(fake.sPublishArgsForCall)
}

func (fake *FakeClient) SPublishCalls(stub func(context.Context, string, interface{}) *redisa.IntCmd) {
	fake.sPublishMutex.Lock()
	defer fake.sPublishMutex.Unlock()
	fake.SPublishStub = stub
}

func (fake *FakeClient) SPublishArgsForCall(i int) (context.Context, string, interface{}) {
	fake.sPublishMutex.RLock()
	defer fake.sPublishMutex.RUnlock()
	argsForCall := fake.sPublishArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SPublishReturns(result1 *redisa.IntCmd) {
	fake.sPublishMutex.Lock()
	defer fake.sPublishMutex.Unlock()
	fake.SPublishStub = nil
	fake.sPublishReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SPublishReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.sPublishMutex.Lock()
	defer fake.sPublishMutex.Unlock()
	fake.SPublishStub = nil
	if fake.sPublishReturnsOnCall == nil {
		fake.sPublishReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.sPublishReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SRandMember(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.sRandMemberMutex.Lock()
	ret, specificReturn := fake.sRandMemberReturnsOnCall[len(fake.sRandMemberArgsForCall)]
	fake.sRandMemberArgsForCall = append(fake.sRandMemberArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.SRandMemberStub
	fakeReturns := fake.sRandMemberReturns
	fake.recordInvocation("SRandMember", []interface{}{arg1, arg2})
	fake.sRandMemberMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SRandMemberCallCount() int {
	fake.sRandMemberMutex.RLock()
	defer fake.sRandMemberMutex.RUnlock()
	return len(fake.sRandMemberArgsForCall)
}

func (fake *FakeClient) SRandMemberCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.sRandMemberMutex.Lock()
	defer fake.sRandMemberMutex.Unlock()
	fake.SRandMemberStub = stub
}

func (fake *FakeClient) SRandMemberArgsForCall(i int) (context.Context, string) {
	fake.sRandMemberMutex.RLock()
	defer fake.sRandMemberMutex.RUnlock()
	argsForCall := fake.sRandMemberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SRandMemberReturns(result1 *redisa.StringCmd) {
	fake.sRandMemberMutex.Lock()
	defer fake.sRandMemberMutex.Unlock()
	fake.SRandMemberStub = nil
	fake.sRandMemberReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) SRandMemberReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.sRandMemberMutex.Lock()
	defer fake.sRandMemberMutex.Unlock()
	fake.SRandMemberStub = nil
	if fake.sRandMemberReturnsOnCall == nil {
		fake.sRandMemberReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.sRandMemberReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) SRandMemberN(arg1 context.Context, arg2 string, arg3 int64) *redisa.StringSliceCmd {
	fake.sRandMemberNMutex.Lock()
	ret, specificReturn := fake.sRandMemberNReturnsOnCall[len(fake.sRandMemberNArgsForCall)]
	fake.sRandMemberNArgsForCall = append(fake.sRandMemberNArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.SRandMemberNStub
	fakeReturns := fake.sRandMemberNReturns
	fake.recordInvocation("SRandMemberN", []interface{}{arg1, arg2, arg3})
	fake.sRandMemberNMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SRandMemberNCallCount() int {
	fake.sRandMemberNMutex.RLock()
	defer fake.sRandMemberNMutex.RUnlock()
	return len(fake.sRandMemberNArgsForCall)
}

func (fake *FakeClient) SRandMemberNCalls(stub func(context.Context, string, int64) *redisa.StringSliceCmd) {
	fake.sRandMemberNMutex.Lock()
	defer fake.sRandMemberNMutex.Unlock()
	fake.SRandMemberNStub = stub
}

func (fake *FakeClient) SRandMemberNArgsForCall(i int) (context.Context, string, int64) {
	fake.sRandMemberNMutex.RLock()
	defer fake.sRandMemberNMutex.RUnlock()
	argsForCall := fake.sRandMemberNArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SRandMemberNReturns(result1 *redisa.StringSliceCmd) {
	fake.sRandMemberNMutex.Lock()
	defer fake.sRandMemberNMutex.Unlock()
	fake.SRandMemberNStub = nil
	fake.sRandMemberNReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SRandMemberNReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.sRandMemberNMutex.Lock()
	defer fake.sRandMemberNMutex.Unlock()
	fake.SRandMemberNStub = nil
	if fake.sRandMemberNReturnsOnCall == nil {
		fake.sRandMemberNReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.sRandMemberNReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SRem(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntCmd {
	fake.sRemMutex.Lock()
	ret, specificReturn := fake.sRemReturnsOnCall[len(fake.sRemArgsForCall)]
	fake.sRemArgsForCall = append(fake.sRemArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.SRemStub
	fakeReturns := fake.sRemReturns
	fake.recordInvocation("SRem", []interface{}{arg1, arg2, arg3})
	fake.sRemMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SRemCallCount() int {
	fake.sRemMutex.RLock()
	defer fake.sRemMutex.RUnlock()
	return len(fake.sRemArgsForCall)
}

func (fake *FakeClient) SRemCalls(stub func(context.Context, string, ...interface{}) *redisa.IntCmd) {
	fake.sRemMutex.Lock()
	defer fake.sRemMutex.Unlock()
	fake.SRemStub = stub
}

func (fake *FakeClient) SRemArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.sRemMutex.RLock()
	defer fake.sRemMutex.RUnlock()
	argsForCall := fake.sRemArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SRemReturns(result1 *redisa.IntCmd) {
	fake.sRemMutex.Lock()
	defer fake.sRemMutex.Unlock()
	fake.SRemStub = nil
	fake.sRemReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SRemReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.sRemMutex.Lock()
	defer fake.sRemMutex.Unlock()
	fake.SRemStub = nil
	if fake.sRemReturnsOnCall == nil {
		fake.sRemReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.sRemReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SScan(arg1 context.Context, arg2 string, arg3 uint64, arg4 string, arg5 int64) *redisa.ScanCmd {
	fake.sScanMutex.Lock()
	ret, specificReturn := fake.sScanReturnsOnCall[len(fake.sScanArgsForCall)]
	fake.sScanArgsForCall = append(fake.sScanArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 uint64
		arg4 string
		arg5 int64
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.SScanStub
	fakeReturns := fake.sScanReturns
	fake.recordInvocation("SScan", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.sScanMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SScanCallCount() int {
	fake.sScanMutex.RLock()
	defer fake.sScanMutex.RUnlock()
	return len(fake.sScanArgsForCall)
}

func (fake *FakeClient) SScanCalls(stub func(context.Context, string, uint64, string, int64) *redisa.ScanCmd) {
	fake.sScanMutex.Lock()
	defer fake.sScanMutex.Unlock()
	fake.SScanStub = stub
}

func (fake *FakeClient) SScanArgsForCall(i int) (context.Context, string, uint64, string, int64) {
	fake.sScanMutex.RLock()
	defer fake.sScanMutex.RUnlock()
	argsForCall := fake.sScanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) SScanReturns(result1 *redisa.ScanCmd) {
	fake.sScanMutex.Lock()
	defer fake.sScanMutex.Unlock()
	fake.SScanStub = nil
	fake.sScanReturns = struct {
		result1 *redisa.ScanCmd
	}{result1}
}

func (fake *FakeClient) SScanReturnsOnCall(i int, result1 *redisa.ScanCmd) {
	fake.sScanMutex.Lock()
	defer fake.sScanMutex.Unlock()
	fake.SScanStub = nil
	if fake.sScanReturnsOnCall == nil {
		fake.sScanReturnsOnCall = make(map[int]struct {
			result1 *redisa.ScanCmd
		})
	}
	fake.sScanReturnsOnCall[i] = struct {
		result1 *redisa.ScanCmd
	}{result1}
}

func (fake *FakeClient) SUnion(arg1 context.Context, arg2 ...string) *redisa.StringSliceCmd {
	fake.sUnionMutex.Lock()
	ret, specificReturn := fake.sUnionReturnsOnCall[len(fake.sUnionArgsForCall)]
	fake.sUnionArgsForCall = append(fake.sUnionArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.SUnionStub
	fakeReturns := fake.sUnionReturns
	fake.recordInvocation("SUnion", []interface{}{arg1, arg2})
	fake.sUnionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SUnionCallCount() int {
	fake.sUnionMutex.RLock()
	defer fake.sUnionMutex.RUnlock()
	return len(fake.sUnionArgsForCall)
}

func (fake *FakeClient) SUnionCalls(stub func(context.Context, ...string) *redisa.StringSliceCmd) {
	fake.sUnionMutex.Lock()
	defer fake.sUnionMutex.Unlock()
	fake.SUnionStub = stub
}

func (fake *FakeClient) SUnionArgsForCall(i int) (context.Context, []string) {
	fake.sUnionMutex.RLock()
	defer fake.sUnionMutex.RUnlock()
	argsForCall := fake.sUnionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SUnionReturns(result1 *redisa.StringSliceCmd) {
	fake.sUnionMutex.Lock()
	defer fake.sUnionMutex.Unlock()
	fake.SUnionStub = nil
	fake.sUnionReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SUnionReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.sUnionMutex.Lock()
	defer fake.sUnionMutex.Unlock()
	fake.SUnionStub = nil
	if fake.sUnionReturnsOnCall == nil {
		fake.sUnionReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.sUnionReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SUnionStore(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntCmd {
	fake.sUnionStoreMutex.Lock()
	ret, specificReturn := fake.sUnionStoreReturnsOnCall[len(fake.sUnionStoreArgsForCall)]
	fake.sUnionStoreArgsForCall = append(fake.sUnionStoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.SUnionStoreStub
	fakeReturns := fake.sUnionStoreReturns
	fake.recordInvocation("SUnionStore", []interface{}{arg1, arg2, arg3})
	fake.sUnionStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SUnionStoreCallCount() int {
	fake.sUnionStoreMutex.RLock()
	defer fake.sUnionStoreMutex.RUnlock()
	return len(fake.sUnionStoreArgsForCall)
}

func (fake *FakeClient) SUnionStoreCalls(stub func(context.Context, string, ...string) *redisa.IntCmd) {
	fake.sUnionStoreMutex.Lock()
	defer fake.sUnionStoreMutex.Unlock()
	fake.SUnionStoreStub = stub
}

func (fake *FakeClient) SUnionStoreArgsForCall(i int) (context.Context, string, []string) {
	fake.sUnionStoreMutex.RLock()
	defer fake.sUnionStoreMutex.RUnlock()
	argsForCall := fake.sUnionStoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SUnionStoreReturns(result1 *redisa.IntCmd) {
	fake.sUnionStoreMutex.Lock()
	defer fake.sUnionStoreMutex.Unlock()
	fake.SUnionStoreStub = nil
	fake.sUnionStoreReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SUnionStoreReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.sUnionStoreMutex.Lock()
	defer fake.sUnionStoreMutex.Unlock()
	fake.SUnionStoreStub = nil
	if fake.sUnionStoreReturnsOnCall == nil {
		fake.sUnionStoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.sUnionStoreReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) Save(arg1 context.Context) *redisa.StatusCmd {
	fake.saveMutex.Lock()
	ret, specificReturn := fake.saveReturnsOnCall[len(fake.saveArgsForCall)]
	fake.saveArgsForCall = append(fake.saveArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.SaveStub
	fakeReturns := fake.saveReturns
	fake.recordInvocation("Save", []interface{}{arg1})
	fake.saveMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SaveCallCount() int {
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	return len(fake.saveArgsForCall)
}

func (fake *FakeClient) SaveCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.saveMutex.Lock()
	defer fake.saveMutex.Unlock()
	fake.SaveStub = stub
}

func (fake *FakeClient) SaveArgsForCall(i int) context.Context {
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	argsForCall := fake.saveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SaveReturns(result1 *redisa.StatusCmd) {
	fake.saveMutex.Lock()
	defer fake.saveMutex.Unlock()
	fake.SaveStub = nil
	fake.saveReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) SaveReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.saveMutex.Lock()
	defer fake.saveMutex.Unlock()
	fake.SaveStub = nil
	if fake.saveReturnsOnCall == nil {
		fake.saveReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.saveReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) Scan(arg1 context.Context, arg2 uint64, arg3 string, arg4 int64) *redisa.ScanCmd {
	fake.scanMutex.Lock()
	ret, specificReturn := fake.scanReturnsOnCall[len(fake.scanArgsForCall)]
	fake.scanArgsForCall = append(fake.scanArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
		arg3 string
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.ScanStub
	fakeReturns := fake.scanReturns
	fake.recordInvocation("Scan", []interface{}{arg1, arg2, arg3, arg4})
	fake.scanMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ScanCallCount() int {
	fake.scanMutex.RLock()
	defer fake.scanMutex.RUnlock()
	return len(fake.scanArgsForCall)
}

func (fake *FakeClient) ScanCalls(stub func(context.Context, uint64, string, int64) *redisa.ScanCmd) {
	fake.scanMutex.Lock()
	defer fake.scanMutex.Unlock()
	fake.ScanStub = stub
}

func (fake *FakeClient) ScanArgsForCall(i int) (context.Context, uint64, string, int64) {
	fake.scanMutex.RLock()
	defer fake.scanMutex.RUnlock()
	argsForCall := fake.scanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ScanReturns(result1 *redisa.ScanCmd) {
	fake.scanMutex.Lock()
	defer fake.scanMutex.Unlock()
	fake.ScanStub = nil
	fake.scanReturns = struct {
		result1 *redisa.ScanCmd
	}{result1}
}

func (fake *FakeClient) ScanReturnsOnCall(i int, result1 *redisa.ScanCmd) {
	fake.scanMutex.Lock()
	defer fake.scanMutex.Unlock()
	fake.ScanStub = nil
	if fake.scanReturnsOnCall == nil {
		fake.scanReturnsOnCall = make(map[int]struct {
			result1 *redisa.ScanCmd
		})
	}
	fake.scanReturnsOnCall[i] = struct {
		result1 *redisa.ScanCmd
	}{result1}
}

func (fake *FakeClient) ScanType(arg1 context.Context, arg2 uint64, arg3 string, arg4 int64, arg5 string) *redisa.ScanCmd {
	fake.scanTypeMutex.Lock()
	ret, specificReturn := fake.scanTypeReturnsOnCall[len(fake.scanTypeArgsForCall)]
	fake.scanTypeArgsForCall = append(fake.scanTypeArgsForCall, struct {
		arg1 context.Context
		arg2 uint64
		arg3 string
		arg4 int64
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ScanTypeStub
	fakeReturns := fake.scanTypeReturns
	fake.recordInvocation("ScanType", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.scanTypeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ScanTypeCallCount() int {
	fake.scanTypeMutex.RLock()
	defer fake.scanTypeMutex.RUnlock()
	return len(fake.scanTypeArgsForCall)
}

func (fake *FakeClient) ScanTypeCalls(stub func(context.Context, uint64, string, int64, string) *redisa.ScanCmd) {
	fake.scanTypeMutex.Lock()
	defer fake.scanTypeMutex.Unlock()
	fake.ScanTypeStub = stub
}

func (fake *FakeClient) ScanTypeArgsForCall(i int) (context.Context, uint64, string, int64, string) {
	fake.scanTypeMutex.RLock()
	defer fake.scanTypeMutex.RUnlock()
	argsForCall := fake.scanTypeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) ScanTypeReturns(result1 *redisa.ScanCmd) {
	fake.scanTypeMutex.Lock()
	defer fake.scanTypeMutex.Unlock()
	fake.ScanTypeStub = nil
	fake.scanTypeReturns = struct {
		result1 *redisa.ScanCmd
	}{result1}
}

func (fake *FakeClient) ScanTypeReturnsOnCall(i int, result1 *redisa.ScanCmd) {
	fake.scanTypeMutex.Lock()
	defer fake.scanTypeMutex.Unlock()
	fake.ScanTypeStub = nil
	if fake.scanTypeReturnsOnCall == nil {
		fake.scanTypeReturnsOnCall = make(map[int]struct {
			result1 *redisa.ScanCmd
		})
	}
	fake.scanTypeReturnsOnCall[i] = struct {
		result1 *redisa.ScanCmd
	}{result1}
}

func (fake *FakeClient) ScriptExists(arg1 context.Context, arg2 ...string) *redisa.BoolSliceCmd {
	fake.scriptExistsMutex.Lock()
	ret, specificReturn := fake.scriptExistsReturnsOnCall[len(fake.scriptExistsArgsForCall)]
	fake.scriptExistsArgsForCall = append(fake.scriptExistsArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.ScriptExistsStub
	fakeReturns := fake.scriptExistsReturns
	fake.recordInvocation("ScriptExists", []interface{}{arg1, arg2})
	fake.scriptExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ScriptExistsCallCount() int {
	fake.scriptExistsMutex.RLock()
	defer fake.scriptExistsMutex.RUnlock()
	return len(fake.scriptExistsArgsForCall)
}

func (fake *FakeClient) ScriptExistsCalls(stub func(context.Context, ...string) *redisa.BoolSliceCmd) {
	fake.scriptExistsMutex.Lock()
	defer fake.scriptExistsMutex.Unlock()
	fake.ScriptExistsStub = stub
}

func (fake *FakeClient) ScriptExistsArgsForCall(i int) (context.Context, []string) {
	fake.scriptExistsMutex.RLock()
	defer fake.scriptExistsMutex.RUnlock()
	argsForCall := fake.scriptExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ScriptExistsReturns(result1 *redisa.BoolSliceCmd) {
	fake.scriptExistsMutex.Lock()
	defer fake.scriptExistsMutex.Unlock()
	fake.ScriptExistsStub = nil
	fake.scriptExistsReturns = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) ScriptExistsReturnsOnCall(i int, result1 *redisa.BoolSliceCmd) {
	fake.scriptExistsMutex.Lock()
	defer fake.scriptExistsMutex.Unlock()
	fake.ScriptExistsStub = nil
	if fake.scriptExistsReturnsOnCall == nil {
		fake.scriptExistsReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolSliceCmd
		})
	}
	fake.scriptExistsReturnsOnCall[i] = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) ScriptFlush(arg1 context.Context) *redisa.StatusCmd {
	fake.scriptFlushMutex.Lock()
	ret, specificReturn := fake.scriptFlushReturnsOnCall[len(fake.scriptFlushArgsForCall)]
	fake.scriptFlushArgsForCall = append(fake.scriptFlushArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ScriptFlushStub
	fakeReturns := fake.scriptFlushReturns
	fake.recordInvocation("ScriptFlush", []interface{}{arg1})
	fake.scriptFlushMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ScriptFlushCallCount() int {
	fake.scriptFlushMutex.RLock()
	defer fake.scriptFlushMutex.RUnlock()
	return len(fake.scriptFlushArgsForCall)
}

func (fake *FakeClient) ScriptFlushCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.scriptFlushMutex.Lock()
	defer fake.scriptFlushMutex.Unlock()
	fake.ScriptFlushStub = stub
}

func (fake *FakeClient) ScriptFlushArgsForCall(i int) context.Context {
	fake.scriptFlushMutex.RLock()
	defer fake.scriptFlushMutex.RUnlock()
	argsForCall := fake.scriptFlushArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ScriptFlushReturns(result1 *redisa.StatusCmd) {
	fake.scriptFlushMutex.Lock()
	defer fake.scriptFlushMutex.Unlock()
	fake.ScriptFlushStub = nil
	fake.scriptFlushReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ScriptFlushReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.scriptFlushMutex.Lock()
	defer fake.scriptFlushMutex.Unlock()
	fake.ScriptFlushStub = nil
	if fake.scriptFlushReturnsOnCall == nil {
		fake.scriptFlushReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.scriptFlushReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ScriptKill(arg1 context.Context) *redisa.StatusCmd {
	fake.scriptKillMutex.Lock()
	ret, specificReturn := fake.scriptKillReturnsOnCall[len(fake.scriptKillArgsForCall)]
	fake.scriptKillArgsForCall = append(fake.scriptKillArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ScriptKillStub
	fakeReturns := fake.scriptKillReturns
	fake.recordInvocation("ScriptKill", []interface{}{arg1})
	fake.scriptKillMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ScriptKillCallCount() int {
	fake.scriptKillMutex.RLock()
	defer fake.scriptKillMutex.RUnlock()
	return len(fake.scriptKillArgsForCall)
}

func (fake *FakeClient) ScriptKillCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.scriptKillMutex.Lock()
	defer fake.scriptKillMutex.Unlock()
	fake.ScriptKillStub = stub
}

func (fake *FakeClient) ScriptKillArgsForCall(i int) context.Context {
	fake.scriptKillMutex.RLock()
	defer fake.scriptKillMutex.RUnlock()
	argsForCall := fake.scriptKillArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ScriptKillReturns(result1 *redisa.StatusCmd) {
	fake.scriptKillMutex.Lock()
	defer fake.scriptKillMutex.Unlock()
	fake.ScriptKillStub = nil
	fake.scriptKillReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ScriptKillReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.scriptKillMutex.Lock()
	defer fake.scriptKillMutex.Unlock()
	fake.ScriptKillStub = nil
	if fake.scriptKillReturnsOnCall == nil {
		fake.scriptKillReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.scriptKillReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ScriptLoad(arg1 context.Context, arg2 string) *redisa.StringCmd {
	fake.scriptLoadMutex.Lock()
	ret, specificReturn := fake.scriptLoadReturnsOnCall[len(fake.scriptLoadArgsForCall)]
	fake.scriptLoadArgsForCall = append(fake.scriptLoadArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ScriptLoadStub
	fakeReturns := fake.scriptLoadReturns
	fake.recordInvocation("ScriptLoad", []interface{}{arg1, arg2})
	fake.scriptLoadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ScriptLoadCallCount() int {
	fake.scriptLoadMutex.RLock()
	defer fake.scriptLoadMutex.RUnlock()
	return len(fake.scriptLoadArgsForCall)
}

func (fake *FakeClient) ScriptLoadCalls(stub func(context.Context, string) *redisa.StringCmd) {
	fake.scriptLoadMutex.Lock()
	defer fake.scriptLoadMutex.Unlock()
	fake.ScriptLoadStub = stub
}

func (fake *FakeClient) ScriptLoadArgsForCall(i int) (context.Context, string) {
	fake.scriptLoadMutex.RLock()
	defer fake.scriptLoadMutex.RUnlock()
	argsForCall := fake.scriptLoadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ScriptLoadReturns(result1 *redisa.StringCmd) {
	fake.scriptLoadMutex.Lock()
	defer fake.scriptLoadMutex.Unlock()
	fake.ScriptLoadStub = nil
	fake.scriptLoadReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) ScriptLoadReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.scriptLoadMutex.Lock()
	defer fake.scriptLoadMutex.Unlock()
	fake.ScriptLoadStub = nil
	if fake.scriptLoadReturnsOnCall == nil {
		fake.scriptLoadReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.scriptLoadReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) Set(arg1 context.Context, arg2 string, arg3 interface{}, arg4 time.Duration) *redisa.StatusCmd {
	fake.setMutex.Lock()
	ret, specificReturn := fake.setReturnsOnCall[len(fake.setArgsForCall)]
	fake.setArgsForCall = append(fake.setArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 time.Duration
	}{arg1, arg2, arg3, arg4})
	stub := fake.SetStub
	fakeReturns := fake.setReturns
	fake.recordInvocation("Set", []interface{}{arg1, arg2, arg3, arg4})
	fake.setMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SetCallCount() int {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return len(fake.setArgsForCall)
}

func (fake *FakeClient) SetCalls(stub func(context.Context, string, interface{}, time.Duration) *redisa.StatusCmd) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = stub
}

func (fake *FakeClient) SetArgsForCall(i int) (context.Context, string, interface{}, time.Duration) {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	argsForCall := fake.setArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) SetReturns(result1 *redisa.StatusCmd) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = nil
	fake.setReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) SetReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = nil
	if fake.setReturnsOnCall == nil {
		fake.setReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.setReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) SetArgs(arg1 context.Context, arg2 string, arg3 interface{}, arg4 redisa.SetArgs) *redisa.StatusCmd {
	fake.setArgsMutex.Lock()
	ret, specificReturn := fake.setArgsReturnsOnCall[len(fake.setArgsArgsForCall)]
	fake.setArgsArgsForCall = append(fake.setArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 redisa.SetArgs
	}{arg1, arg2, arg3, arg4})
	stub := fake.SetArgsStub
	fakeReturns := fake.setArgsReturns
	fake.recordInvocation("SetArgs", []interface{}{arg1, arg2, arg3, arg4})
	fake.setArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SetArgsCallCount() int {
	fake.setArgsMutex.RLock()
	defer fake.setArgsMutex.RUnlock()
	return len(fake.setArgsArgsForCall)
}

func (fake *FakeClient) SetArgsCalls(stub func(context.Context, string, interface{}, redisa.SetArgs) *redisa.StatusCmd) {
	fake.setArgsMutex.Lock()
	defer fake.setArgsMutex.Unlock()
	fake.SetArgsStub = stub
}

func (fake *FakeClient) SetArgsArgsForCall(i int) (context.Context, string, interface{}, redisa.SetArgs) {
	fake.setArgsMutex.RLock()
	defer fake.setArgsMutex.RUnlock()
	argsForCall := fake.setArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) SetArgsReturns(result1 *redisa.StatusCmd) {
	fake.setArgsMutex.Lock()
	defer fake.setArgsMutex.Unlock()
	fake.SetArgsStub = nil
	fake.setArgsReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) SetArgsReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.setArgsMutex.Lock()
	defer fake.setArgsMutex.Unlock()
	fake.SetArgsStub = nil
	if fake.setArgsReturnsOnCall == nil {
		fake.setArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.setArgsReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) SetBit(arg1 context.Context, arg2 string, arg3 int64, arg4 int) *redisa.IntCmd {
	fake.setBitMutex.Lock()
	ret, specificReturn := fake.setBitReturnsOnCall[len(fake.setBitArgsForCall)]
	fake.setBitArgsForCall = append(fake.setBitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.SetBitStub
	fakeReturns := fake.setBitReturns
	fake.recordInvocation("SetBit", []interface{}{arg1, arg2, arg3, arg4})
	fake.setBitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SetBitCallCount() int {
	fake.setBitMutex.RLock()
	defer fake.setBitMutex.RUnlock()
	return len(fake.setBitArgsForCall)
}

func (fake *FakeClient) SetBitCalls(stub func(context.Context, string, int64, int) *redisa.IntCmd) {
	fake.setBitMutex.Lock()
	defer fake.setBitMutex.Unlock()
	fake.SetBitStub = stub
}

func (fake *FakeClient) SetBitArgsForCall(i int) (context.Context, string, int64, int) {
	fake.setBitMutex.RLock()
	defer fake.setBitMutex.RUnlock()
	argsForCall := fake.setBitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) SetBitReturns(result1 *redisa.IntCmd) {
	fake.setBitMutex.Lock()
	defer fake.setBitMutex.Unlock()
	fake.SetBitStub = nil
	fake.setBitReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SetBitReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.setBitMutex.Lock()
	defer fake.setBitMutex.Unlock()
	fake.SetBitStub = nil
	if fake.setBitReturnsOnCall == nil {
		fake.setBitReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.setBitReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SetEx(arg1 context.Context, arg2 string, arg3 interface{}, arg4 time.Duration) *redisa.StatusCmd {
	fake.setExMutex.Lock()
	ret, specificReturn := fake.setExReturnsOnCall[len(fake.setExArgsForCall)]
	fake.setExArgsForCall = append(fake.setExArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 time.Duration
	}{arg1, arg2, arg3, arg4})
	stub := fake.SetExStub
	fakeReturns := fake.setExReturns
	fake.recordInvocation("SetEx", []interface{}{arg1, arg2, arg3, arg4})
	fake.setExMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SetExCallCount() int {
	fake.setExMutex.RLock()
	defer fake.setExMutex.RUnlock()
	return len(fake.setExArgsForCall)
}

func (fake *FakeClient) SetExCalls(stub func(context.Context, string, interface{}, time.Duration) *redisa.StatusCmd) {
	fake.setExMutex.Lock()
	defer fake.setExMutex.Unlock()
	fake.SetExStub = stub
}

func (fake *FakeClient) SetExArgsForCall(i int) (context.Context, string, interface{}, time.Duration) {
	fake.setExMutex.RLock()
	defer fake.setExMutex.RUnlock()
	argsForCall := fake.setExArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) SetExReturns(result1 *redisa.StatusCmd) {
	fake.setExMutex.Lock()
	defer fake.setExMutex.Unlock()
	fake.SetExStub = nil
	fake.setExReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) SetExReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.setExMutex.Lock()
	defer fake.setExMutex.Unlock()
	fake.SetExStub = nil
	if fake.setExReturnsOnCall == nil {
		fake.setExReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.setExReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) SetNX(arg1 context.Context, arg2 string, arg3 interface{}, arg4 time.Duration) *redisa.BoolCmd {
	fake.setNXMutex.Lock()
	ret, specificReturn := fake.setNXReturnsOnCall[len(fake.setNXArgsForCall)]
	fake.setNXArgsForCall = append(fake.setNXArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 time.Duration
	}{arg1, arg2, arg3, arg4})
	stub := fake.SetNXStub
	fakeReturns := fake.setNXReturns
	fake.recordInvocation("SetNX", []interface{}{arg1, arg2, arg3, arg4})
	fake.setNXMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SetNXCallCount() int {
	fake.setNXMutex.RLock()
	defer fake.setNXMutex.RUnlock()
	return len(fake.setNXArgsForCall)
}

func (fake *FakeClient) SetNXCalls(stub func(context.Context, string, interface{}, time.Duration) *redisa.BoolCmd) {
	fake.setNXMutex.Lock()
	defer fake.setNXMutex.Unlock()
	fake.SetNXStub = stub
}

func (fake *FakeClient) SetNXArgsForCall(i int) (context.Context, string, interface{}, time.Duration) {
	fake.setNXMutex.RLock()
	defer fake.setNXMutex.RUnlock()
	argsForCall := fake.setNXArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) SetNXReturns(result1 *redisa.BoolCmd) {
	fake.setNXMutex.Lock()
	defer fake.setNXMutex.Unlock()
	fake.SetNXStub = nil
	fake.setNXReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) SetNXReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.setNXMutex.Lock()
	defer fake.setNXMutex.Unlock()
	fake.SetNXStub = nil
	if fake.setNXReturnsOnCall == nil {
		fake.setNXReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.setNXReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) SetRange(arg1 context.Context, arg2 string, arg3 int64, arg4 string) *redisa.IntCmd {
	fake.setRangeMutex.Lock()
	ret, specificReturn := fake.setRangeReturnsOnCall[len(fake.setRangeArgsForCall)]
	fake.setRangeArgsForCall = append(fake.setRangeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.SetRangeStub
	fakeReturns := fake.setRangeReturns
	fake.recordInvocation("SetRange", []interface{}{arg1, arg2, arg3, arg4})
	fake.setRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SetRangeCallCount() int {
	fake.setRangeMutex.RLock()
	defer fake.setRangeMutex.RUnlock()
	return len(fake.setRangeArgsForCall)
}

func (fake *FakeClient) SetRangeCalls(stub func(context.Context, string, int64, string) *redisa.IntCmd) {
	fake.setRangeMutex.Lock()
	defer fake.setRangeMutex.Unlock()
	fake.SetRangeStub = stub
}

func (fake *FakeClient) SetRangeArgsForCall(i int) (context.Context, string, int64, string) {
	fake.setRangeMutex.RLock()
	defer fake.setRangeMutex.RUnlock()
	argsForCall := fake.setRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) SetRangeReturns(result1 *redisa.IntCmd) {
	fake.setRangeMutex.Lock()
	defer fake.setRangeMutex.Unlock()
	fake.SetRangeStub = nil
	fake.setRangeReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SetRangeReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.setRangeMutex.Lock()
	defer fake.setRangeMutex.Unlock()
	fake.SetRangeStub = nil
	if fake.setRangeReturnsOnCall == nil {
		fake.setRangeReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.setRangeReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SetXX(arg1 context.Context, arg2 string, arg3 interface{}, arg4 time.Duration) *redisa.BoolCmd {
	fake.setXXMutex.Lock()
	ret, specificReturn := fake.setXXReturnsOnCall[len(fake.setXXArgsForCall)]
	fake.setXXArgsForCall = append(fake.setXXArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 time.Duration
	}{arg1, arg2, arg3, arg4})
	stub := fake.SetXXStub
	fakeReturns := fake.setXXReturns
	fake.recordInvocation("SetXX", []interface{}{arg1, arg2, arg3, arg4})
	fake.setXXMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SetXXCallCount() int {
	fake.setXXMutex.RLock()
	defer fake.setXXMutex.RUnlock()
	return len(fake.setXXArgsForCall)
}

func (fake *FakeClient) SetXXCalls(stub func(context.Context, string, interface{}, time.Duration) *redisa.BoolCmd) {
	fake.setXXMutex.Lock()
	defer fake.setXXMutex.Unlock()
	fake.SetXXStub = stub
}

func (fake *FakeClient) SetXXArgsForCall(i int) (context.Context, string, interface{}, time.Duration) {
	fake.setXXMutex.RLock()
	defer fake.setXXMutex.RUnlock()
	argsForCall := fake.setXXArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) SetXXReturns(result1 *redisa.BoolCmd) {
	fake.setXXMutex.Lock()
	defer fake.setXXMutex.Unlock()
	fake.SetXXStub = nil
	fake.setXXReturns = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) SetXXReturnsOnCall(i int, result1 *redisa.BoolCmd) {
	fake.setXXMutex.Lock()
	defer fake.setXXMutex.Unlock()
	fake.SetXXStub = nil
	if fake.setXXReturnsOnCall == nil {
		fake.setXXReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolCmd
		})
	}
	fake.setXXReturnsOnCall[i] = struct {
		result1 *redisa.BoolCmd
	}{result1}
}

func (fake *FakeClient) Shutdown(arg1 context.Context) *redisa.StatusCmd {
	fake.shutdownMutex.Lock()
	ret, specificReturn := fake.shutdownReturnsOnCall[len(fake.shutdownArgsForCall)]
	fake.shutdownArgsForCall = append(fake.shutdownArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ShutdownStub
	fakeReturns := fake.shutdownReturns
	fake.recordInvocation("Shutdown", []interface{}{arg1})
	fake.shutdownMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ShutdownCallCount() int {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	return len(fake.shutdownArgsForCall)
}

func (fake *FakeClient) ShutdownCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = stub
}

func (fake *FakeClient) ShutdownArgsForCall(i int) context.Context {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	argsForCall := fake.shutdownArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ShutdownReturns(result1 *redisa.StatusCmd) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	fake.shutdownReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ShutdownReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	if fake.shutdownReturnsOnCall == nil {
		fake.shutdownReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.shutdownReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ShutdownNoSave(arg1 context.Context) *redisa.StatusCmd {
	fake.shutdownNoSaveMutex.Lock()
	ret, specificReturn := fake.shutdownNoSaveReturnsOnCall[len(fake.shutdownNoSaveArgsForCall)]
	fake.shutdownNoSaveArgsForCall = append(fake.shutdownNoSaveArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ShutdownNoSaveStub
	fakeReturns := fake.shutdownNoSaveReturns
	fake.recordInvocation("ShutdownNoSave", []interface{}{arg1})
	fake.shutdownNoSaveMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ShutdownNoSaveCallCount() int {
	fake.shutdownNoSaveMutex.RLock()
	defer fake.shutdownNoSaveMutex.RUnlock()
	return len(fake.shutdownNoSaveArgsForCall)
}

func (fake *FakeClient) ShutdownNoSaveCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.shutdownNoSaveMutex.Lock()
	defer fake.shutdownNoSaveMutex.Unlock()
	fake.ShutdownNoSaveStub = stub
}

func (fake *FakeClient) ShutdownNoSaveArgsForCall(i int) context.Context {
	fake.shutdownNoSaveMutex.RLock()
	defer fake.shutdownNoSaveMutex.RUnlock()
	argsForCall := fake.shutdownNoSaveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ShutdownNoSaveReturns(result1 *redisa.StatusCmd) {
	fake.shutdownNoSaveMutex.Lock()
	defer fake.shutdownNoSaveMutex.Unlock()
	fake.ShutdownNoSaveStub = nil
	fake.shutdownNoSaveReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ShutdownNoSaveReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.shutdownNoSaveMutex.Lock()
	defer fake.shutdownNoSaveMutex.Unlock()
	fake.ShutdownNoSaveStub = nil
	if fake.shutdownNoSaveReturnsOnCall == nil {
		fake.shutdownNoSaveReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.shutdownNoSaveReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ShutdownSave(arg1 context.Context) *redisa.StatusCmd {
	fake.shutdownSaveMutex.Lock()
	ret, specificReturn := fake.shutdownSaveReturnsOnCall[len(fake.shutdownSaveArgsForCall)]
	fake.shutdownSaveArgsForCall = append(fake.shutdownSaveArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ShutdownSaveStub
	fakeReturns := fake.shutdownSaveReturns
	fake.recordInvocation("ShutdownSave", []interface{}{arg1})
	fake.shutdownSaveMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ShutdownSaveCallCount() int {
	fake.shutdownSaveMutex.RLock()
	defer fake.shutdownSaveMutex.RUnlock()
	return len(fake.shutdownSaveArgsForCall)
}

func (fake *FakeClient) ShutdownSaveCalls(stub func(context.Context) *redisa.StatusCmd) {
	fake.shutdownSaveMutex.Lock()
	defer fake.shutdownSaveMutex.Unlock()
	fake.ShutdownSaveStub = stub
}

func (fake *FakeClient) ShutdownSaveArgsForCall(i int) context.Context {
	fake.shutdownSaveMutex.RLock()
	defer fake.shutdownSaveMutex.RUnlock()
	argsForCall := fake.shutdownSaveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ShutdownSaveReturns(result1 *redisa.StatusCmd) {
	fake.shutdownSaveMutex.Lock()
	defer fake.shutdownSaveMutex.Unlock()
	fake.ShutdownSaveStub = nil
	fake.shutdownSaveReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) ShutdownSaveReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.shutdownSaveMutex.Lock()
	defer fake.shutdownSaveMutex.Unlock()
	fake.ShutdownSaveStub = nil
	if fake.shutdownSaveReturnsOnCall == nil {
		fake.shutdownSaveReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.shutdownSaveReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) SlaveOf(arg1 context.Context, arg2 string, arg3 string) *redisa.StatusCmd {
	fake.slaveOfMutex.Lock()
	ret, specificReturn := fake.slaveOfReturnsOnCall[len(fake.slaveOfArgsForCall)]
	fake.slaveOfArgsForCall = append(fake.slaveOfArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.SlaveOfStub
	fakeReturns := fake.slaveOfReturns
	fake.recordInvocation("SlaveOf", []interface{}{arg1, arg2, arg3})
	fake.slaveOfMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SlaveOfCallCount() int {
	fake.slaveOfMutex.RLock()
	defer fake.slaveOfMutex.RUnlock()
	return len(fake.slaveOfArgsForCall)
}

func (fake *FakeClient) SlaveOfCalls(stub func(context.Context, string, string) *redisa.StatusCmd) {
	fake.slaveOfMutex.Lock()
	defer fake.slaveOfMutex.Unlock()
	fake.SlaveOfStub = stub
}

func (fake *FakeClient) SlaveOfArgsForCall(i int) (context.Context, string, string) {
	fake.slaveOfMutex.RLock()
	defer fake.slaveOfMutex.RUnlock()
	argsForCall := fake.slaveOfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SlaveOfReturns(result1 *redisa.StatusCmd) {
	fake.slaveOfMutex.Lock()
	defer fake.slaveOfMutex.Unlock()
	fake.SlaveOfStub = nil
	fake.slaveOfReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) SlaveOfReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.slaveOfMutex.Lock()
	defer fake.slaveOfMutex.Unlock()
	fake.SlaveOfStub = nil
	if fake.slaveOfReturnsOnCall == nil {
		fake.slaveOfReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.slaveOfReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) SlowLogGet(arg1 context.Context, arg2 int64) *redisa.SlowLogCmd {
	fake.slowLogGetMutex.Lock()
	ret, specificReturn := fake.slowLogGetReturnsOnCall[len(fake.slowLogGetArgsForCall)]
	fake.slowLogGetArgsForCall = append(fake.slowLogGetArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.SlowLogGetStub
	fakeReturns := fake.slowLogGetReturns
	fake.recordInvocation("SlowLogGet", []interface{}{arg1, arg2})
	fake.slowLogGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SlowLogGetCallCount() int {
	fake.slowLogGetMutex.RLock()
	defer fake.slowLogGetMutex.RUnlock()
	return len(fake.slowLogGetArgsForCall)
}

func (fake *FakeClient) SlowLogGetCalls(stub func(context.Context, int64) *redisa.SlowLogCmd) {
	fake.slowLogGetMutex.Lock()
	defer fake.slowLogGetMutex.Unlock()
	fake.SlowLogGetStub = stub
}

func (fake *FakeClient) SlowLogGetArgsForCall(i int) (context.Context, int64) {
	fake.slowLogGetMutex.RLock()
	defer fake.slowLogGetMutex.RUnlock()
	argsForCall := fake.slowLogGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SlowLogGetReturns(result1 *redisa.SlowLogCmd) {
	fake.slowLogGetMutex.Lock()
	defer fake.slowLogGetMutex.Unlock()
	fake.SlowLogGetStub = nil
	fake.slowLogGetReturns = struct {
		result1 *redisa.SlowLogCmd
	}{result1}
}

func (fake *FakeClient) SlowLogGetReturnsOnCall(i int, result1 *redisa.SlowLogCmd) {
	fake.slowLogGetMutex.Lock()
	defer fake.slowLogGetMutex.Unlock()
	fake.SlowLogGetStub = nil
	if fake.slowLogGetReturnsOnCall == nil {
		fake.slowLogGetReturnsOnCall = make(map[int]struct {
			result1 *redisa.SlowLogCmd
		})
	}
	fake.slowLogGetReturnsOnCall[i] = struct {
		result1 *redisa.SlowLogCmd
	}{result1}
}

func (fake *FakeClient) Sort(arg1 context.Context, arg2 string, arg3 *redisa.Sort) *redisa.StringSliceCmd {
	fake.sortMutex.Lock()
	ret, specificReturn := fake.sortReturnsOnCall[len(fake.sortArgsForCall)]
	fake.sortArgsForCall = append(fake.sortArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.Sort
	}{arg1, arg2, arg3})
	stub := fake.SortStub
	fakeReturns := fake.sortReturns
	fake.recordInvocation("Sort", []interface{}{arg1, arg2, arg3})
	fake.sortMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SortCallCount() int {
	fake.sortMutex.RLock()
	defer fake.sortMutex.RUnlock()
	return len(fake.sortArgsForCall)
}

func (fake *FakeClient) SortCalls(stub func(context.Context, string, *redisa.Sort) *redisa.StringSliceCmd) {
	fake.sortMutex.Lock()
	defer fake.sortMutex.Unlock()
	fake.SortStub = stub
}

func (fake *FakeClient) SortArgsForCall(i int) (context.Context, string, *redisa.Sort) {
	fake.sortMutex.RLock()
	defer fake.sortMutex.RUnlock()
	argsForCall := fake.sortArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SortReturns(result1 *redisa.StringSliceCmd) {
	fake.sortMutex.Lock()
	defer fake.sortMutex.Unlock()
	fake.SortStub = nil
	fake.sortReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SortReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.sortMutex.Lock()
	defer fake.sortMutex.Unlock()
	fake.SortStub = nil
	if fake.sortReturnsOnCall == nil {
		fake.sortReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.sortReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SortInterfaces(arg1 context.Context, arg2 string, arg3 *redisa.Sort) *redisa.SliceCmd {
	fake.sortInterfacesMutex.Lock()
	ret, specificReturn := fake.sortInterfacesReturnsOnCall[len(fake.sortInterfacesArgsForCall)]
	fake.sortInterfacesArgsForCall = append(fake.sortInterfacesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.Sort
	}{arg1, arg2, arg3})
	stub := fake.SortInterfacesStub
	fakeReturns := fake.sortInterfacesReturns
	fake.recordInvocation("SortInterfaces", []interface{}{arg1, arg2, arg3})
	fake.sortInterfacesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SortInterfacesCallCount() int {
	fake.sortInterfacesMutex.RLock()
	defer fake.sortInterfacesMutex.RUnlock()
	return len(fake.sortInterfacesArgsForCall)
}

func (fake *FakeClient) SortInterfacesCalls(stub func(context.Context, string, *redisa.Sort) *redisa.SliceCmd) {
	fake.sortInterfacesMutex.Lock()
	defer fake.sortInterfacesMutex.Unlock()
	fake.SortInterfacesStub = stub
}

func (fake *FakeClient) SortInterfacesArgsForCall(i int) (context.Context, string, *redisa.Sort) {
	fake.sortInterfacesMutex.RLock()
	defer fake.sortInterfacesMutex.RUnlock()
	argsForCall := fake.sortInterfacesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SortInterfacesReturns(result1 *redisa.SliceCmd) {
	fake.sortInterfacesMutex.Lock()
	defer fake.sortInterfacesMutex.Unlock()
	fake.SortInterfacesStub = nil
	fake.sortInterfacesReturns = struct {
		result1 *redisa.SliceCmd
	}{result1}
}

func (fake *FakeClient) SortInterfacesReturnsOnCall(i int, result1 *redisa.SliceCmd) {
	fake.sortInterfacesMutex.Lock()
	defer fake.sortInterfacesMutex.Unlock()
	fake.SortInterfacesStub = nil
	if fake.sortInterfacesReturnsOnCall == nil {
		fake.sortInterfacesReturnsOnCall = make(map[int]struct {
			result1 *redisa.SliceCmd
		})
	}
	fake.sortInterfacesReturnsOnCall[i] = struct {
		result1 *redisa.SliceCmd
	}{result1}
}

func (fake *FakeClient) SortRO(arg1 context.Context, arg2 string, arg3 *redisa.Sort) *redisa.StringSliceCmd {
	fake.sortROMutex.Lock()
	ret, specificReturn := fake.sortROReturnsOnCall[len(fake.sortROArgsForCall)]
	fake.sortROArgsForCall = append(fake.sortROArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.Sort
	}{arg1, arg2, arg3})
	stub := fake.SortROStub
	fakeReturns := fake.sortROReturns
	fake.recordInvocation("SortRO", []interface{}{arg1, arg2, arg3})
	fake.sortROMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SortROCallCount() int {
	fake.sortROMutex.RLock()
	defer fake.sortROMutex.RUnlock()
	return len(fake.sortROArgsForCall)
}

func (fake *FakeClient) SortROCalls(stub func(context.Context, string, *redisa.Sort) *redisa.StringSliceCmd) {
	fake.sortROMutex.Lock()
	defer fake.sortROMutex.Unlock()
	fake.SortROStub = stub
}

func (fake *FakeClient) SortROArgsForCall(i int) (context.Context, string, *redisa.Sort) {
	fake.sortROMutex.RLock()
	defer fake.sortROMutex.RUnlock()
	argsForCall := fake.sortROArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SortROReturns(result1 *redisa.StringSliceCmd) {
	fake.sortROMutex.Lock()
	defer fake.sortROMutex.Unlock()
	fake.SortROStub = nil
	fake.sortROReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SortROReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.sortROMutex.Lock()
	defer fake.sortROMutex.Unlock()
	fake.SortROStub = nil
	if fake.sortROReturnsOnCall == nil {
		fake.sortROReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.sortROReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) SortStore(arg1 context.Context, arg2 string, arg3 string, arg4 *redisa.Sort) *redisa.IntCmd {
	fake.sortStoreMutex.Lock()
	ret, specificReturn := fake.sortStoreReturnsOnCall[len(fake.sortStoreArgsForCall)]
	fake.sortStoreArgsForCall = append(fake.sortStoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *redisa.Sort
	}{arg1, arg2, arg3, arg4})
	stub := fake.SortStoreStub
	fakeReturns := fake.sortStoreReturns
	fake.recordInvocation("SortStore", []interface{}{arg1, arg2, arg3, arg4})
	fake.sortStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SortStoreCallCount() int {
	fake.sortStoreMutex.RLock()
	defer fake.sortStoreMutex.RUnlock()
	return len(fake.sortStoreArgsForCall)
}

func (fake *FakeClient) SortStoreCalls(stub func(context.Context, string, string, *redisa.Sort) *redisa.IntCmd) {
	fake.sortStoreMutex.Lock()
	defer fake.sortStoreMutex.Unlock()
	fake.SortStoreStub = stub
}

func (fake *FakeClient) SortStoreArgsForCall(i int) (context.Context, string, string, *redisa.Sort) {
	fake.sortStoreMutex.RLock()
	defer fake.sortStoreMutex.RUnlock()
	argsForCall := fake.sortStoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) SortStoreReturns(result1 *redisa.IntCmd) {
	fake.sortStoreMutex.Lock()
	defer fake.sortStoreMutex.Unlock()
	fake.SortStoreStub = nil
	fake.sortStoreReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) SortStoreReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.sortStoreMutex.Lock()
	defer fake.sortStoreMutex.Unlock()
	fake.SortStoreStub = nil
	if fake.sortStoreReturnsOnCall == nil {
		fake.sortStoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.sortStoreReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) StrLen(arg1 context.Context, arg2 string) *redisa.IntCmd {
	fake.strLenMutex.Lock()
	ret, specificReturn := fake.strLenReturnsOnCall[len(fake.strLenArgsForCall)]
	fake.strLenArgsForCall = append(fake.strLenArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.StrLenStub
	fakeReturns := fake.strLenReturns
	fake.recordInvocation("StrLen", []interface{}{arg1, arg2})
	fake.strLenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) StrLenCallCount() int {
	fake.strLenMutex.RLock()
	defer fake.strLenMutex.RUnlock()
	return len(fake.strLenArgsForCall)
}

func (fake *FakeClient) StrLenCalls(stub func(context.Context, string) *redisa.IntCmd) {
	fake.strLenMutex.Lock()
	defer fake.strLenMutex.Unlock()
	fake.StrLenStub = stub
}

func (fake *FakeClient) StrLenArgsForCall(i int) (context.Context, string) {
	fake.strLenMutex.RLock()
	defer fake.strLenMutex.RUnlock()
	argsForCall := fake.strLenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) StrLenReturns(result1 *redisa.IntCmd) {
	fake.strLenMutex.Lock()
	defer fake.strLenMutex.Unlock()
	fake.StrLenStub = nil
	fake.strLenReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) StrLenReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.strLenMutex.Lock()
	defer fake.strLenMutex.Unlock()
	fake.StrLenStub = nil
	if fake.strLenReturnsOnCall == nil {
		fake.strLenReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.strLenReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TDigestAdd(arg1 context.Context, arg2 string, arg3 ...float64) *redisa.StatusCmd {
	fake.tDigestAddMutex.Lock()
	ret, specificReturn := fake.tDigestAddReturnsOnCall[len(fake.tDigestAddArgsForCall)]
	fake.tDigestAddArgsForCall = append(fake.tDigestAddArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []float64
	}{arg1, arg2, arg3})
	stub := fake.TDigestAddStub
	fakeReturns := fake.tDigestAddReturns
	fake.recordInvocation("TDigestAdd", []interface{}{arg1, arg2, arg3})
	fake.tDigestAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestAddCallCount() int {
	fake.tDigestAddMutex.RLock()
	defer fake.tDigestAddMutex.RUnlock()
	return len(fake.tDigestAddArgsForCall)
}

func (fake *FakeClient) TDigestAddCalls(stub func(context.Context, string, ...float64) *redisa.StatusCmd) {
	fake.tDigestAddMutex.Lock()
	defer fake.tDigestAddMutex.Unlock()
	fake.TDigestAddStub = stub
}

func (fake *FakeClient) TDigestAddArgsForCall(i int) (context.Context, string, []float64) {
	fake.tDigestAddMutex.RLock()
	defer fake.tDigestAddMutex.RUnlock()
	argsForCall := fake.tDigestAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TDigestAddReturns(result1 *redisa.StatusCmd) {
	fake.tDigestAddMutex.Lock()
	defer fake.tDigestAddMutex.Unlock()
	fake.TDigestAddStub = nil
	fake.tDigestAddReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TDigestAddReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tDigestAddMutex.Lock()
	defer fake.tDigestAddMutex.Unlock()
	fake.TDigestAddStub = nil
	if fake.tDigestAddReturnsOnCall == nil {
		fake.tDigestAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tDigestAddReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TDigestByRank(arg1 context.Context, arg2 string, arg3 ...uint64) *redisa.FloatSliceCmd {
	fake.tDigestByRankMutex.Lock()
	ret, specificReturn := fake.tDigestByRankReturnsOnCall[len(fake.tDigestByRankArgsForCall)]
	fake.tDigestByRankArgsForCall = append(fake.tDigestByRankArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []uint64
	}{arg1, arg2, arg3})
	stub := fake.TDigestByRankStub
	fakeReturns := fake.tDigestByRankReturns
	fake.recordInvocation("TDigestByRank", []interface{}{arg1, arg2, arg3})
	fake.tDigestByRankMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestByRankCallCount() int {
	fake.tDigestByRankMutex.RLock()
	defer fake.tDigestByRankMutex.RUnlock()
	return len(fake.tDigestByRankArgsForCall)
}

func (fake *FakeClient) TDigestByRankCalls(stub func(context.Context, string, ...uint64) *redisa.FloatSliceCmd) {
	fake.tDigestByRankMutex.Lock()
	defer fake.tDigestByRankMutex.Unlock()
	fake.TDigestByRankStub = stub
}

func (fake *FakeClient) TDigestByRankArgsForCall(i int) (context.Context, string, []uint64) {
	fake.tDigestByRankMutex.RLock()
	defer fake.tDigestByRankMutex.RUnlock()
	argsForCall := fake.tDigestByRankArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TDigestByRankReturns(result1 *redisa.FloatSliceCmd) {
	fake.tDigestByRankMutex.Lock()
	defer fake.tDigestByRankMutex.Unlock()
	fake.TDigestByRankStub = nil
	fake.tDigestByRankReturns = struct {
		result1 *redisa.FloatSliceCmd
	}{result1}
}

func (fake *FakeClient) TDigestByRankReturnsOnCall(i int, result1 *redisa.FloatSliceCmd) {
	fake.tDigestByRankMutex.Lock()
	defer fake.tDigestByRankMutex.Unlock()
	fake.TDigestByRankStub = nil
	if fake.tDigestByRankReturnsOnCall == nil {
		fake.tDigestByRankReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatSliceCmd
		})
	}
	fake.tDigestByRankReturnsOnCall[i] = struct {
		result1 *redisa.FloatSliceCmd
	}{result1}
}

func (fake *FakeClient) TDigestByRevRank(arg1 context.Context, arg2 string, arg3 ...uint64) *redisa.FloatSliceCmd {
	fake.tDigestByRevRankMutex.Lock()
	ret, specificReturn := fake.tDigestByRevRankReturnsOnCall[len(fake.tDigestByRevRankArgsForCall)]
	fake.tDigestByRevRankArgsForCall = append(fake.tDigestByRevRankArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []uint64
	}{arg1, arg2, arg3})
	stub := fake.TDigestByRevRankStub
	fakeReturns := fake.tDigestByRevRankReturns
	fake.recordInvocation("TDigestByRevRank", []interface{}{arg1, arg2, arg3})
	fake.tDigestByRevRankMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestByRevRankCallCount() int {
	fake.tDigestByRevRankMutex.RLock()
	defer fake.tDigestByRevRankMutex.RUnlock()
	return len(fake.tDigestByRevRankArgsForCall)
}

func (fake *FakeClient) TDigestByRevRankCalls(stub func(context.Context, string, ...uint64) *redisa.FloatSliceCmd) {
	fake.tDigestByRevRankMutex.Lock()
	defer fake.tDigestByRevRankMutex.Unlock()
	fake.TDigestByRevRankStub = stub
}

func (fake *FakeClient) TDigestByRevRankArgsForCall(i int) (context.Context, string, []uint64) {
	fake.tDigestByRevRankMutex.RLock()
	defer fake.tDigestByRevRankMutex.RUnlock()
	argsForCall := fake.tDigestByRevRankArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TDigestByRevRankReturns(result1 *redisa.FloatSliceCmd) {
	fake.tDigestByRevRankMutex.Lock()
	defer fake.tDigestByRevRankMutex.Unlock()
	fake.TDigestByRevRankStub = nil
	fake.tDigestByRevRankReturns = struct {
		result1 *redisa.FloatSliceCmd
	}{result1}
}

func (fake *FakeClient) TDigestByRevRankReturnsOnCall(i int, result1 *redisa.FloatSliceCmd) {
	fake.tDigestByRevRankMutex.Lock()
	defer fake.tDigestByRevRankMutex.Unlock()
	fake.TDigestByRevRankStub = nil
	if fake.tDigestByRevRankReturnsOnCall == nil {
		fake.tDigestByRevRankReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatSliceCmd
		})
	}
	fake.tDigestByRevRankReturnsOnCall[i] = struct {
		result1 *redisa.FloatSliceCmd
	}{result1}
}

func (fake *FakeClient) TDigestCDF(arg1 context.Context, arg2 string, arg3 ...float64) *redisa.FloatSliceCmd {
	fake.tDigestCDFMutex.Lock()
	ret, specificReturn := fake.tDigestCDFReturnsOnCall[len(fake.tDigestCDFArgsForCall)]
	fake.tDigestCDFArgsForCall = append(fake.tDigestCDFArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []float64
	}{arg1, arg2, arg3})
	stub := fake.TDigestCDFStub
	fakeReturns := fake.tDigestCDFReturns
	fake.recordInvocation("TDigestCDF", []interface{}{arg1, arg2, arg3})
	fake.tDigestCDFMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestCDFCallCount() int {
	fake.tDigestCDFMutex.RLock()
	defer fake.tDigestCDFMutex.RUnlock()
	return len(fake.tDigestCDFArgsForCall)
}

func (fake *FakeClient) TDigestCDFCalls(stub func(context.Context, string, ...float64) *redisa.FloatSliceCmd) {
	fake.tDigestCDFMutex.Lock()
	defer fake.tDigestCDFMutex.Unlock()
	fake.TDigestCDFStub = stub
}

func (fake *FakeClient) TDigestCDFArgsForCall(i int) (context.Context, string, []float64) {
	fake.tDigestCDFMutex.RLock()
	defer fake.tDigestCDFMutex.RUnlock()
	argsForCall := fake.tDigestCDFArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TDigestCDFReturns(result1 *redisa.FloatSliceCmd) {
	fake.tDigestCDFMutex.Lock()
	defer fake.tDigestCDFMutex.Unlock()
	fake.TDigestCDFStub = nil
	fake.tDigestCDFReturns = struct {
		result1 *redisa.FloatSliceCmd
	}{result1}
}

func (fake *FakeClient) TDigestCDFReturnsOnCall(i int, result1 *redisa.FloatSliceCmd) {
	fake.tDigestCDFMutex.Lock()
	defer fake.tDigestCDFMutex.Unlock()
	fake.TDigestCDFStub = nil
	if fake.tDigestCDFReturnsOnCall == nil {
		fake.tDigestCDFReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatSliceCmd
		})
	}
	fake.tDigestCDFReturnsOnCall[i] = struct {
		result1 *redisa.FloatSliceCmd
	}{result1}
}

func (fake *FakeClient) TDigestCreate(arg1 context.Context, arg2 string) *redisa.StatusCmd {
	fake.tDigestCreateMutex.Lock()
	ret, specificReturn := fake.tDigestCreateReturnsOnCall[len(fake.tDigestCreateArgsForCall)]
	fake.tDigestCreateArgsForCall = append(fake.tDigestCreateArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TDigestCreateStub
	fakeReturns := fake.tDigestCreateReturns
	fake.recordInvocation("TDigestCreate", []interface{}{arg1, arg2})
	fake.tDigestCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestCreateCallCount() int {
	fake.tDigestCreateMutex.RLock()
	defer fake.tDigestCreateMutex.RUnlock()
	return len(fake.tDigestCreateArgsForCall)
}

func (fake *FakeClient) TDigestCreateCalls(stub func(context.Context, string) *redisa.StatusCmd) {
	fake.tDigestCreateMutex.Lock()
	defer fake.tDigestCreateMutex.Unlock()
	fake.TDigestCreateStub = stub
}

func (fake *FakeClient) TDigestCreateArgsForCall(i int) (context.Context, string) {
	fake.tDigestCreateMutex.RLock()
	defer fake.tDigestCreateMutex.RUnlock()
	argsForCall := fake.tDigestCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TDigestCreateReturns(result1 *redisa.StatusCmd) {
	fake.tDigestCreateMutex.Lock()
	defer fake.tDigestCreateMutex.Unlock()
	fake.TDigestCreateStub = nil
	fake.tDigestCreateReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TDigestCreateReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tDigestCreateMutex.Lock()
	defer fake.tDigestCreateMutex.Unlock()
	fake.TDigestCreateStub = nil
	if fake.tDigestCreateReturnsOnCall == nil {
		fake.tDigestCreateReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tDigestCreateReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TDigestCreateWithCompression(arg1 context.Context, arg2 string, arg3 int64) *redisa.StatusCmd {
	fake.tDigestCreateWithCompressionMutex.Lock()
	ret, specificReturn := fake.tDigestCreateWithCompressionReturnsOnCall[len(fake.tDigestCreateWithCompressionArgsForCall)]
	fake.tDigestCreateWithCompressionArgsForCall = append(fake.tDigestCreateWithCompressionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.TDigestCreateWithCompressionStub
	fakeReturns := fake.tDigestCreateWithCompressionReturns
	fake.recordInvocation("TDigestCreateWithCompression", []interface{}{arg1, arg2, arg3})
	fake.tDigestCreateWithCompressionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestCreateWithCompressionCallCount() int {
	fake.tDigestCreateWithCompressionMutex.RLock()
	defer fake.tDigestCreateWithCompressionMutex.RUnlock()
	return len(fake.tDigestCreateWithCompressionArgsForCall)
}

func (fake *FakeClient) TDigestCreateWithCompressionCalls(stub func(context.Context, string, int64) *redisa.StatusCmd) {
	fake.tDigestCreateWithCompressionMutex.Lock()
	defer fake.tDigestCreateWithCompressionMutex.Unlock()
	fake.TDigestCreateWithCompressionStub = stub
}

func (fake *FakeClient) TDigestCreateWithCompressionArgsForCall(i int) (context.Context, string, int64) {
	fake.tDigestCreateWithCompressionMutex.RLock()
	defer fake.tDigestCreateWithCompressionMutex.RUnlock()
	argsForCall := fake.tDigestCreateWithCompressionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TDigestCreateWithCompressionReturns(result1 *redisa.StatusCmd) {
	fake.tDigestCreateWithCompressionMutex.Lock()
	defer fake.tDigestCreateWithCompressionMutex.Unlock()
	fake.TDigestCreateWithCompressionStub = nil
	fake.tDigestCreateWithCompressionReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TDigestCreateWithCompressionReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tDigestCreateWithCompressionMutex.Lock()
	defer fake.tDigestCreateWithCompressionMutex.Unlock()
	fake.TDigestCreateWithCompressionStub = nil
	if fake.tDigestCreateWithCompressionReturnsOnCall == nil {
		fake.tDigestCreateWithCompressionReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tDigestCreateWithCompressionReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TDigestInfo(arg1 context.Context, arg2 string) *redisa.TDigestInfoCmd {
	fake.tDigestInfoMutex.Lock()
	ret, specificReturn := fake.tDigestInfoReturnsOnCall[len(fake.tDigestInfoArgsForCall)]
	fake.tDigestInfoArgsForCall = append(fake.tDigestInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TDigestInfoStub
	fakeReturns := fake.tDigestInfoReturns
	fake.recordInvocation("TDigestInfo", []interface{}{arg1, arg2})
	fake.tDigestInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestInfoCallCount() int {
	fake.tDigestInfoMutex.RLock()
	defer fake.tDigestInfoMutex.RUnlock()
	return len(fake.tDigestInfoArgsForCall)
}

func (fake *FakeClient) TDigestInfoCalls(stub func(context.Context, string) *redisa.TDigestInfoCmd) {
	fake.tDigestInfoMutex.Lock()
	defer fake.tDigestInfoMutex.Unlock()
	fake.TDigestInfoStub = stub
}

func (fake *FakeClient) TDigestInfoArgsForCall(i int) (context.Context, string) {
	fake.tDigestInfoMutex.RLock()
	defer fake.tDigestInfoMutex.RUnlock()
	argsForCall := fake.tDigestInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TDigestInfoReturns(result1 *redisa.TDigestInfoCmd) {
	fake.tDigestInfoMutex.Lock()
	defer fake.tDigestInfoMutex.Unlock()
	fake.TDigestInfoStub = nil
	fake.tDigestInfoReturns = struct {
		result1 *redisa.TDigestInfoCmd
	}{result1}
}

func (fake *FakeClient) TDigestInfoReturnsOnCall(i int, result1 *redisa.TDigestInfoCmd) {
	fake.tDigestInfoMutex.Lock()
	defer fake.tDigestInfoMutex.Unlock()
	fake.TDigestInfoStub = nil
	if fake.tDigestInfoReturnsOnCall == nil {
		fake.tDigestInfoReturnsOnCall = make(map[int]struct {
			result1 *redisa.TDigestInfoCmd
		})
	}
	fake.tDigestInfoReturnsOnCall[i] = struct {
		result1 *redisa.TDigestInfoCmd
	}{result1}
}

func (fake *FakeClient) TDigestMax(arg1 context.Context, arg2 string) *redisa.FloatCmd {
	fake.tDigestMaxMutex.Lock()
	ret, specificReturn := fake.tDigestMaxReturnsOnCall[len(fake.tDigestMaxArgsForCall)]
	fake.tDigestMaxArgsForCall = append(fake.tDigestMaxArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TDigestMaxStub
	fakeReturns := fake.tDigestMaxReturns
	fake.recordInvocation("TDigestMax", []interface{}{arg1, arg2})
	fake.tDigestMaxMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestMaxCallCount() int {
	fake.tDigestMaxMutex.RLock()
	defer fake.tDigestMaxMutex.RUnlock()
	return len(fake.tDigestMaxArgsForCall)
}

func (fake *FakeClient) TDigestMaxCalls(stub func(context.Context, string) *redisa.FloatCmd) {
	fake.tDigestMaxMutex.Lock()
	defer fake.tDigestMaxMutex.Unlock()
	fake.TDigestMaxStub = stub
}

func (fake *FakeClient) TDigestMaxArgsForCall(i int) (context.Context, string) {
	fake.tDigestMaxMutex.RLock()
	defer fake.tDigestMaxMutex.RUnlock()
	argsForCall := fake.tDigestMaxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TDigestMaxReturns(result1 *redisa.FloatCmd) {
	fake.tDigestMaxMutex.Lock()
	defer fake.tDigestMaxMutex.Unlock()
	fake.TDigestMaxStub = nil
	fake.tDigestMaxReturns = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) TDigestMaxReturnsOnCall(i int, result1 *redisa.FloatCmd) {
	fake.tDigestMaxMutex.Lock()
	defer fake.tDigestMaxMutex.Unlock()
	fake.TDigestMaxStub = nil
	if fake.tDigestMaxReturnsOnCall == nil {
		fake.tDigestMaxReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatCmd
		})
	}
	fake.tDigestMaxReturnsOnCall[i] = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) TDigestMerge(arg1 context.Context, arg2 string, arg3 *redisa.TDigestMergeOptions, arg4 ...string) *redisa.StatusCmd {
	fake.tDigestMergeMutex.Lock()
	ret, specificReturn := fake.tDigestMergeReturnsOnCall[len(fake.tDigestMergeArgsForCall)]
	fake.tDigestMergeArgsForCall = append(fake.tDigestMergeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.TDigestMergeOptions
		arg4 []string
	}{arg1, arg2, arg3, arg4})
	stub := fake.TDigestMergeStub
	fakeReturns := fake.tDigestMergeReturns
	fake.recordInvocation("TDigestMerge", []interface{}{arg1, arg2, arg3, arg4})
	fake.tDigestMergeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestMergeCallCount() int {
	fake.tDigestMergeMutex.RLock()
	defer fake.tDigestMergeMutex.RUnlock()
	return len(fake.tDigestMergeArgsForCall)
}

func (fake *FakeClient) TDigestMergeCalls(stub func(context.Context, string, *redisa.TDigestMergeOptions, ...string) *redisa.StatusCmd) {
	fake.tDigestMergeMutex.Lock()
	defer fake.tDigestMergeMutex.Unlock()
	fake.TDigestMergeStub = stub
}

func (fake *FakeClient) TDigestMergeArgsForCall(i int) (context.Context, string, *redisa.TDigestMergeOptions, []string) {
	fake.tDigestMergeMutex.RLock()
	defer fake.tDigestMergeMutex.RUnlock()
	argsForCall := fake.tDigestMergeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) TDigestMergeReturns(result1 *redisa.StatusCmd) {
	fake.tDigestMergeMutex.Lock()
	defer fake.tDigestMergeMutex.Unlock()
	fake.TDigestMergeStub = nil
	fake.tDigestMergeReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TDigestMergeReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tDigestMergeMutex.Lock()
	defer fake.tDigestMergeMutex.Unlock()
	fake.TDigestMergeStub = nil
	if fake.tDigestMergeReturnsOnCall == nil {
		fake.tDigestMergeReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tDigestMergeReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TDigestMin(arg1 context.Context, arg2 string) *redisa.FloatCmd {
	fake.tDigestMinMutex.Lock()
	ret, specificReturn := fake.tDigestMinReturnsOnCall[len(fake.tDigestMinArgsForCall)]
	fake.tDigestMinArgsForCall = append(fake.tDigestMinArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TDigestMinStub
	fakeReturns := fake.tDigestMinReturns
	fake.recordInvocation("TDigestMin", []interface{}{arg1, arg2})
	fake.tDigestMinMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestMinCallCount() int {
	fake.tDigestMinMutex.RLock()
	defer fake.tDigestMinMutex.RUnlock()
	return len(fake.tDigestMinArgsForCall)
}

func (fake *FakeClient) TDigestMinCalls(stub func(context.Context, string) *redisa.FloatCmd) {
	fake.tDigestMinMutex.Lock()
	defer fake.tDigestMinMutex.Unlock()
	fake.TDigestMinStub = stub
}

func (fake *FakeClient) TDigestMinArgsForCall(i int) (context.Context, string) {
	fake.tDigestMinMutex.RLock()
	defer fake.tDigestMinMutex.RUnlock()
	argsForCall := fake.tDigestMinArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TDigestMinReturns(result1 *redisa.FloatCmd) {
	fake.tDigestMinMutex.Lock()
	defer fake.tDigestMinMutex.Unlock()
	fake.TDigestMinStub = nil
	fake.tDigestMinReturns = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) TDigestMinReturnsOnCall(i int, result1 *redisa.FloatCmd) {
	fake.tDigestMinMutex.Lock()
	defer fake.tDigestMinMutex.Unlock()
	fake.TDigestMinStub = nil
	if fake.tDigestMinReturnsOnCall == nil {
		fake.tDigestMinReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatCmd
		})
	}
	fake.tDigestMinReturnsOnCall[i] = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) TDigestQuantile(arg1 context.Context, arg2 string, arg3 ...float64) *redisa.FloatSliceCmd {
	fake.tDigestQuantileMutex.Lock()
	ret, specificReturn := fake.tDigestQuantileReturnsOnCall[len(fake.tDigestQuantileArgsForCall)]
	fake.tDigestQuantileArgsForCall = append(fake.tDigestQuantileArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []float64
	}{arg1, arg2, arg3})
	stub := fake.TDigestQuantileStub
	fakeReturns := fake.tDigestQuantileReturns
	fake.recordInvocation("TDigestQuantile", []interface{}{arg1, arg2, arg3})
	fake.tDigestQuantileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestQuantileCallCount() int {
	fake.tDigestQuantileMutex.RLock()
	defer fake.tDigestQuantileMutex.RUnlock()
	return len(fake.tDigestQuantileArgsForCall)
}

func (fake *FakeClient) TDigestQuantileCalls(stub func(context.Context, string, ...float64) *redisa.FloatSliceCmd) {
	fake.tDigestQuantileMutex.Lock()
	defer fake.tDigestQuantileMutex.Unlock()
	fake.TDigestQuantileStub = stub
}

func (fake *FakeClient) TDigestQuantileArgsForCall(i int) (context.Context, string, []float64) {
	fake.tDigestQuantileMutex.RLock()
	defer fake.tDigestQuantileMutex.RUnlock()
	argsForCall := fake.tDigestQuantileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TDigestQuantileReturns(result1 *redisa.FloatSliceCmd) {
	fake.tDigestQuantileMutex.Lock()
	defer fake.tDigestQuantileMutex.Unlock()
	fake.TDigestQuantileStub = nil
	fake.tDigestQuantileReturns = struct {
		result1 *redisa.FloatSliceCmd
	}{result1}
}

func (fake *FakeClient) TDigestQuantileReturnsOnCall(i int, result1 *redisa.FloatSliceCmd) {
	fake.tDigestQuantileMutex.Lock()
	defer fake.tDigestQuantileMutex.Unlock()
	fake.TDigestQuantileStub = nil
	if fake.tDigestQuantileReturnsOnCall == nil {
		fake.tDigestQuantileReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatSliceCmd
		})
	}
	fake.tDigestQuantileReturnsOnCall[i] = struct {
		result1 *redisa.FloatSliceCmd
	}{result1}
}

func (fake *FakeClient) TDigestRank(arg1 context.Context, arg2 string, arg3 ...float64) *redisa.IntSliceCmd {
	fake.tDigestRankMutex.Lock()
	ret, specificReturn := fake.tDigestRankReturnsOnCall[len(fake.tDigestRankArgsForCall)]
	fake.tDigestRankArgsForCall = append(fake.tDigestRankArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []float64
	}{arg1, arg2, arg3})
	stub := fake.TDigestRankStub
	fakeReturns := fake.tDigestRankReturns
	fake.recordInvocation("TDigestRank", []interface{}{arg1, arg2, arg3})
	fake.tDigestRankMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestRankCallCount() int {
	fake.tDigestRankMutex.RLock()
	defer fake.tDigestRankMutex.RUnlock()
	return len(fake.tDigestRankArgsForCall)
}

func (fake *FakeClient) TDigestRankCalls(stub func(context.Context, string, ...float64) *redisa.IntSliceCmd) {
	fake.tDigestRankMutex.Lock()
	defer fake.tDigestRankMutex.Unlock()
	fake.TDigestRankStub = stub
}

func (fake *FakeClient) TDigestRankArgsForCall(i int) (context.Context, string, []float64) {
	fake.tDigestRankMutex.RLock()
	defer fake.tDigestRankMutex.RUnlock()
	argsForCall := fake.tDigestRankArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TDigestRankReturns(result1 *redisa.IntSliceCmd) {
	fake.tDigestRankMutex.Lock()
	defer fake.tDigestRankMutex.Unlock()
	fake.TDigestRankStub = nil
	fake.tDigestRankReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) TDigestRankReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.tDigestRankMutex.Lock()
	defer fake.tDigestRankMutex.Unlock()
	fake.TDigestRankStub = nil
	if fake.tDigestRankReturnsOnCall == nil {
		fake.tDigestRankReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.tDigestRankReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) TDigestReset(arg1 context.Context, arg2 string) *redisa.StatusCmd {
	fake.tDigestResetMutex.Lock()
	ret, specificReturn := fake.tDigestResetReturnsOnCall[len(fake.tDigestResetArgsForCall)]
	fake.tDigestResetArgsForCall = append(fake.tDigestResetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TDigestResetStub
	fakeReturns := fake.tDigestResetReturns
	fake.recordInvocation("TDigestReset", []interface{}{arg1, arg2})
	fake.tDigestResetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestResetCallCount() int {
	fake.tDigestResetMutex.RLock()
	defer fake.tDigestResetMutex.RUnlock()
	return len(fake.tDigestResetArgsForCall)
}

func (fake *FakeClient) TDigestResetCalls(stub func(context.Context, string) *redisa.StatusCmd) {
	fake.tDigestResetMutex.Lock()
	defer fake.tDigestResetMutex.Unlock()
	fake.TDigestResetStub = stub
}

func (fake *FakeClient) TDigestResetArgsForCall(i int) (context.Context, string) {
	fake.tDigestResetMutex.RLock()
	defer fake.tDigestResetMutex.RUnlock()
	argsForCall := fake.tDigestResetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TDigestResetReturns(result1 *redisa.StatusCmd) {
	fake.tDigestResetMutex.Lock()
	defer fake.tDigestResetMutex.Unlock()
	fake.TDigestResetStub = nil
	fake.tDigestResetReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TDigestResetReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tDigestResetMutex.Lock()
	defer fake.tDigestResetMutex.Unlock()
	fake.TDigestResetStub = nil
	if fake.tDigestResetReturnsOnCall == nil {
		fake.tDigestResetReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tDigestResetReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TDigestRevRank(arg1 context.Context, arg2 string, arg3 ...float64) *redisa.IntSliceCmd {
	fake.tDigestRevRankMutex.Lock()
	ret, specificReturn := fake.tDigestRevRankReturnsOnCall[len(fake.tDigestRevRankArgsForCall)]
	fake.tDigestRevRankArgsForCall = append(fake.tDigestRevRankArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []float64
	}{arg1, arg2, arg3})
	stub := fake.TDigestRevRankStub
	fakeReturns := fake.tDigestRevRankReturns
	fake.recordInvocation("TDigestRevRank", []interface{}{arg1, arg2, arg3})
	fake.tDigestRevRankMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestRevRankCallCount() int {
	fake.tDigestRevRankMutex.RLock()
	defer fake.tDigestRevRankMutex.RUnlock()
	return len(fake.tDigestRevRankArgsForCall)
}

func (fake *FakeClient) TDigestRevRankCalls(stub func(context.Context, string, ...float64) *redisa.IntSliceCmd) {
	fake.tDigestRevRankMutex.Lock()
	defer fake.tDigestRevRankMutex.Unlock()
	fake.TDigestRevRankStub = stub
}

func (fake *FakeClient) TDigestRevRankArgsForCall(i int) (context.Context, string, []float64) {
	fake.tDigestRevRankMutex.RLock()
	defer fake.tDigestRevRankMutex.RUnlock()
	argsForCall := fake.tDigestRevRankArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TDigestRevRankReturns(result1 *redisa.IntSliceCmd) {
	fake.tDigestRevRankMutex.Lock()
	defer fake.tDigestRevRankMutex.Unlock()
	fake.TDigestRevRankStub = nil
	fake.tDigestRevRankReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) TDigestRevRankReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.tDigestRevRankMutex.Lock()
	defer fake.tDigestRevRankMutex.Unlock()
	fake.TDigestRevRankStub = nil
	if fake.tDigestRevRankReturnsOnCall == nil {
		fake.tDigestRevRankReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.tDigestRevRankReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) TDigestTrimmedMean(arg1 context.Context, arg2 string, arg3 float64, arg4 float64) *redisa.FloatCmd {
	fake.tDigestTrimmedMeanMutex.Lock()
	ret, specificReturn := fake.tDigestTrimmedMeanReturnsOnCall[len(fake.tDigestTrimmedMeanArgsForCall)]
	fake.tDigestTrimmedMeanArgsForCall = append(fake.tDigestTrimmedMeanArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 float64
	}{arg1, arg2, arg3, arg4})
	stub := fake.TDigestTrimmedMeanStub
	fakeReturns := fake.tDigestTrimmedMeanReturns
	fake.recordInvocation("TDigestTrimmedMean", []interface{}{arg1, arg2, arg3, arg4})
	fake.tDigestTrimmedMeanMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TDigestTrimmedMeanCallCount() int {
	fake.tDigestTrimmedMeanMutex.RLock()
	defer fake.tDigestTrimmedMeanMutex.RUnlock()
	return len(fake.tDigestTrimmedMeanArgsForCall)
}

func (fake *FakeClient) TDigestTrimmedMeanCalls(stub func(context.Context, string, float64, float64) *redisa.FloatCmd) {
	fake.tDigestTrimmedMeanMutex.Lock()
	defer fake.tDigestTrimmedMeanMutex.Unlock()
	fake.TDigestTrimmedMeanStub = stub
}

func (fake *FakeClient) TDigestTrimmedMeanArgsForCall(i int) (context.Context, string, float64, float64) {
	fake.tDigestTrimmedMeanMutex.RLock()
	defer fake.tDigestTrimmedMeanMutex.RUnlock()
	argsForCall := fake.tDigestTrimmedMeanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) TDigestTrimmedMeanReturns(result1 *redisa.FloatCmd) {
	fake.tDigestTrimmedMeanMutex.Lock()
	defer fake.tDigestTrimmedMeanMutex.Unlock()
	fake.TDigestTrimmedMeanStub = nil
	fake.tDigestTrimmedMeanReturns = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) TDigestTrimmedMeanReturnsOnCall(i int, result1 *redisa.FloatCmd) {
	fake.tDigestTrimmedMeanMutex.Lock()
	defer fake.tDigestTrimmedMeanMutex.Unlock()
	fake.TDigestTrimmedMeanStub = nil
	if fake.tDigestTrimmedMeanReturnsOnCall == nil {
		fake.tDigestTrimmedMeanReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatCmd
		})
	}
	fake.tDigestTrimmedMeanReturnsOnCall[i] = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) TFCall(arg1 context.Context, arg2 string, arg3 string, arg4 int) *redisa.Cmd {
	fake.tFCallMutex.Lock()
	ret, specificReturn := fake.tFCallReturnsOnCall[len(fake.tFCallArgsForCall)]
	fake.tFCallArgsForCall = append(fake.tFCallArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.TFCallStub
	fakeReturns := fake.tFCallReturns
	fake.recordInvocation("TFCall", []interface{}{arg1, arg2, arg3, arg4})
	fake.tFCallMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TFCallCallCount() int {
	fake.tFCallMutex.RLock()
	defer fake.tFCallMutex.RUnlock()
	return len(fake.tFCallArgsForCall)
}

func (fake *FakeClient) TFCallCalls(stub func(context.Context, string, string, int) *redisa.Cmd) {
	fake.tFCallMutex.Lock()
	defer fake.tFCallMutex.Unlock()
	fake.TFCallStub = stub
}

func (fake *FakeClient) TFCallArgsForCall(i int) (context.Context, string, string, int) {
	fake.tFCallMutex.RLock()
	defer fake.tFCallMutex.RUnlock()
	argsForCall := fake.tFCallArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) TFCallReturns(result1 *redisa.Cmd) {
	fake.tFCallMutex.Lock()
	defer fake.tFCallMutex.Unlock()
	fake.TFCallStub = nil
	fake.tFCallReturns = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) TFCallReturnsOnCall(i int, result1 *redisa.Cmd) {
	fake.tFCallMutex.Lock()
	defer fake.tFCallMutex.Unlock()
	fake.TFCallStub = nil
	if fake.tFCallReturnsOnCall == nil {
		fake.tFCallReturnsOnCall = make(map[int]struct {
			result1 *redisa.Cmd
		})
	}
	fake.tFCallReturnsOnCall[i] = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) TFCallASYNC(arg1 context.Context, arg2 string, arg3 string, arg4 int) *redisa.Cmd {
	fake.tFCallASYNCMutex.Lock()
	ret, specificReturn := fake.tFCallASYNCReturnsOnCall[len(fake.tFCallASYNCArgsForCall)]
	fake.tFCallASYNCArgsForCall = append(fake.tFCallASYNCArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.TFCallASYNCStub
	fakeReturns := fake.tFCallASYNCReturns
	fake.recordInvocation("TFCallASYNC", []interface{}{arg1, arg2, arg3, arg4})
	fake.tFCallASYNCMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TFCallASYNCCallCount() int {
	fake.tFCallASYNCMutex.RLock()
	defer fake.tFCallASYNCMutex.RUnlock()
	return len(fake.tFCallASYNCArgsForCall)
}

func (fake *FakeClient) TFCallASYNCCalls(stub func(context.Context, string, string, int) *redisa.Cmd) {
	fake.tFCallASYNCMutex.Lock()
	defer fake.tFCallASYNCMutex.Unlock()
	fake.TFCallASYNCStub = stub
}

func (fake *FakeClient) TFCallASYNCArgsForCall(i int) (context.Context, string, string, int) {
	fake.tFCallASYNCMutex.RLock()
	defer fake.tFCallASYNCMutex.RUnlock()
	argsForCall := fake.tFCallASYNCArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) TFCallASYNCReturns(result1 *redisa.Cmd) {
	fake.tFCallASYNCMutex.Lock()
	defer fake.tFCallASYNCMutex.Unlock()
	fake.TFCallASYNCStub = nil
	fake.tFCallASYNCReturns = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) TFCallASYNCReturnsOnCall(i int, result1 *redisa.Cmd) {
	fake.tFCallASYNCMutex.Lock()
	defer fake.tFCallASYNCMutex.Unlock()
	fake.TFCallASYNCStub = nil
	if fake.tFCallASYNCReturnsOnCall == nil {
		fake.tFCallASYNCReturnsOnCall = make(map[int]struct {
			result1 *redisa.Cmd
		})
	}
	fake.tFCallASYNCReturnsOnCall[i] = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) TFCallASYNCArgs(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 *redisa.TFCallOptions) *redisa.Cmd {
	fake.tFCallASYNCArgsMutex.Lock()
	ret, specificReturn := fake.tFCallASYNCArgsReturnsOnCall[len(fake.tFCallASYNCArgsArgsForCall)]
	fake.tFCallASYNCArgsArgsForCall = append(fake.tFCallASYNCArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *redisa.TFCallOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.TFCallASYNCArgsStub
	fakeReturns := fake.tFCallASYNCArgsReturns
	fake.recordInvocation("TFCallASYNCArgs", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.tFCallASYNCArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TFCallASYNCArgsCallCount() int {
	fake.tFCallASYNCArgsMutex.RLock()
	defer fake.tFCallASYNCArgsMutex.RUnlock()
	return len(fake.tFCallASYNCArgsArgsForCall)
}

func (fake *FakeClient) TFCallASYNCArgsCalls(stub func(context.Context, string, string, int, *redisa.TFCallOptions) *redisa.Cmd) {
	fake.tFCallASYNCArgsMutex.Lock()
	defer fake.tFCallASYNCArgsMutex.Unlock()
	fake.TFCallASYNCArgsStub = stub
}

func (fake *FakeClient) TFCallASYNCArgsArgsForCall(i int) (context.Context, string, string, int, *redisa.TFCallOptions) {
	fake.tFCallASYNCArgsMutex.RLock()
	defer fake.tFCallASYNCArgsMutex.RUnlock()
	argsForCall := fake.tFCallASYNCArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) TFCallASYNCArgsReturns(result1 *redisa.Cmd) {
	fake.tFCallASYNCArgsMutex.Lock()
	defer fake.tFCallASYNCArgsMutex.Unlock()
	fake.TFCallASYNCArgsStub = nil
	fake.tFCallASYNCArgsReturns = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) TFCallASYNCArgsReturnsOnCall(i int, result1 *redisa.Cmd) {
	fake.tFCallASYNCArgsMutex.Lock()
	defer fake.tFCallASYNCArgsMutex.Unlock()
	fake.TFCallASYNCArgsStub = nil
	if fake.tFCallASYNCArgsReturnsOnCall == nil {
		fake.tFCallASYNCArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.Cmd
		})
	}
	fake.tFCallASYNCArgsReturnsOnCall[i] = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) TFCallArgs(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 *redisa.TFCallOptions) *redisa.Cmd {
	fake.tFCallArgsMutex.Lock()
	ret, specificReturn := fake.tFCallArgsReturnsOnCall[len(fake.tFCallArgsArgsForCall)]
	fake.tFCallArgsArgsForCall = append(fake.tFCallArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *redisa.TFCallOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.TFCallArgsStub
	fakeReturns := fake.tFCallArgsReturns
	fake.recordInvocation("TFCallArgs", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.tFCallArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TFCallArgsCallCount() int {
	fake.tFCallArgsMutex.RLock()
	defer fake.tFCallArgsMutex.RUnlock()
	return len(fake.tFCallArgsArgsForCall)
}

func (fake *FakeClient) TFCallArgsCalls(stub func(context.Context, string, string, int, *redisa.TFCallOptions) *redisa.Cmd) {
	fake.tFCallArgsMutex.Lock()
	defer fake.tFCallArgsMutex.Unlock()
	fake.TFCallArgsStub = stub
}

func (fake *FakeClient) TFCallArgsArgsForCall(i int) (context.Context, string, string, int, *redisa.TFCallOptions) {
	fake.tFCallArgsMutex.RLock()
	defer fake.tFCallArgsMutex.RUnlock()
	argsForCall := fake.tFCallArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) TFCallArgsReturns(result1 *redisa.Cmd) {
	fake.tFCallArgsMutex.Lock()
	defer fake.tFCallArgsMutex.Unlock()
	fake.TFCallArgsStub = nil
	fake.tFCallArgsReturns = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) TFCallArgsReturnsOnCall(i int, result1 *redisa.Cmd) {
	fake.tFCallArgsMutex.Lock()
	defer fake.tFCallArgsMutex.Unlock()
	fake.TFCallArgsStub = nil
	if fake.tFCallArgsReturnsOnCall == nil {
		fake.tFCallArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.Cmd
		})
	}
	fake.tFCallArgsReturnsOnCall[i] = struct {
		result1 *redisa.Cmd
	}{result1}
}

func (fake *FakeClient) TFunctionDelete(arg1 context.Context, arg2 string) *redisa.StatusCmd {
	fake.tFunctionDeleteMutex.Lock()
	ret, specificReturn := fake.tFunctionDeleteReturnsOnCall[len(fake.tFunctionDeleteArgsForCall)]
	fake.tFunctionDeleteArgsForCall = append(fake.tFunctionDeleteArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TFunctionDeleteStub
	fakeReturns := fake.tFunctionDeleteReturns
	fake.recordInvocation("TFunctionDelete", []interface{}{arg1, arg2})
	fake.tFunctionDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TFunctionDeleteCallCount() int {
	fake.tFunctionDeleteMutex.RLock()
	defer fake.tFunctionDeleteMutex.RUnlock()
	return len(fake.tFunctionDeleteArgsForCall)
}

func (fake *FakeClient) TFunctionDeleteCalls(stub func(context.Context, string) *redisa.StatusCmd) {
	fake.tFunctionDeleteMutex.Lock()
	defer fake.tFunctionDeleteMutex.Unlock()
	fake.TFunctionDeleteStub = stub
}

func (fake *FakeClient) TFunctionDeleteArgsForCall(i int) (context.Context, string) {
	fake.tFunctionDeleteMutex.RLock()
	defer fake.tFunctionDeleteMutex.RUnlock()
	argsForCall := fake.tFunctionDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TFunctionDeleteReturns(result1 *redisa.StatusCmd) {
	fake.tFunctionDeleteMutex.Lock()
	defer fake.tFunctionDeleteMutex.Unlock()
	fake.TFunctionDeleteStub = nil
	fake.tFunctionDeleteReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TFunctionDeleteReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tFunctionDeleteMutex.Lock()
	defer fake.tFunctionDeleteMutex.Unlock()
	fake.TFunctionDeleteStub = nil
	if fake.tFunctionDeleteReturnsOnCall == nil {
		fake.tFunctionDeleteReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tFunctionDeleteReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TFunctionList(arg1 context.Context) *redisa.MapStringInterfaceSliceCmd {
	fake.tFunctionListMutex.Lock()
	ret, specificReturn := fake.tFunctionListReturnsOnCall[len(fake.tFunctionListArgsForCall)]
	fake.tFunctionListArgsForCall = append(fake.tFunctionListArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.TFunctionListStub
	fakeReturns := fake.tFunctionListReturns
	fake.recordInvocation("TFunctionList", []interface{}{arg1})
	fake.tFunctionListMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TFunctionListCallCount() int {
	fake.tFunctionListMutex.RLock()
	defer fake.tFunctionListMutex.RUnlock()
	return len(fake.tFunctionListArgsForCall)
}

func (fake *FakeClient) TFunctionListCalls(stub func(context.Context) *redisa.MapStringInterfaceSliceCmd) {
	fake.tFunctionListMutex.Lock()
	defer fake.tFunctionListMutex.Unlock()
	fake.TFunctionListStub = stub
}

func (fake *FakeClient) TFunctionListArgsForCall(i int) context.Context {
	fake.tFunctionListMutex.RLock()
	defer fake.tFunctionListMutex.RUnlock()
	argsForCall := fake.tFunctionListArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) TFunctionListReturns(result1 *redisa.MapStringInterfaceSliceCmd) {
	fake.tFunctionListMutex.Lock()
	defer fake.tFunctionListMutex.Unlock()
	fake.TFunctionListStub = nil
	fake.tFunctionListReturns = struct {
		result1 *redisa.MapStringInterfaceSliceCmd
	}{result1}
}

func (fake *FakeClient) TFunctionListReturnsOnCall(i int, result1 *redisa.MapStringInterfaceSliceCmd) {
	fake.tFunctionListMutex.Lock()
	defer fake.tFunctionListMutex.Unlock()
	fake.TFunctionListStub = nil
	if fake.tFunctionListReturnsOnCall == nil {
		fake.tFunctionListReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringInterfaceSliceCmd
		})
	}
	fake.tFunctionListReturnsOnCall[i] = struct {
		result1 *redisa.MapStringInterfaceSliceCmd
	}{result1}
}

func (fake *FakeClient) TFunctionListArgs(arg1 context.Context, arg2 *redisa.TFunctionListOptions) *redisa.MapStringInterfaceSliceCmd {
	fake.tFunctionListArgsMutex.Lock()
	ret, specificReturn := fake.tFunctionListArgsReturnsOnCall[len(fake.tFunctionListArgsArgsForCall)]
	fake.tFunctionListArgsArgsForCall = append(fake.tFunctionListArgsArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.TFunctionListOptions
	}{arg1, arg2})
	stub := fake.TFunctionListArgsStub
	fakeReturns := fake.tFunctionListArgsReturns
	fake.recordInvocation("TFunctionListArgs", []interface{}{arg1, arg2})
	fake.tFunctionListArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TFunctionListArgsCallCount() int {
	fake.tFunctionListArgsMutex.RLock()
	defer fake.tFunctionListArgsMutex.RUnlock()
	return len(fake.tFunctionListArgsArgsForCall)
}

func (fake *FakeClient) TFunctionListArgsCalls(stub func(context.Context, *redisa.TFunctionListOptions) *redisa.MapStringInterfaceSliceCmd) {
	fake.tFunctionListArgsMutex.Lock()
	defer fake.tFunctionListArgsMutex.Unlock()
	fake.TFunctionListArgsStub = stub
}

func (fake *FakeClient) TFunctionListArgsArgsForCall(i int) (context.Context, *redisa.TFunctionListOptions) {
	fake.tFunctionListArgsMutex.RLock()
	defer fake.tFunctionListArgsMutex.RUnlock()
	argsForCall := fake.tFunctionListArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TFunctionListArgsReturns(result1 *redisa.MapStringInterfaceSliceCmd) {
	fake.tFunctionListArgsMutex.Lock()
	defer fake.tFunctionListArgsMutex.Unlock()
	fake.TFunctionListArgsStub = nil
	fake.tFunctionListArgsReturns = struct {
		result1 *redisa.MapStringInterfaceSliceCmd
	}{result1}
}

func (fake *FakeClient) TFunctionListArgsReturnsOnCall(i int, result1 *redisa.MapStringInterfaceSliceCmd) {
	fake.tFunctionListArgsMutex.Lock()
	defer fake.tFunctionListArgsMutex.Unlock()
	fake.TFunctionListArgsStub = nil
	if fake.tFunctionListArgsReturnsOnCall == nil {
		fake.tFunctionListArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringInterfaceSliceCmd
		})
	}
	fake.tFunctionListArgsReturnsOnCall[i] = struct {
		result1 *redisa.MapStringInterfaceSliceCmd
	}{result1}
}

func (fake *FakeClient) TFunctionLoad(arg1 context.Context, arg2 string) *redisa.StatusCmd {
	fake.tFunctionLoadMutex.Lock()
	ret, specificReturn := fake.tFunctionLoadReturnsOnCall[len(fake.tFunctionLoadArgsForCall)]
	fake.tFunctionLoadArgsForCall = append(fake.tFunctionLoadArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TFunctionLoadStub
	fakeReturns := fake.tFunctionLoadReturns
	fake.recordInvocation("TFunctionLoad", []interface{}{arg1, arg2})
	fake.tFunctionLoadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TFunctionLoadCallCount() int {
	fake.tFunctionLoadMutex.RLock()
	defer fake.tFunctionLoadMutex.RUnlock()
	return len(fake.tFunctionLoadArgsForCall)
}

func (fake *FakeClient) TFunctionLoadCalls(stub func(context.Context, string) *redisa.StatusCmd) {
	fake.tFunctionLoadMutex.Lock()
	defer fake.tFunctionLoadMutex.Unlock()
	fake.TFunctionLoadStub = stub
}

func (fake *FakeClient) TFunctionLoadArgsForCall(i int) (context.Context, string) {
	fake.tFunctionLoadMutex.RLock()
	defer fake.tFunctionLoadMutex.RUnlock()
	argsForCall := fake.tFunctionLoadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TFunctionLoadReturns(result1 *redisa.StatusCmd) {
	fake.tFunctionLoadMutex.Lock()
	defer fake.tFunctionLoadMutex.Unlock()
	fake.TFunctionLoadStub = nil
	fake.tFunctionLoadReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TFunctionLoadReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tFunctionLoadMutex.Lock()
	defer fake.tFunctionLoadMutex.Unlock()
	fake.TFunctionLoadStub = nil
	if fake.tFunctionLoadReturnsOnCall == nil {
		fake.tFunctionLoadReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tFunctionLoadReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TFunctionLoadArgs(arg1 context.Context, arg2 string, arg3 *redisa.TFunctionLoadOptions) *redisa.StatusCmd {
	fake.tFunctionLoadArgsMutex.Lock()
	ret, specificReturn := fake.tFunctionLoadArgsReturnsOnCall[len(fake.tFunctionLoadArgsArgsForCall)]
	fake.tFunctionLoadArgsArgsForCall = append(fake.tFunctionLoadArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.TFunctionLoadOptions
	}{arg1, arg2, arg3})
	stub := fake.TFunctionLoadArgsStub
	fakeReturns := fake.tFunctionLoadArgsReturns
	fake.recordInvocation("TFunctionLoadArgs", []interface{}{arg1, arg2, arg3})
	fake.tFunctionLoadArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TFunctionLoadArgsCallCount() int {
	fake.tFunctionLoadArgsMutex.RLock()
	defer fake.tFunctionLoadArgsMutex.RUnlock()
	return len(fake.tFunctionLoadArgsArgsForCall)
}

func (fake *FakeClient) TFunctionLoadArgsCalls(stub func(context.Context, string, *redisa.TFunctionLoadOptions) *redisa.StatusCmd) {
	fake.tFunctionLoadArgsMutex.Lock()
	defer fake.tFunctionLoadArgsMutex.Unlock()
	fake.TFunctionLoadArgsStub = stub
}

func (fake *FakeClient) TFunctionLoadArgsArgsForCall(i int) (context.Context, string, *redisa.TFunctionLoadOptions) {
	fake.tFunctionLoadArgsMutex.RLock()
	defer fake.tFunctionLoadArgsMutex.RUnlock()
	argsForCall := fake.tFunctionLoadArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TFunctionLoadArgsReturns(result1 *redisa.StatusCmd) {
	fake.tFunctionLoadArgsMutex.Lock()
	defer fake.tFunctionLoadArgsMutex.Unlock()
	fake.TFunctionLoadArgsStub = nil
	fake.tFunctionLoadArgsReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TFunctionLoadArgsReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tFunctionLoadArgsMutex.Lock()
	defer fake.tFunctionLoadArgsMutex.Unlock()
	fake.TFunctionLoadArgsStub = nil
	if fake.tFunctionLoadArgsReturnsOnCall == nil {
		fake.tFunctionLoadArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tFunctionLoadArgsReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TSAdd(arg1 context.Context, arg2 string, arg3 interface{}, arg4 float64) *redisa.IntCmd {
	fake.tSAddMutex.Lock()
	ret, specificReturn := fake.tSAddReturnsOnCall[len(fake.tSAddArgsForCall)]
	fake.tSAddArgsForCall = append(fake.tSAddArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 float64
	}{arg1, arg2, arg3, arg4})
	stub := fake.TSAddStub
	fakeReturns := fake.tSAddReturns
	fake.recordInvocation("TSAdd", []interface{}{arg1, arg2, arg3, arg4})
	fake.tSAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSAddCallCount() int {
	fake.tSAddMutex.RLock()
	defer fake.tSAddMutex.RUnlock()
	return len(fake.tSAddArgsForCall)
}

func (fake *FakeClient) TSAddCalls(stub func(context.Context, string, interface{}, float64) *redisa.IntCmd) {
	fake.tSAddMutex.Lock()
	defer fake.tSAddMutex.Unlock()
	fake.TSAddStub = stub
}

func (fake *FakeClient) TSAddArgsForCall(i int) (context.Context, string, interface{}, float64) {
	fake.tSAddMutex.RLock()
	defer fake.tSAddMutex.RUnlock()
	argsForCall := fake.tSAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) TSAddReturns(result1 *redisa.IntCmd) {
	fake.tSAddMutex.Lock()
	defer fake.tSAddMutex.Unlock()
	fake.TSAddStub = nil
	fake.tSAddReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSAddReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.tSAddMutex.Lock()
	defer fake.tSAddMutex.Unlock()
	fake.TSAddStub = nil
	if fake.tSAddReturnsOnCall == nil {
		fake.tSAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.tSAddReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSAddWithArgs(arg1 context.Context, arg2 string, arg3 interface{}, arg4 float64, arg5 *redisa.TSOptions) *redisa.IntCmd {
	fake.tSAddWithArgsMutex.Lock()
	ret, specificReturn := fake.tSAddWithArgsReturnsOnCall[len(fake.tSAddWithArgsArgsForCall)]
	fake.tSAddWithArgsArgsForCall = append(fake.tSAddWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 float64
		arg5 *redisa.TSOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.TSAddWithArgsStub
	fakeReturns := fake.tSAddWithArgsReturns
	fake.recordInvocation("TSAddWithArgs", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.tSAddWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSAddWithArgsCallCount() int {
	fake.tSAddWithArgsMutex.RLock()
	defer fake.tSAddWithArgsMutex.RUnlock()
	return len(fake.tSAddWithArgsArgsForCall)
}

func (fake *FakeClient) TSAddWithArgsCalls(stub func(context.Context, string, interface{}, float64, *redisa.TSOptions) *redisa.IntCmd) {
	fake.tSAddWithArgsMutex.Lock()
	defer fake.tSAddWithArgsMutex.Unlock()
	fake.TSAddWithArgsStub = stub
}

func (fake *FakeClient) TSAddWithArgsArgsForCall(i int) (context.Context, string, interface{}, float64, *redisa.TSOptions) {
	fake.tSAddWithArgsMutex.RLock()
	defer fake.tSAddWithArgsMutex.RUnlock()
	argsForCall := fake.tSAddWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) TSAddWithArgsReturns(result1 *redisa.IntCmd) {
	fake.tSAddWithArgsMutex.Lock()
	defer fake.tSAddWithArgsMutex.Unlock()
	fake.TSAddWithArgsStub = nil
	fake.tSAddWithArgsReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSAddWithArgsReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.tSAddWithArgsMutex.Lock()
	defer fake.tSAddWithArgsMutex.Unlock()
	fake.TSAddWithArgsStub = nil
	if fake.tSAddWithArgsReturnsOnCall == nil {
		fake.tSAddWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.tSAddWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSAlter(arg1 context.Context, arg2 string, arg3 *redisa.TSAlterOptions) *redisa.StatusCmd {
	fake.tSAlterMutex.Lock()
	ret, specificReturn := fake.tSAlterReturnsOnCall[len(fake.tSAlterArgsForCall)]
	fake.tSAlterArgsForCall = append(fake.tSAlterArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.TSAlterOptions
	}{arg1, arg2, arg3})
	stub := fake.TSAlterStub
	fakeReturns := fake.tSAlterReturns
	fake.recordInvocation("TSAlter", []interface{}{arg1, arg2, arg3})
	fake.tSAlterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSAlterCallCount() int {
	fake.tSAlterMutex.RLock()
	defer fake.tSAlterMutex.RUnlock()
	return len(fake.tSAlterArgsForCall)
}

func (fake *FakeClient) TSAlterCalls(stub func(context.Context, string, *redisa.TSAlterOptions) *redisa.StatusCmd) {
	fake.tSAlterMutex.Lock()
	defer fake.tSAlterMutex.Unlock()
	fake.TSAlterStub = stub
}

func (fake *FakeClient) TSAlterArgsForCall(i int) (context.Context, string, *redisa.TSAlterOptions) {
	fake.tSAlterMutex.RLock()
	defer fake.tSAlterMutex.RUnlock()
	argsForCall := fake.tSAlterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TSAlterReturns(result1 *redisa.StatusCmd) {
	fake.tSAlterMutex.Lock()
	defer fake.tSAlterMutex.Unlock()
	fake.TSAlterStub = nil
	fake.tSAlterReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TSAlterReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tSAlterMutex.Lock()
	defer fake.tSAlterMutex.Unlock()
	fake.TSAlterStub = nil
	if fake.tSAlterReturnsOnCall == nil {
		fake.tSAlterReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tSAlterReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TSCreate(arg1 context.Context, arg2 string) *redisa.StatusCmd {
	fake.tSCreateMutex.Lock()
	ret, specificReturn := fake.tSCreateReturnsOnCall[len(fake.tSCreateArgsForCall)]
	fake.tSCreateArgsForCall = append(fake.tSCreateArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TSCreateStub
	fakeReturns := fake.tSCreateReturns
	fake.recordInvocation("TSCreate", []interface{}{arg1, arg2})
	fake.tSCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSCreateCallCount() int {
	fake.tSCreateMutex.RLock()
	defer fake.tSCreateMutex.RUnlock()
	return len(fake.tSCreateArgsForCall)
}

func (fake *FakeClient) TSCreateCalls(stub func(context.Context, string) *redisa.StatusCmd) {
	fake.tSCreateMutex.Lock()
	defer fake.tSCreateMutex.Unlock()
	fake.TSCreateStub = stub
}

func (fake *FakeClient) TSCreateArgsForCall(i int) (context.Context, string) {
	fake.tSCreateMutex.RLock()
	defer fake.tSCreateMutex.RUnlock()
	argsForCall := fake.tSCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TSCreateReturns(result1 *redisa.StatusCmd) {
	fake.tSCreateMutex.Lock()
	defer fake.tSCreateMutex.Unlock()
	fake.TSCreateStub = nil
	fake.tSCreateReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TSCreateReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tSCreateMutex.Lock()
	defer fake.tSCreateMutex.Unlock()
	fake.TSCreateStub = nil
	if fake.tSCreateReturnsOnCall == nil {
		fake.tSCreateReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tSCreateReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TSCreateRule(arg1 context.Context, arg2 string, arg3 string, arg4 redisa.Aggregator, arg5 int) *redisa.StatusCmd {
	fake.tSCreateRuleMutex.Lock()
	ret, specificReturn := fake.tSCreateRuleReturnsOnCall[len(fake.tSCreateRuleArgsForCall)]
	fake.tSCreateRuleArgsForCall = append(fake.tSCreateRuleArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 redisa.Aggregator
		arg5 int
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.TSCreateRuleStub
	fakeReturns := fake.tSCreateRuleReturns
	fake.recordInvocation("TSCreateRule", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.tSCreateRuleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSCreateRuleCallCount() int {
	fake.tSCreateRuleMutex.RLock()
	defer fake.tSCreateRuleMutex.RUnlock()
	return len(fake.tSCreateRuleArgsForCall)
}

func (fake *FakeClient) TSCreateRuleCalls(stub func(context.Context, string, string, redisa.Aggregator, int) *redisa.StatusCmd) {
	fake.tSCreateRuleMutex.Lock()
	defer fake.tSCreateRuleMutex.Unlock()
	fake.TSCreateRuleStub = stub
}

func (fake *FakeClient) TSCreateRuleArgsForCall(i int) (context.Context, string, string, redisa.Aggregator, int) {
	fake.tSCreateRuleMutex.RLock()
	defer fake.tSCreateRuleMutex.RUnlock()
	argsForCall := fake.tSCreateRuleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) TSCreateRuleReturns(result1 *redisa.StatusCmd) {
	fake.tSCreateRuleMutex.Lock()
	defer fake.tSCreateRuleMutex.Unlock()
	fake.TSCreateRuleStub = nil
	fake.tSCreateRuleReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TSCreateRuleReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tSCreateRuleMutex.Lock()
	defer fake.tSCreateRuleMutex.Unlock()
	fake.TSCreateRuleStub = nil
	if fake.tSCreateRuleReturnsOnCall == nil {
		fake.tSCreateRuleReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tSCreateRuleReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TSCreateRuleWithArgs(arg1 context.Context, arg2 string, arg3 string, arg4 redisa.Aggregator, arg5 int, arg6 *redisa.TSCreateRuleOptions) *redisa.StatusCmd {
	fake.tSCreateRuleWithArgsMutex.Lock()
	ret, specificReturn := fake.tSCreateRuleWithArgsReturnsOnCall[len(fake.tSCreateRuleWithArgsArgsForCall)]
	fake.tSCreateRuleWithArgsArgsForCall = append(fake.tSCreateRuleWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 redisa.Aggregator
		arg5 int
		arg6 *redisa.TSCreateRuleOptions
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.TSCreateRuleWithArgsStub
	fakeReturns := fake.tSCreateRuleWithArgsReturns
	fake.recordInvocation("TSCreateRuleWithArgs", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.tSCreateRuleWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSCreateRuleWithArgsCallCount() int {
	fake.tSCreateRuleWithArgsMutex.RLock()
	defer fake.tSCreateRuleWithArgsMutex.RUnlock()
	return len(fake.tSCreateRuleWithArgsArgsForCall)
}

func (fake *FakeClient) TSCreateRuleWithArgsCalls(stub func(context.Context, string, string, redisa.Aggregator, int, *redisa.TSCreateRuleOptions) *redisa.StatusCmd) {
	fake.tSCreateRuleWithArgsMutex.Lock()
	defer fake.tSCreateRuleWithArgsMutex.Unlock()
	fake.TSCreateRuleWithArgsStub = stub
}

func (fake *FakeClient) TSCreateRuleWithArgsArgsForCall(i int) (context.Context, string, string, redisa.Aggregator, int, *redisa.TSCreateRuleOptions) {
	fake.tSCreateRuleWithArgsMutex.RLock()
	defer fake.tSCreateRuleWithArgsMutex.RUnlock()
	argsForCall := fake.tSCreateRuleWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeClient) TSCreateRuleWithArgsReturns(result1 *redisa.StatusCmd) {
	fake.tSCreateRuleWithArgsMutex.Lock()
	defer fake.tSCreateRuleWithArgsMutex.Unlock()
	fake.TSCreateRuleWithArgsStub = nil
	fake.tSCreateRuleWithArgsReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TSCreateRuleWithArgsReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tSCreateRuleWithArgsMutex.Lock()
	defer fake.tSCreateRuleWithArgsMutex.Unlock()
	fake.TSCreateRuleWithArgsStub = nil
	if fake.tSCreateRuleWithArgsReturnsOnCall == nil {
		fake.tSCreateRuleWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tSCreateRuleWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TSCreateWithArgs(arg1 context.Context, arg2 string, arg3 *redisa.TSOptions) *redisa.StatusCmd {
	fake.tSCreateWithArgsMutex.Lock()
	ret, specificReturn := fake.tSCreateWithArgsReturnsOnCall[len(fake.tSCreateWithArgsArgsForCall)]
	fake.tSCreateWithArgsArgsForCall = append(fake.tSCreateWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.TSOptions
	}{arg1, arg2, arg3})
	stub := fake.TSCreateWithArgsStub
	fakeReturns := fake.tSCreateWithArgsReturns
	fake.recordInvocation("TSCreateWithArgs", []interface{}{arg1, arg2, arg3})
	fake.tSCreateWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSCreateWithArgsCallCount() int {
	fake.tSCreateWithArgsMutex.RLock()
	defer fake.tSCreateWithArgsMutex.RUnlock()
	return len(fake.tSCreateWithArgsArgsForCall)
}

func (fake *FakeClient) TSCreateWithArgsCalls(stub func(context.Context, string, *redisa.TSOptions) *redisa.StatusCmd) {
	fake.tSCreateWithArgsMutex.Lock()
	defer fake.tSCreateWithArgsMutex.Unlock()
	fake.TSCreateWithArgsStub = stub
}

func (fake *FakeClient) TSCreateWithArgsArgsForCall(i int) (context.Context, string, *redisa.TSOptions) {
	fake.tSCreateWithArgsMutex.RLock()
	defer fake.tSCreateWithArgsMutex.RUnlock()
	argsForCall := fake.tSCreateWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TSCreateWithArgsReturns(result1 *redisa.StatusCmd) {
	fake.tSCreateWithArgsMutex.Lock()
	defer fake.tSCreateWithArgsMutex.Unlock()
	fake.TSCreateWithArgsStub = nil
	fake.tSCreateWithArgsReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TSCreateWithArgsReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tSCreateWithArgsMutex.Lock()
	defer fake.tSCreateWithArgsMutex.Unlock()
	fake.TSCreateWithArgsStub = nil
	if fake.tSCreateWithArgsReturnsOnCall == nil {
		fake.tSCreateWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tSCreateWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TSDecrBy(arg1 context.Context, arg2 string, arg3 float64) *redisa.IntCmd {
	fake.tSDecrByMutex.Lock()
	ret, specificReturn := fake.tSDecrByReturnsOnCall[len(fake.tSDecrByArgsForCall)]
	fake.tSDecrByArgsForCall = append(fake.tSDecrByArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 float64
	}{arg1, arg2, arg3})
	stub := fake.TSDecrByStub
	fakeReturns := fake.tSDecrByReturns
	fake.recordInvocation("TSDecrBy", []interface{}{arg1, arg2, arg3})
	fake.tSDecrByMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSDecrByCallCount() int {
	fake.tSDecrByMutex.RLock()
	defer fake.tSDecrByMutex.RUnlock()
	return len(fake.tSDecrByArgsForCall)
}

func (fake *FakeClient) TSDecrByCalls(stub func(context.Context, string, float64) *redisa.IntCmd) {
	fake.tSDecrByMutex.Lock()
	defer fake.tSDecrByMutex.Unlock()
	fake.TSDecrByStub = stub
}

func (fake *FakeClient) TSDecrByArgsForCall(i int) (context.Context, string, float64) {
	fake.tSDecrByMutex.RLock()
	defer fake.tSDecrByMutex.RUnlock()
	argsForCall := fake.tSDecrByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TSDecrByReturns(result1 *redisa.IntCmd) {
	fake.tSDecrByMutex.Lock()
	defer fake.tSDecrByMutex.Unlock()
	fake.TSDecrByStub = nil
	fake.tSDecrByReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSDecrByReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.tSDecrByMutex.Lock()
	defer fake.tSDecrByMutex.Unlock()
	fake.TSDecrByStub = nil
	if fake.tSDecrByReturnsOnCall == nil {
		fake.tSDecrByReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.tSDecrByReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSDecrByWithArgs(arg1 context.Context, arg2 string, arg3 float64, arg4 *redisa.TSIncrDecrOptions) *redisa.IntCmd {
	fake.tSDecrByWithArgsMutex.Lock()
	ret, specificReturn := fake.tSDecrByWithArgsReturnsOnCall[len(fake.tSDecrByWithArgsArgsForCall)]
	fake.tSDecrByWithArgsArgsForCall = append(fake.tSDecrByWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 *redisa.TSIncrDecrOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.TSDecrByWithArgsStub
	fakeReturns := fake.tSDecrByWithArgsReturns
	fake.recordInvocation("TSDecrByWithArgs", []interface{}{arg1, arg2, arg3, arg4})
	fake.tSDecrByWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSDecrByWithArgsCallCount() int {
	fake.tSDecrByWithArgsMutex.RLock()
	defer fake.tSDecrByWithArgsMutex.RUnlock()
	return len(fake.tSDecrByWithArgsArgsForCall)
}

func (fake *FakeClient) TSDecrByWithArgsCalls(stub func(context.Context, string, float64, *redisa.TSIncrDecrOptions) *redisa.IntCmd) {
	fake.tSDecrByWithArgsMutex.Lock()
	defer fake.tSDecrByWithArgsMutex.Unlock()
	fake.TSDecrByWithArgsStub = stub
}

func (fake *FakeClient) TSDecrByWithArgsArgsForCall(i int) (context.Context, string, float64, *redisa.TSIncrDecrOptions) {
	fake.tSDecrByWithArgsMutex.RLock()
	defer fake.tSDecrByWithArgsMutex.RUnlock()
	argsForCall := fake.tSDecrByWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) TSDecrByWithArgsReturns(result1 *redisa.IntCmd) {
	fake.tSDecrByWithArgsMutex.Lock()
	defer fake.tSDecrByWithArgsMutex.Unlock()
	fake.TSDecrByWithArgsStub = nil
	fake.tSDecrByWithArgsReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSDecrByWithArgsReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.tSDecrByWithArgsMutex.Lock()
	defer fake.tSDecrByWithArgsMutex.Unlock()
	fake.TSDecrByWithArgsStub = nil
	if fake.tSDecrByWithArgsReturnsOnCall == nil {
		fake.tSDecrByWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.tSDecrByWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSDel(arg1 context.Context, arg2 string, arg3 int, arg4 int) *redisa.IntCmd {
	fake.tSDelMutex.Lock()
	ret, specificReturn := fake.tSDelReturnsOnCall[len(fake.tSDelArgsForCall)]
	fake.tSDelArgsForCall = append(fake.tSDelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.TSDelStub
	fakeReturns := fake.tSDelReturns
	fake.recordInvocation("TSDel", []interface{}{arg1, arg2, arg3, arg4})
	fake.tSDelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSDelCallCount() int {
	fake.tSDelMutex.RLock()
	defer fake.tSDelMutex.RUnlock()
	return len(fake.tSDelArgsForCall)
}

func (fake *FakeClient) TSDelCalls(stub func(context.Context, string, int, int) *redisa.IntCmd) {
	fake.tSDelMutex.Lock()
	defer fake.tSDelMutex.Unlock()
	fake.TSDelStub = stub
}

func (fake *FakeClient) TSDelArgsForCall(i int) (context.Context, string, int, int) {
	fake.tSDelMutex.RLock()
	defer fake.tSDelMutex.RUnlock()
	argsForCall := fake.tSDelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) TSDelReturns(result1 *redisa.IntCmd) {
	fake.tSDelMutex.Lock()
	defer fake.tSDelMutex.Unlock()
	fake.TSDelStub = nil
	fake.tSDelReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSDelReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.tSDelMutex.Lock()
	defer fake.tSDelMutex.Unlock()
	fake.TSDelStub = nil
	if fake.tSDelReturnsOnCall == nil {
		fake.tSDelReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.tSDelReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSDeleteRule(arg1 context.Context, arg2 string, arg3 string) *redisa.StatusCmd {
	fake.tSDeleteRuleMutex.Lock()
	ret, specificReturn := fake.tSDeleteRuleReturnsOnCall[len(fake.tSDeleteRuleArgsForCall)]
	fake.tSDeleteRuleArgsForCall = append(fake.tSDeleteRuleArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.TSDeleteRuleStub
	fakeReturns := fake.tSDeleteRuleReturns
	fake.recordInvocation("TSDeleteRule", []interface{}{arg1, arg2, arg3})
	fake.tSDeleteRuleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSDeleteRuleCallCount() int {
	fake.tSDeleteRuleMutex.RLock()
	defer fake.tSDeleteRuleMutex.RUnlock()
	return len(fake.tSDeleteRuleArgsForCall)
}

func (fake *FakeClient) TSDeleteRuleCalls(stub func(context.Context, string, string) *redisa.StatusCmd) {
	fake.tSDeleteRuleMutex.Lock()
	defer fake.tSDeleteRuleMutex.Unlock()
	fake.TSDeleteRuleStub = stub
}

func (fake *FakeClient) TSDeleteRuleArgsForCall(i int) (context.Context, string, string) {
	fake.tSDeleteRuleMutex.RLock()
	defer fake.tSDeleteRuleMutex.RUnlock()
	argsForCall := fake.tSDeleteRuleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TSDeleteRuleReturns(result1 *redisa.StatusCmd) {
	fake.tSDeleteRuleMutex.Lock()
	defer fake.tSDeleteRuleMutex.Unlock()
	fake.TSDeleteRuleStub = nil
	fake.tSDeleteRuleReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TSDeleteRuleReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.tSDeleteRuleMutex.Lock()
	defer fake.tSDeleteRuleMutex.Unlock()
	fake.TSDeleteRuleStub = nil
	if fake.tSDeleteRuleReturnsOnCall == nil {
		fake.tSDeleteRuleReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.tSDeleteRuleReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TSGet(arg1 context.Context, arg2 string) *redisa.TSTimestampValueCmd {
	fake.tSGetMutex.Lock()
	ret, specificReturn := fake.tSGetReturnsOnCall[len(fake.tSGetArgsForCall)]
	fake.tSGetArgsForCall = append(fake.tSGetArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TSGetStub
	fakeReturns := fake.tSGetReturns
	fake.recordInvocation("TSGet", []interface{}{arg1, arg2})
	fake.tSGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSGetCallCount() int {
	fake.tSGetMutex.RLock()
	defer fake.tSGetMutex.RUnlock()
	return len(fake.tSGetArgsForCall)
}

func (fake *FakeClient) TSGetCalls(stub func(context.Context, string) *redisa.TSTimestampValueCmd) {
	fake.tSGetMutex.Lock()
	defer fake.tSGetMutex.Unlock()
	fake.TSGetStub = stub
}

func (fake *FakeClient) TSGetArgsForCall(i int) (context.Context, string) {
	fake.tSGetMutex.RLock()
	defer fake.tSGetMutex.RUnlock()
	argsForCall := fake.tSGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TSGetReturns(result1 *redisa.TSTimestampValueCmd) {
	fake.tSGetMutex.Lock()
	defer fake.tSGetMutex.Unlock()
	fake.TSGetStub = nil
	fake.tSGetReturns = struct {
		result1 *redisa.TSTimestampValueCmd
	}{result1}
}

func (fake *FakeClient) TSGetReturnsOnCall(i int, result1 *redisa.TSTimestampValueCmd) {
	fake.tSGetMutex.Lock()
	defer fake.tSGetMutex.Unlock()
	fake.TSGetStub = nil
	if fake.tSGetReturnsOnCall == nil {
		fake.tSGetReturnsOnCall = make(map[int]struct {
			result1 *redisa.TSTimestampValueCmd
		})
	}
	fake.tSGetReturnsOnCall[i] = struct {
		result1 *redisa.TSTimestampValueCmd
	}{result1}
}

func (fake *FakeClient) TSGetWithArgs(arg1 context.Context, arg2 string, arg3 *redisa.TSGetOptions) *redisa.TSTimestampValueCmd {
	fake.tSGetWithArgsMutex.Lock()
	ret, specificReturn := fake.tSGetWithArgsReturnsOnCall[len(fake.tSGetWithArgsArgsForCall)]
	fake.tSGetWithArgsArgsForCall = append(fake.tSGetWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.TSGetOptions
	}{arg1, arg2, arg3})
	stub := fake.TSGetWithArgsStub
	fakeReturns := fake.tSGetWithArgsReturns
	fake.recordInvocation("TSGetWithArgs", []interface{}{arg1, arg2, arg3})
	fake.tSGetWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSGetWithArgsCallCount() int {
	fake.tSGetWithArgsMutex.RLock()
	defer fake.tSGetWithArgsMutex.RUnlock()
	return len(fake.tSGetWithArgsArgsForCall)
}

func (fake *FakeClient) TSGetWithArgsCalls(stub func(context.Context, string, *redisa.TSGetOptions) *redisa.TSTimestampValueCmd) {
	fake.tSGetWithArgsMutex.Lock()
	defer fake.tSGetWithArgsMutex.Unlock()
	fake.TSGetWithArgsStub = stub
}

func (fake *FakeClient) TSGetWithArgsArgsForCall(i int) (context.Context, string, *redisa.TSGetOptions) {
	fake.tSGetWithArgsMutex.RLock()
	defer fake.tSGetWithArgsMutex.RUnlock()
	argsForCall := fake.tSGetWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TSGetWithArgsReturns(result1 *redisa.TSTimestampValueCmd) {
	fake.tSGetWithArgsMutex.Lock()
	defer fake.tSGetWithArgsMutex.Unlock()
	fake.TSGetWithArgsStub = nil
	fake.tSGetWithArgsReturns = struct {
		result1 *redisa.TSTimestampValueCmd
	}{result1}
}

func (fake *FakeClient) TSGetWithArgsReturnsOnCall(i int, result1 *redisa.TSTimestampValueCmd) {
	fake.tSGetWithArgsMutex.Lock()
	defer fake.tSGetWithArgsMutex.Unlock()
	fake.TSGetWithArgsStub = nil
	if fake.tSGetWithArgsReturnsOnCall == nil {
		fake.tSGetWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.TSTimestampValueCmd
		})
	}
	fake.tSGetWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.TSTimestampValueCmd
	}{result1}
}

func (fake *FakeClient) TSIncrBy(arg1 context.Context, arg2 string, arg3 float64) *redisa.IntCmd {
	fake.tSIncrByMutex.Lock()
	ret, specificReturn := fake.tSIncrByReturnsOnCall[len(fake.tSIncrByArgsForCall)]
	fake.tSIncrByArgsForCall = append(fake.tSIncrByArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 float64
	}{arg1, arg2, arg3})
	stub := fake.TSIncrByStub
	fakeReturns := fake.tSIncrByReturns
	fake.recordInvocation("TSIncrBy", []interface{}{arg1, arg2, arg3})
	fake.tSIncrByMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSIncrByCallCount() int {
	fake.tSIncrByMutex.RLock()
	defer fake.tSIncrByMutex.RUnlock()
	return len(fake.tSIncrByArgsForCall)
}

func (fake *FakeClient) TSIncrByCalls(stub func(context.Context, string, float64) *redisa.IntCmd) {
	fake.tSIncrByMutex.Lock()
	defer fake.tSIncrByMutex.Unlock()
	fake.TSIncrByStub = stub
}

func (fake *FakeClient) TSIncrByArgsForCall(i int) (context.Context, string, float64) {
	fake.tSIncrByMutex.RLock()
	defer fake.tSIncrByMutex.RUnlock()
	argsForCall := fake.tSIncrByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TSIncrByReturns(result1 *redisa.IntCmd) {
	fake.tSIncrByMutex.Lock()
	defer fake.tSIncrByMutex.Unlock()
	fake.TSIncrByStub = nil
	fake.tSIncrByReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSIncrByReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.tSIncrByMutex.Lock()
	defer fake.tSIncrByMutex.Unlock()
	fake.TSIncrByStub = nil
	if fake.tSIncrByReturnsOnCall == nil {
		fake.tSIncrByReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.tSIncrByReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSIncrByWithArgs(arg1 context.Context, arg2 string, arg3 float64, arg4 *redisa.TSIncrDecrOptions) *redisa.IntCmd {
	fake.tSIncrByWithArgsMutex.Lock()
	ret, specificReturn := fake.tSIncrByWithArgsReturnsOnCall[len(fake.tSIncrByWithArgsArgsForCall)]
	fake.tSIncrByWithArgsArgsForCall = append(fake.tSIncrByWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 *redisa.TSIncrDecrOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.TSIncrByWithArgsStub
	fakeReturns := fake.tSIncrByWithArgsReturns
	fake.recordInvocation("TSIncrByWithArgs", []interface{}{arg1, arg2, arg3, arg4})
	fake.tSIncrByWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSIncrByWithArgsCallCount() int {
	fake.tSIncrByWithArgsMutex.RLock()
	defer fake.tSIncrByWithArgsMutex.RUnlock()
	return len(fake.tSIncrByWithArgsArgsForCall)
}

func (fake *FakeClient) TSIncrByWithArgsCalls(stub func(context.Context, string, float64, *redisa.TSIncrDecrOptions) *redisa.IntCmd) {
	fake.tSIncrByWithArgsMutex.Lock()
	defer fake.tSIncrByWithArgsMutex.Unlock()
	fake.TSIncrByWithArgsStub = stub
}

func (fake *FakeClient) TSIncrByWithArgsArgsForCall(i int) (context.Context, string, float64, *redisa.TSIncrDecrOptions) {
	fake.tSIncrByWithArgsMutex.RLock()
	defer fake.tSIncrByWithArgsMutex.RUnlock()
	argsForCall := fake.tSIncrByWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) TSIncrByWithArgsReturns(result1 *redisa.IntCmd) {
	fake.tSIncrByWithArgsMutex.Lock()
	defer fake.tSIncrByWithArgsMutex.Unlock()
	fake.TSIncrByWithArgsStub = nil
	fake.tSIncrByWithArgsReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSIncrByWithArgsReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.tSIncrByWithArgsMutex.Lock()
	defer fake.tSIncrByWithArgsMutex.Unlock()
	fake.TSIncrByWithArgsStub = nil
	if fake.tSIncrByWithArgsReturnsOnCall == nil {
		fake.tSIncrByWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.tSIncrByWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TSInfo(arg1 context.Context, arg2 string) *redisa.MapStringInterfaceCmd {
	fake.tSInfoMutex.Lock()
	ret, specificReturn := fake.tSInfoReturnsOnCall[len(fake.tSInfoArgsForCall)]
	fake.tSInfoArgsForCall = append(fake.tSInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TSInfoStub
	fakeReturns := fake.tSInfoReturns
	fake.recordInvocation("TSInfo", []interface{}{arg1, arg2})
	fake.tSInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSInfoCallCount() int {
	fake.tSInfoMutex.RLock()
	defer fake.tSInfoMutex.RUnlock()
	return len(fake.tSInfoArgsForCall)
}

func (fake *FakeClient) TSInfoCalls(stub func(context.Context, string) *redisa.MapStringInterfaceCmd) {
	fake.tSInfoMutex.Lock()
	defer fake.tSInfoMutex.Unlock()
	fake.TSInfoStub = stub
}

func (fake *FakeClient) TSInfoArgsForCall(i int) (context.Context, string) {
	fake.tSInfoMutex.RLock()
	defer fake.tSInfoMutex.RUnlock()
	argsForCall := fake.tSInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TSInfoReturns(result1 *redisa.MapStringInterfaceCmd) {
	fake.tSInfoMutex.Lock()
	defer fake.tSInfoMutex.Unlock()
	fake.TSInfoStub = nil
	fake.tSInfoReturns = struct {
		result1 *redisa.MapStringInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSInfoReturnsOnCall(i int, result1 *redisa.MapStringInterfaceCmd) {
	fake.tSInfoMutex.Lock()
	defer fake.tSInfoMutex.Unlock()
	fake.TSInfoStub = nil
	if fake.tSInfoReturnsOnCall == nil {
		fake.tSInfoReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringInterfaceCmd
		})
	}
	fake.tSInfoReturnsOnCall[i] = struct {
		result1 *redisa.MapStringInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSInfoWithArgs(arg1 context.Context, arg2 string, arg3 *redisa.TSInfoOptions) *redisa.MapStringInterfaceCmd {
	fake.tSInfoWithArgsMutex.Lock()
	ret, specificReturn := fake.tSInfoWithArgsReturnsOnCall[len(fake.tSInfoWithArgsArgsForCall)]
	fake.tSInfoWithArgsArgsForCall = append(fake.tSInfoWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.TSInfoOptions
	}{arg1, arg2, arg3})
	stub := fake.TSInfoWithArgsStub
	fakeReturns := fake.tSInfoWithArgsReturns
	fake.recordInvocation("TSInfoWithArgs", []interface{}{arg1, arg2, arg3})
	fake.tSInfoWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSInfoWithArgsCallCount() int {
	fake.tSInfoWithArgsMutex.RLock()
	defer fake.tSInfoWithArgsMutex.RUnlock()
	return len(fake.tSInfoWithArgsArgsForCall)
}

func (fake *FakeClient) TSInfoWithArgsCalls(stub func(context.Context, string, *redisa.TSInfoOptions) *redisa.MapStringInterfaceCmd) {
	fake.tSInfoWithArgsMutex.Lock()
	defer fake.tSInfoWithArgsMutex.Unlock()
	fake.TSInfoWithArgsStub = stub
}

func (fake *FakeClient) TSInfoWithArgsArgsForCall(i int) (context.Context, string, *redisa.TSInfoOptions) {
	fake.tSInfoWithArgsMutex.RLock()
	defer fake.tSInfoWithArgsMutex.RUnlock()
	argsForCall := fake.tSInfoWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TSInfoWithArgsReturns(result1 *redisa.MapStringInterfaceCmd) {
	fake.tSInfoWithArgsMutex.Lock()
	defer fake.tSInfoWithArgsMutex.Unlock()
	fake.TSInfoWithArgsStub = nil
	fake.tSInfoWithArgsReturns = struct {
		result1 *redisa.MapStringInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSInfoWithArgsReturnsOnCall(i int, result1 *redisa.MapStringInterfaceCmd) {
	fake.tSInfoWithArgsMutex.Lock()
	defer fake.tSInfoWithArgsMutex.Unlock()
	fake.TSInfoWithArgsStub = nil
	if fake.tSInfoWithArgsReturnsOnCall == nil {
		fake.tSInfoWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringInterfaceCmd
		})
	}
	fake.tSInfoWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.MapStringInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSMAdd(arg1 context.Context, arg2 [][]interface{}) *redisa.IntSliceCmd {
	var arg2Copy [][]interface{}
	if arg2 != nil {
		arg2Copy = make([][]interface{}, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.tSMAddMutex.Lock()
	ret, specificReturn := fake.tSMAddReturnsOnCall[len(fake.tSMAddArgsForCall)]
	fake.tSMAddArgsForCall = append(fake.tSMAddArgsForCall, struct {
		arg1 context.Context
		arg2 [][]interface{}
	}{arg1, arg2Copy})
	stub := fake.TSMAddStub
	fakeReturns := fake.tSMAddReturns
	fake.recordInvocation("TSMAdd", []interface{}{arg1, arg2Copy})
	fake.tSMAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSMAddCallCount() int {
	fake.tSMAddMutex.RLock()
	defer fake.tSMAddMutex.RUnlock()
	return len(fake.tSMAddArgsForCall)
}

func (fake *FakeClient) TSMAddCalls(stub func(context.Context, [][]interface{}) *redisa.IntSliceCmd) {
	fake.tSMAddMutex.Lock()
	defer fake.tSMAddMutex.Unlock()
	fake.TSMAddStub = stub
}

func (fake *FakeClient) TSMAddArgsForCall(i int) (context.Context, [][]interface{}) {
	fake.tSMAddMutex.RLock()
	defer fake.tSMAddMutex.RUnlock()
	argsForCall := fake.tSMAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TSMAddReturns(result1 *redisa.IntSliceCmd) {
	fake.tSMAddMutex.Lock()
	defer fake.tSMAddMutex.Unlock()
	fake.TSMAddStub = nil
	fake.tSMAddReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) TSMAddReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.tSMAddMutex.Lock()
	defer fake.tSMAddMutex.Unlock()
	fake.TSMAddStub = nil
	if fake.tSMAddReturnsOnCall == nil {
		fake.tSMAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.tSMAddReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) TSMGet(arg1 context.Context, arg2 []string) *redisa.MapStringSliceInterfaceCmd {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.tSMGetMutex.Lock()
	ret, specificReturn := fake.tSMGetReturnsOnCall[len(fake.tSMGetArgsForCall)]
	fake.tSMGetArgsForCall = append(fake.tSMGetArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.TSMGetStub
	fakeReturns := fake.tSMGetReturns
	fake.recordInvocation("TSMGet", []interface{}{arg1, arg2Copy})
	fake.tSMGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSMGetCallCount() int {
	fake.tSMGetMutex.RLock()
	defer fake.tSMGetMutex.RUnlock()
	return len(fake.tSMGetArgsForCall)
}

func (fake *FakeClient) TSMGetCalls(stub func(context.Context, []string) *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMGetMutex.Lock()
	defer fake.tSMGetMutex.Unlock()
	fake.TSMGetStub = stub
}

func (fake *FakeClient) TSMGetArgsForCall(i int) (context.Context, []string) {
	fake.tSMGetMutex.RLock()
	defer fake.tSMGetMutex.RUnlock()
	argsForCall := fake.tSMGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TSMGetReturns(result1 *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMGetMutex.Lock()
	defer fake.tSMGetMutex.Unlock()
	fake.TSMGetStub = nil
	fake.tSMGetReturns = struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSMGetReturnsOnCall(i int, result1 *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMGetMutex.Lock()
	defer fake.tSMGetMutex.Unlock()
	fake.TSMGetStub = nil
	if fake.tSMGetReturnsOnCall == nil {
		fake.tSMGetReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringSliceInterfaceCmd
		})
	}
	fake.tSMGetReturnsOnCall[i] = struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSMGetWithArgs(arg1 context.Context, arg2 []string, arg3 *redisa.TSMGetOptions) *redisa.MapStringSliceInterfaceCmd {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.tSMGetWithArgsMutex.Lock()
	ret, specificReturn := fake.tSMGetWithArgsReturnsOnCall[len(fake.tSMGetWithArgsArgsForCall)]
	fake.tSMGetWithArgsArgsForCall = append(fake.tSMGetWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 []string
		arg3 *redisa.TSMGetOptions
	}{arg1, arg2Copy, arg3})
	stub := fake.TSMGetWithArgsStub
	fakeReturns := fake.tSMGetWithArgsReturns
	fake.recordInvocation("TSMGetWithArgs", []interface{}{arg1, arg2Copy, arg3})
	fake.tSMGetWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSMGetWithArgsCallCount() int {
	fake.tSMGetWithArgsMutex.RLock()
	defer fake.tSMGetWithArgsMutex.RUnlock()
	return len(fake.tSMGetWithArgsArgsForCall)
}

func (fake *FakeClient) TSMGetWithArgsCalls(stub func(context.Context, []string, *redisa.TSMGetOptions) *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMGetWithArgsMutex.Lock()
	defer fake.tSMGetWithArgsMutex.Unlock()
	fake.TSMGetWithArgsStub = stub
}

func (fake *FakeClient) TSMGetWithArgsArgsForCall(i int) (context.Context, []string, *redisa.TSMGetOptions) {
	fake.tSMGetWithArgsMutex.RLock()
	defer fake.tSMGetWithArgsMutex.RUnlock()
	argsForCall := fake.tSMGetWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TSMGetWithArgsReturns(result1 *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMGetWithArgsMutex.Lock()
	defer fake.tSMGetWithArgsMutex.Unlock()
	fake.TSMGetWithArgsStub = nil
	fake.tSMGetWithArgsReturns = struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSMGetWithArgsReturnsOnCall(i int, result1 *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMGetWithArgsMutex.Lock()
	defer fake.tSMGetWithArgsMutex.Unlock()
	fake.TSMGetWithArgsStub = nil
	if fake.tSMGetWithArgsReturnsOnCall == nil {
		fake.tSMGetWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringSliceInterfaceCmd
		})
	}
	fake.tSMGetWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSMRange(arg1 context.Context, arg2 int, arg3 int, arg4 []string) *redisa.MapStringSliceInterfaceCmd {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.tSMRangeMutex.Lock()
	ret, specificReturn := fake.tSMRangeReturnsOnCall[len(fake.tSMRangeArgsForCall)]
	fake.tSMRangeArgsForCall = append(fake.tSMRangeArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 int
		arg4 []string
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.TSMRangeStub
	fakeReturns := fake.tSMRangeReturns
	fake.recordInvocation("TSMRange", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.tSMRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSMRangeCallCount() int {
	fake.tSMRangeMutex.RLock()
	defer fake.tSMRangeMutex.RUnlock()
	return len(fake.tSMRangeArgsForCall)
}

func (fake *FakeClient) TSMRangeCalls(stub func(context.Context, int, int, []string) *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMRangeMutex.Lock()
	defer fake.tSMRangeMutex.Unlock()
	fake.TSMRangeStub = stub
}

func (fake *FakeClient) TSMRangeArgsForCall(i int) (context.Context, int, int, []string) {
	fake.tSMRangeMutex.RLock()
	defer fake.tSMRangeMutex.RUnlock()
	argsForCall := fake.tSMRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) TSMRangeReturns(result1 *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMRangeMutex.Lock()
	defer fake.tSMRangeMutex.Unlock()
	fake.TSMRangeStub = nil
	fake.tSMRangeReturns = struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSMRangeReturnsOnCall(i int, result1 *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMRangeMutex.Lock()
	defer fake.tSMRangeMutex.Unlock()
	fake.TSMRangeStub = nil
	if fake.tSMRangeReturnsOnCall == nil {
		fake.tSMRangeReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringSliceInterfaceCmd
		})
	}
	fake.tSMRangeReturnsOnCall[i] = struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSMRangeWithArgs(arg1 context.Context, arg2 int, arg3 int, arg4 []string, arg5 *redisa.TSMRangeOptions) *redisa.MapStringSliceInterfaceCmd {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.tSMRangeWithArgsMutex.Lock()
	ret, specificReturn := fake.tSMRangeWithArgsReturnsOnCall[len(fake.tSMRangeWithArgsArgsForCall)]
	fake.tSMRangeWithArgsArgsForCall = append(fake.tSMRangeWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 int
		arg4 []string
		arg5 *redisa.TSMRangeOptions
	}{arg1, arg2, arg3, arg4Copy, arg5})
	stub := fake.TSMRangeWithArgsStub
	fakeReturns := fake.tSMRangeWithArgsReturns
	fake.recordInvocation("TSMRangeWithArgs", []interface{}{arg1, arg2, arg3, arg4Copy, arg5})
	fake.tSMRangeWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSMRangeWithArgsCallCount() int {
	fake.tSMRangeWithArgsMutex.RLock()
	defer fake.tSMRangeWithArgsMutex.RUnlock()
	return len(fake.tSMRangeWithArgsArgsForCall)
}

func (fake *FakeClient) TSMRangeWithArgsCalls(stub func(context.Context, int, int, []string, *redisa.TSMRangeOptions) *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMRangeWithArgsMutex.Lock()
	defer fake.tSMRangeWithArgsMutex.Unlock()
	fake.TSMRangeWithArgsStub = stub
}

func (fake *FakeClient) TSMRangeWithArgsArgsForCall(i int) (context.Context, int, int, []string, *redisa.TSMRangeOptions) {
	fake.tSMRangeWithArgsMutex.RLock()
	defer fake.tSMRangeWithArgsMutex.RUnlock()
	argsForCall := fake.tSMRangeWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) TSMRangeWithArgsReturns(result1 *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMRangeWithArgsMutex.Lock()
	defer fake.tSMRangeWithArgsMutex.Unlock()
	fake.TSMRangeWithArgsStub = nil
	fake.tSMRangeWithArgsReturns = struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSMRangeWithArgsReturnsOnCall(i int, result1 *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMRangeWithArgsMutex.Lock()
	defer fake.tSMRangeWithArgsMutex.Unlock()
	fake.TSMRangeWithArgsStub = nil
	if fake.tSMRangeWithArgsReturnsOnCall == nil {
		fake.tSMRangeWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringSliceInterfaceCmd
		})
	}
	fake.tSMRangeWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSMRevRange(arg1 context.Context, arg2 int, arg3 int, arg4 []string) *redisa.MapStringSliceInterfaceCmd {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.tSMRevRangeMutex.Lock()
	ret, specificReturn := fake.tSMRevRangeReturnsOnCall[len(fake.tSMRevRangeArgsForCall)]
	fake.tSMRevRangeArgsForCall = append(fake.tSMRevRangeArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 int
		arg4 []string
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.TSMRevRangeStub
	fakeReturns := fake.tSMRevRangeReturns
	fake.recordInvocation("TSMRevRange", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.tSMRevRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSMRevRangeCallCount() int {
	fake.tSMRevRangeMutex.RLock()
	defer fake.tSMRevRangeMutex.RUnlock()
	return len(fake.tSMRevRangeArgsForCall)
}

func (fake *FakeClient) TSMRevRangeCalls(stub func(context.Context, int, int, []string) *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMRevRangeMutex.Lock()
	defer fake.tSMRevRangeMutex.Unlock()
	fake.TSMRevRangeStub = stub
}

func (fake *FakeClient) TSMRevRangeArgsForCall(i int) (context.Context, int, int, []string) {
	fake.tSMRevRangeMutex.RLock()
	defer fake.tSMRevRangeMutex.RUnlock()
	argsForCall := fake.tSMRevRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) TSMRevRangeReturns(result1 *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMRevRangeMutex.Lock()
	defer fake.tSMRevRangeMutex.Unlock()
	fake.TSMRevRangeStub = nil
	fake.tSMRevRangeReturns = struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSMRevRangeReturnsOnCall(i int, result1 *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMRevRangeMutex.Lock()
	defer fake.tSMRevRangeMutex.Unlock()
	fake.TSMRevRangeStub = nil
	if fake.tSMRevRangeReturnsOnCall == nil {
		fake.tSMRevRangeReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringSliceInterfaceCmd
		})
	}
	fake.tSMRevRangeReturnsOnCall[i] = struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSMRevRangeWithArgs(arg1 context.Context, arg2 int, arg3 int, arg4 []string, arg5 *redisa.TSMRevRangeOptions) *redisa.MapStringSliceInterfaceCmd {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.tSMRevRangeWithArgsMutex.Lock()
	ret, specificReturn := fake.tSMRevRangeWithArgsReturnsOnCall[len(fake.tSMRevRangeWithArgsArgsForCall)]
	fake.tSMRevRangeWithArgsArgsForCall = append(fake.tSMRevRangeWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 int
		arg4 []string
		arg5 *redisa.TSMRevRangeOptions
	}{arg1, arg2, arg3, arg4Copy, arg5})
	stub := fake.TSMRevRangeWithArgsStub
	fakeReturns := fake.tSMRevRangeWithArgsReturns
	fake.recordInvocation("TSMRevRangeWithArgs", []interface{}{arg1, arg2, arg3, arg4Copy, arg5})
	fake.tSMRevRangeWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSMRevRangeWithArgsCallCount() int {
	fake.tSMRevRangeWithArgsMutex.RLock()
	defer fake.tSMRevRangeWithArgsMutex.RUnlock()
	return len(fake.tSMRevRangeWithArgsArgsForCall)
}

func (fake *FakeClient) TSMRevRangeWithArgsCalls(stub func(context.Context, int, int, []string, *redisa.TSMRevRangeOptions) *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMRevRangeWithArgsMutex.Lock()
	defer fake.tSMRevRangeWithArgsMutex.Unlock()
	fake.TSMRevRangeWithArgsStub = stub
}

func (fake *FakeClient) TSMRevRangeWithArgsArgsForCall(i int) (context.Context, int, int, []string, *redisa.TSMRevRangeOptions) {
	fake.tSMRevRangeWithArgsMutex.RLock()
	defer fake.tSMRevRangeWithArgsMutex.RUnlock()
	argsForCall := fake.tSMRevRangeWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) TSMRevRangeWithArgsReturns(result1 *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMRevRangeWithArgsMutex.Lock()
	defer fake.tSMRevRangeWithArgsMutex.Unlock()
	fake.TSMRevRangeWithArgsStub = nil
	fake.tSMRevRangeWithArgsReturns = struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSMRevRangeWithArgsReturnsOnCall(i int, result1 *redisa.MapStringSliceInterfaceCmd) {
	fake.tSMRevRangeWithArgsMutex.Lock()
	defer fake.tSMRevRangeWithArgsMutex.Unlock()
	fake.TSMRevRangeWithArgsStub = nil
	if fake.tSMRevRangeWithArgsReturnsOnCall == nil {
		fake.tSMRevRangeWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringSliceInterfaceCmd
		})
	}
	fake.tSMRevRangeWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.MapStringSliceInterfaceCmd
	}{result1}
}

func (fake *FakeClient) TSQueryIndex(arg1 context.Context, arg2 []string) *redisa.StringSliceCmd {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.tSQueryIndexMutex.Lock()
	ret, specificReturn := fake.tSQueryIndexReturnsOnCall[len(fake.tSQueryIndexArgsForCall)]
	fake.tSQueryIndexArgsForCall = append(fake.tSQueryIndexArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.TSQueryIndexStub
	fakeReturns := fake.tSQueryIndexReturns
	fake.recordInvocation("TSQueryIndex", []interface{}{arg1, arg2Copy})
	fake.tSQueryIndexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSQueryIndexCallCount() int {
	fake.tSQueryIndexMutex.RLock()
	defer fake.tSQueryIndexMutex.RUnlock()
	return len(fake.tSQueryIndexArgsForCall)
}

func (fake *FakeClient) TSQueryIndexCalls(stub func(context.Context, []string) *redisa.StringSliceCmd) {
	fake.tSQueryIndexMutex.Lock()
	defer fake.tSQueryIndexMutex.Unlock()
	fake.TSQueryIndexStub = stub
}

func (fake *FakeClient) TSQueryIndexArgsForCall(i int) (context.Context, []string) {
	fake.tSQueryIndexMutex.RLock()
	defer fake.tSQueryIndexMutex.RUnlock()
	argsForCall := fake.tSQueryIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TSQueryIndexReturns(result1 *redisa.StringSliceCmd) {
	fake.tSQueryIndexMutex.Lock()
	defer fake.tSQueryIndexMutex.Unlock()
	fake.TSQueryIndexStub = nil
	fake.tSQueryIndexReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) TSQueryIndexReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.tSQueryIndexMutex.Lock()
	defer fake.tSQueryIndexMutex.Unlock()
	fake.TSQueryIndexStub = nil
	if fake.tSQueryIndexReturnsOnCall == nil {
		fake.tSQueryIndexReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.tSQueryIndexReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) TSRange(arg1 context.Context, arg2 string, arg3 int, arg4 int) *redisa.TSTimestampValueSliceCmd {
	fake.tSRangeMutex.Lock()
	ret, specificReturn := fake.tSRangeReturnsOnCall[len(fake.tSRangeArgsForCall)]
	fake.tSRangeArgsForCall = append(fake.tSRangeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.TSRangeStub
	fakeReturns := fake.tSRangeReturns
	fake.recordInvocation("TSRange", []interface{}{arg1, arg2, arg3, arg4})
	fake.tSRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSRangeCallCount() int {
	fake.tSRangeMutex.RLock()
	defer fake.tSRangeMutex.RUnlock()
	return len(fake.tSRangeArgsForCall)
}

func (fake *FakeClient) TSRangeCalls(stub func(context.Context, string, int, int) *redisa.TSTimestampValueSliceCmd) {
	fake.tSRangeMutex.Lock()
	defer fake.tSRangeMutex.Unlock()
	fake.TSRangeStub = stub
}

func (fake *FakeClient) TSRangeArgsForCall(i int) (context.Context, string, int, int) {
	fake.tSRangeMutex.RLock()
	defer fake.tSRangeMutex.RUnlock()
	argsForCall := fake.tSRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) TSRangeReturns(result1 *redisa.TSTimestampValueSliceCmd) {
	fake.tSRangeMutex.Lock()
	defer fake.tSRangeMutex.Unlock()
	fake.TSRangeStub = nil
	fake.tSRangeReturns = struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}{result1}
}

func (fake *FakeClient) TSRangeReturnsOnCall(i int, result1 *redisa.TSTimestampValueSliceCmd) {
	fake.tSRangeMutex.Lock()
	defer fake.tSRangeMutex.Unlock()
	fake.TSRangeStub = nil
	if fake.tSRangeReturnsOnCall == nil {
		fake.tSRangeReturnsOnCall = make(map[int]struct {
			result1 *redisa.TSTimestampValueSliceCmd
		})
	}
	fake.tSRangeReturnsOnCall[i] = struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}{result1}
}

func (fake *FakeClient) TSRangeWithArgs(arg1 context.Context, arg2 string, arg3 int, arg4 int, arg5 *redisa.TSRangeOptions) *redisa.TSTimestampValueSliceCmd {
	fake.tSRangeWithArgsMutex.Lock()
	ret, specificReturn := fake.tSRangeWithArgsReturnsOnCall[len(fake.tSRangeWithArgsArgsForCall)]
	fake.tSRangeWithArgsArgsForCall = append(fake.tSRangeWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 int
		arg5 *redisa.TSRangeOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.TSRangeWithArgsStub
	fakeReturns := fake.tSRangeWithArgsReturns
	fake.recordInvocation("TSRangeWithArgs", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.tSRangeWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSRangeWithArgsCallCount() int {
	fake.tSRangeWithArgsMutex.RLock()
	defer fake.tSRangeWithArgsMutex.RUnlock()
	return len(fake.tSRangeWithArgsArgsForCall)
}

func (fake *FakeClient) TSRangeWithArgsCalls(stub func(context.Context, string, int, int, *redisa.TSRangeOptions) *redisa.TSTimestampValueSliceCmd) {
	fake.tSRangeWithArgsMutex.Lock()
	defer fake.tSRangeWithArgsMutex.Unlock()
	fake.TSRangeWithArgsStub = stub
}

func (fake *FakeClient) TSRangeWithArgsArgsForCall(i int) (context.Context, string, int, int, *redisa.TSRangeOptions) {
	fake.tSRangeWithArgsMutex.RLock()
	defer fake.tSRangeWithArgsMutex.RUnlock()
	argsForCall := fake.tSRangeWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) TSRangeWithArgsReturns(result1 *redisa.TSTimestampValueSliceCmd) {
	fake.tSRangeWithArgsMutex.Lock()
	defer fake.tSRangeWithArgsMutex.Unlock()
	fake.TSRangeWithArgsStub = nil
	fake.tSRangeWithArgsReturns = struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}{result1}
}

func (fake *FakeClient) TSRangeWithArgsReturnsOnCall(i int, result1 *redisa.TSTimestampValueSliceCmd) {
	fake.tSRangeWithArgsMutex.Lock()
	defer fake.tSRangeWithArgsMutex.Unlock()
	fake.TSRangeWithArgsStub = nil
	if fake.tSRangeWithArgsReturnsOnCall == nil {
		fake.tSRangeWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.TSTimestampValueSliceCmd
		})
	}
	fake.tSRangeWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}{result1}
}

func (fake *FakeClient) TSRevRange(arg1 context.Context, arg2 string, arg3 int, arg4 int) *redisa.TSTimestampValueSliceCmd {
	fake.tSRevRangeMutex.Lock()
	ret, specificReturn := fake.tSRevRangeReturnsOnCall[len(fake.tSRevRangeArgsForCall)]
	fake.tSRevRangeArgsForCall = append(fake.tSRevRangeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.TSRevRangeStub
	fakeReturns := fake.tSRevRangeReturns
	fake.recordInvocation("TSRevRange", []interface{}{arg1, arg2, arg3, arg4})
	fake.tSRevRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSRevRangeCallCount() int {
	fake.tSRevRangeMutex.RLock()
	defer fake.tSRevRangeMutex.RUnlock()
	return len(fake.tSRevRangeArgsForCall)
}

func (fake *FakeClient) TSRevRangeCalls(stub func(context.Context, string, int, int) *redisa.TSTimestampValueSliceCmd) {
	fake.tSRevRangeMutex.Lock()
	defer fake.tSRevRangeMutex.Unlock()
	fake.TSRevRangeStub = stub
}

func (fake *FakeClient) TSRevRangeArgsForCall(i int) (context.Context, string, int, int) {
	fake.tSRevRangeMutex.RLock()
	defer fake.tSRevRangeMutex.RUnlock()
	argsForCall := fake.tSRevRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) TSRevRangeReturns(result1 *redisa.TSTimestampValueSliceCmd) {
	fake.tSRevRangeMutex.Lock()
	defer fake.tSRevRangeMutex.Unlock()
	fake.TSRevRangeStub = nil
	fake.tSRevRangeReturns = struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}{result1}
}

func (fake *FakeClient) TSRevRangeReturnsOnCall(i int, result1 *redisa.TSTimestampValueSliceCmd) {
	fake.tSRevRangeMutex.Lock()
	defer fake.tSRevRangeMutex.Unlock()
	fake.TSRevRangeStub = nil
	if fake.tSRevRangeReturnsOnCall == nil {
		fake.tSRevRangeReturnsOnCall = make(map[int]struct {
			result1 *redisa.TSTimestampValueSliceCmd
		})
	}
	fake.tSRevRangeReturnsOnCall[i] = struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}{result1}
}

func (fake *FakeClient) TSRevRangeWithArgs(arg1 context.Context, arg2 string, arg3 int, arg4 int, arg5 *redisa.TSRevRangeOptions) *redisa.TSTimestampValueSliceCmd {
	fake.tSRevRangeWithArgsMutex.Lock()
	ret, specificReturn := fake.tSRevRangeWithArgsReturnsOnCall[len(fake.tSRevRangeWithArgsArgsForCall)]
	fake.tSRevRangeWithArgsArgsForCall = append(fake.tSRevRangeWithArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
		arg4 int
		arg5 *redisa.TSRevRangeOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.TSRevRangeWithArgsStub
	fakeReturns := fake.tSRevRangeWithArgsReturns
	fake.recordInvocation("TSRevRangeWithArgs", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.tSRevRangeWithArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TSRevRangeWithArgsCallCount() int {
	fake.tSRevRangeWithArgsMutex.RLock()
	defer fake.tSRevRangeWithArgsMutex.RUnlock()
	return len(fake.tSRevRangeWithArgsArgsForCall)
}

func (fake *FakeClient) TSRevRangeWithArgsCalls(stub func(context.Context, string, int, int, *redisa.TSRevRangeOptions) *redisa.TSTimestampValueSliceCmd) {
	fake.tSRevRangeWithArgsMutex.Lock()
	defer fake.tSRevRangeWithArgsMutex.Unlock()
	fake.TSRevRangeWithArgsStub = stub
}

func (fake *FakeClient) TSRevRangeWithArgsArgsForCall(i int) (context.Context, string, int, int, *redisa.TSRevRangeOptions) {
	fake.tSRevRangeWithArgsMutex.RLock()
	defer fake.tSRevRangeWithArgsMutex.RUnlock()
	argsForCall := fake.tSRevRangeWithArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) TSRevRangeWithArgsReturns(result1 *redisa.TSTimestampValueSliceCmd) {
	fake.tSRevRangeWithArgsMutex.Lock()
	defer fake.tSRevRangeWithArgsMutex.Unlock()
	fake.TSRevRangeWithArgsStub = nil
	fake.tSRevRangeWithArgsReturns = struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}{result1}
}

func (fake *FakeClient) TSRevRangeWithArgsReturnsOnCall(i int, result1 *redisa.TSTimestampValueSliceCmd) {
	fake.tSRevRangeWithArgsMutex.Lock()
	defer fake.tSRevRangeWithArgsMutex.Unlock()
	fake.TSRevRangeWithArgsStub = nil
	if fake.tSRevRangeWithArgsReturnsOnCall == nil {
		fake.tSRevRangeWithArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.TSTimestampValueSliceCmd
		})
	}
	fake.tSRevRangeWithArgsReturnsOnCall[i] = struct {
		result1 *redisa.TSTimestampValueSliceCmd
	}{result1}
}

func (fake *FakeClient) TTL(arg1 context.Context, arg2 string) *redisa.DurationCmd {
	fake.tTLMutex.Lock()
	ret, specificReturn := fake.tTLReturnsOnCall[len(fake.tTLArgsForCall)]
	fake.tTLArgsForCall = append(fake.tTLArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TTLStub
	fakeReturns := fake.tTLReturns
	fake.recordInvocation("TTL", []interface{}{arg1, arg2})
	fake.tTLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TTLCallCount() int {
	fake.tTLMutex.RLock()
	defer fake.tTLMutex.RUnlock()
	return len(fake.tTLArgsForCall)
}

func (fake *FakeClient) TTLCalls(stub func(context.Context, string) *redisa.DurationCmd) {
	fake.tTLMutex.Lock()
	defer fake.tTLMutex.Unlock()
	fake.TTLStub = stub
}

func (fake *FakeClient) TTLArgsForCall(i int) (context.Context, string) {
	fake.tTLMutex.RLock()
	defer fake.tTLMutex.RUnlock()
	argsForCall := fake.tTLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TTLReturns(result1 *redisa.DurationCmd) {
	fake.tTLMutex.Lock()
	defer fake.tTLMutex.Unlock()
	fake.TTLStub = nil
	fake.tTLReturns = struct {
		result1 *redisa.DurationCmd
	}{result1}
}

func (fake *FakeClient) TTLReturnsOnCall(i int, result1 *redisa.DurationCmd) {
	fake.tTLMutex.Lock()
	defer fake.tTLMutex.Unlock()
	fake.TTLStub = nil
	if fake.tTLReturnsOnCall == nil {
		fake.tTLReturnsOnCall = make(map[int]struct {
			result1 *redisa.DurationCmd
		})
	}
	fake.tTLReturnsOnCall[i] = struct {
		result1 *redisa.DurationCmd
	}{result1}
}

func (fake *FakeClient) Time(arg1 context.Context) *redisa.TimeCmd {
	fake.timeMutex.Lock()
	ret, specificReturn := fake.timeReturnsOnCall[len(fake.timeArgsForCall)]
	fake.timeArgsForCall = append(fake.timeArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.TimeStub
	fakeReturns := fake.timeReturns
	fake.recordInvocation("Time", []interface{}{arg1})
	fake.timeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TimeCallCount() int {
	fake.timeMutex.RLock()
	defer fake.timeMutex.RUnlock()
	return len(fake.timeArgsForCall)
}

func (fake *FakeClient) TimeCalls(stub func(context.Context) *redisa.TimeCmd) {
	fake.timeMutex.Lock()
	defer fake.timeMutex.Unlock()
	fake.TimeStub = stub
}

func (fake *FakeClient) TimeArgsForCall(i int) context.Context {
	fake.timeMutex.RLock()
	defer fake.timeMutex.RUnlock()
	argsForCall := fake.timeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) TimeReturns(result1 *redisa.TimeCmd) {
	fake.timeMutex.Lock()
	defer fake.timeMutex.Unlock()
	fake.TimeStub = nil
	fake.timeReturns = struct {
		result1 *redisa.TimeCmd
	}{result1}
}

func (fake *FakeClient) TimeReturnsOnCall(i int, result1 *redisa.TimeCmd) {
	fake.timeMutex.Lock()
	defer fake.timeMutex.Unlock()
	fake.TimeStub = nil
	if fake.timeReturnsOnCall == nil {
		fake.timeReturnsOnCall = make(map[int]struct {
			result1 *redisa.TimeCmd
		})
	}
	fake.timeReturnsOnCall[i] = struct {
		result1 *redisa.TimeCmd
	}{result1}
}

func (fake *FakeClient) TopKAdd(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.StringSliceCmd {
	fake.topKAddMutex.Lock()
	ret, specificReturn := fake.topKAddReturnsOnCall[len(fake.topKAddArgsForCall)]
	fake.topKAddArgsForCall = append(fake.topKAddArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.TopKAddStub
	fakeReturns := fake.topKAddReturns
	fake.recordInvocation("TopKAdd", []interface{}{arg1, arg2, arg3})
	fake.topKAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TopKAddCallCount() int {
	fake.topKAddMutex.RLock()
	defer fake.topKAddMutex.RUnlock()
	return len(fake.topKAddArgsForCall)
}

func (fake *FakeClient) TopKAddCalls(stub func(context.Context, string, ...interface{}) *redisa.StringSliceCmd) {
	fake.topKAddMutex.Lock()
	defer fake.topKAddMutex.Unlock()
	fake.TopKAddStub = stub
}

func (fake *FakeClient) TopKAddArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.topKAddMutex.RLock()
	defer fake.topKAddMutex.RUnlock()
	argsForCall := fake.topKAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TopKAddReturns(result1 *redisa.StringSliceCmd) {
	fake.topKAddMutex.Lock()
	defer fake.topKAddMutex.Unlock()
	fake.TopKAddStub = nil
	fake.topKAddReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) TopKAddReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.topKAddMutex.Lock()
	defer fake.topKAddMutex.Unlock()
	fake.TopKAddStub = nil
	if fake.topKAddReturnsOnCall == nil {
		fake.topKAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.topKAddReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) TopKCount(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntSliceCmd {
	fake.topKCountMutex.Lock()
	ret, specificReturn := fake.topKCountReturnsOnCall[len(fake.topKCountArgsForCall)]
	fake.topKCountArgsForCall = append(fake.topKCountArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.TopKCountStub
	fakeReturns := fake.topKCountReturns
	fake.recordInvocation("TopKCount", []interface{}{arg1, arg2, arg3})
	fake.topKCountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TopKCountCallCount() int {
	fake.topKCountMutex.RLock()
	defer fake.topKCountMutex.RUnlock()
	return len(fake.topKCountArgsForCall)
}

func (fake *FakeClient) TopKCountCalls(stub func(context.Context, string, ...interface{}) *redisa.IntSliceCmd) {
	fake.topKCountMutex.Lock()
	defer fake.topKCountMutex.Unlock()
	fake.TopKCountStub = stub
}

func (fake *FakeClient) TopKCountArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.topKCountMutex.RLock()
	defer fake.topKCountMutex.RUnlock()
	argsForCall := fake.topKCountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TopKCountReturns(result1 *redisa.IntSliceCmd) {
	fake.topKCountMutex.Lock()
	defer fake.topKCountMutex.Unlock()
	fake.TopKCountStub = nil
	fake.topKCountReturns = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) TopKCountReturnsOnCall(i int, result1 *redisa.IntSliceCmd) {
	fake.topKCountMutex.Lock()
	defer fake.topKCountMutex.Unlock()
	fake.TopKCountStub = nil
	if fake.topKCountReturnsOnCall == nil {
		fake.topKCountReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntSliceCmd
		})
	}
	fake.topKCountReturnsOnCall[i] = struct {
		result1 *redisa.IntSliceCmd
	}{result1}
}

func (fake *FakeClient) TopKIncrBy(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.StringSliceCmd {
	fake.topKIncrByMutex.Lock()
	ret, specificReturn := fake.topKIncrByReturnsOnCall[len(fake.topKIncrByArgsForCall)]
	fake.topKIncrByArgsForCall = append(fake.topKIncrByArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.TopKIncrByStub
	fakeReturns := fake.topKIncrByReturns
	fake.recordInvocation("TopKIncrBy", []interface{}{arg1, arg2, arg3})
	fake.topKIncrByMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TopKIncrByCallCount() int {
	fake.topKIncrByMutex.RLock()
	defer fake.topKIncrByMutex.RUnlock()
	return len(fake.topKIncrByArgsForCall)
}

func (fake *FakeClient) TopKIncrByCalls(stub func(context.Context, string, ...interface{}) *redisa.StringSliceCmd) {
	fake.topKIncrByMutex.Lock()
	defer fake.topKIncrByMutex.Unlock()
	fake.TopKIncrByStub = stub
}

func (fake *FakeClient) TopKIncrByArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.topKIncrByMutex.RLock()
	defer fake.topKIncrByMutex.RUnlock()
	argsForCall := fake.topKIncrByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TopKIncrByReturns(result1 *redisa.StringSliceCmd) {
	fake.topKIncrByMutex.Lock()
	defer fake.topKIncrByMutex.Unlock()
	fake.TopKIncrByStub = nil
	fake.topKIncrByReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) TopKIncrByReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.topKIncrByMutex.Lock()
	defer fake.topKIncrByMutex.Unlock()
	fake.TopKIncrByStub = nil
	if fake.topKIncrByReturnsOnCall == nil {
		fake.topKIncrByReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.topKIncrByReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) TopKInfo(arg1 context.Context, arg2 string) *redisa.TopKInfoCmd {
	fake.topKInfoMutex.Lock()
	ret, specificReturn := fake.topKInfoReturnsOnCall[len(fake.topKInfoArgsForCall)]
	fake.topKInfoArgsForCall = append(fake.topKInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TopKInfoStub
	fakeReturns := fake.topKInfoReturns
	fake.recordInvocation("TopKInfo", []interface{}{arg1, arg2})
	fake.topKInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TopKInfoCallCount() int {
	fake.topKInfoMutex.RLock()
	defer fake.topKInfoMutex.RUnlock()
	return len(fake.topKInfoArgsForCall)
}

func (fake *FakeClient) TopKInfoCalls(stub func(context.Context, string) *redisa.TopKInfoCmd) {
	fake.topKInfoMutex.Lock()
	defer fake.topKInfoMutex.Unlock()
	fake.TopKInfoStub = stub
}

func (fake *FakeClient) TopKInfoArgsForCall(i int) (context.Context, string) {
	fake.topKInfoMutex.RLock()
	defer fake.topKInfoMutex.RUnlock()
	argsForCall := fake.topKInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TopKInfoReturns(result1 *redisa.TopKInfoCmd) {
	fake.topKInfoMutex.Lock()
	defer fake.topKInfoMutex.Unlock()
	fake.TopKInfoStub = nil
	fake.topKInfoReturns = struct {
		result1 *redisa.TopKInfoCmd
	}{result1}
}

func (fake *FakeClient) TopKInfoReturnsOnCall(i int, result1 *redisa.TopKInfoCmd) {
	fake.topKInfoMutex.Lock()
	defer fake.topKInfoMutex.Unlock()
	fake.TopKInfoStub = nil
	if fake.topKInfoReturnsOnCall == nil {
		fake.topKInfoReturnsOnCall = make(map[int]struct {
			result1 *redisa.TopKInfoCmd
		})
	}
	fake.topKInfoReturnsOnCall[i] = struct {
		result1 *redisa.TopKInfoCmd
	}{result1}
}

func (fake *FakeClient) TopKList(arg1 context.Context, arg2 string) *redisa.StringSliceCmd {
	fake.topKListMutex.Lock()
	ret, specificReturn := fake.topKListReturnsOnCall[len(fake.topKListArgsForCall)]
	fake.topKListArgsForCall = append(fake.topKListArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TopKListStub
	fakeReturns := fake.topKListReturns
	fake.recordInvocation("TopKList", []interface{}{arg1, arg2})
	fake.topKListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TopKListCallCount() int {
	fake.topKListMutex.RLock()
	defer fake.topKListMutex.RUnlock()
	return len(fake.topKListArgsForCall)
}

func (fake *FakeClient) TopKListCalls(stub func(context.Context, string) *redisa.StringSliceCmd) {
	fake.topKListMutex.Lock()
	defer fake.topKListMutex.Unlock()
	fake.TopKListStub = stub
}

func (fake *FakeClient) TopKListArgsForCall(i int) (context.Context, string) {
	fake.topKListMutex.RLock()
	defer fake.topKListMutex.RUnlock()
	argsForCall := fake.topKListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TopKListReturns(result1 *redisa.StringSliceCmd) {
	fake.topKListMutex.Lock()
	defer fake.topKListMutex.Unlock()
	fake.TopKListStub = nil
	fake.topKListReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) TopKListReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.topKListMutex.Lock()
	defer fake.topKListMutex.Unlock()
	fake.TopKListStub = nil
	if fake.topKListReturnsOnCall == nil {
		fake.topKListReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.topKListReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) TopKListWithCount(arg1 context.Context, arg2 string) *redisa.MapStringIntCmd {
	fake.topKListWithCountMutex.Lock()
	ret, specificReturn := fake.topKListWithCountReturnsOnCall[len(fake.topKListWithCountArgsForCall)]
	fake.topKListWithCountArgsForCall = append(fake.topKListWithCountArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TopKListWithCountStub
	fakeReturns := fake.topKListWithCountReturns
	fake.recordInvocation("TopKListWithCount", []interface{}{arg1, arg2})
	fake.topKListWithCountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TopKListWithCountCallCount() int {
	fake.topKListWithCountMutex.RLock()
	defer fake.topKListWithCountMutex.RUnlock()
	return len(fake.topKListWithCountArgsForCall)
}

func (fake *FakeClient) TopKListWithCountCalls(stub func(context.Context, string) *redisa.MapStringIntCmd) {
	fake.topKListWithCountMutex.Lock()
	defer fake.topKListWithCountMutex.Unlock()
	fake.TopKListWithCountStub = stub
}

func (fake *FakeClient) TopKListWithCountArgsForCall(i int) (context.Context, string) {
	fake.topKListWithCountMutex.RLock()
	defer fake.topKListWithCountMutex.RUnlock()
	argsForCall := fake.topKListWithCountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TopKListWithCountReturns(result1 *redisa.MapStringIntCmd) {
	fake.topKListWithCountMutex.Lock()
	defer fake.topKListWithCountMutex.Unlock()
	fake.TopKListWithCountStub = nil
	fake.topKListWithCountReturns = struct {
		result1 *redisa.MapStringIntCmd
	}{result1}
}

func (fake *FakeClient) TopKListWithCountReturnsOnCall(i int, result1 *redisa.MapStringIntCmd) {
	fake.topKListWithCountMutex.Lock()
	defer fake.topKListWithCountMutex.Unlock()
	fake.TopKListWithCountStub = nil
	if fake.topKListWithCountReturnsOnCall == nil {
		fake.topKListWithCountReturnsOnCall = make(map[int]struct {
			result1 *redisa.MapStringIntCmd
		})
	}
	fake.topKListWithCountReturnsOnCall[i] = struct {
		result1 *redisa.MapStringIntCmd
	}{result1}
}

func (fake *FakeClient) TopKQuery(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.BoolSliceCmd {
	fake.topKQueryMutex.Lock()
	ret, specificReturn := fake.topKQueryReturnsOnCall[len(fake.topKQueryArgsForCall)]
	fake.topKQueryArgsForCall = append(fake.topKQueryArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.TopKQueryStub
	fakeReturns := fake.topKQueryReturns
	fake.recordInvocation("TopKQuery", []interface{}{arg1, arg2, arg3})
	fake.topKQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TopKQueryCallCount() int {
	fake.topKQueryMutex.RLock()
	defer fake.topKQueryMutex.RUnlock()
	return len(fake.topKQueryArgsForCall)
}

func (fake *FakeClient) TopKQueryCalls(stub func(context.Context, string, ...interface{}) *redisa.BoolSliceCmd) {
	fake.topKQueryMutex.Lock()
	defer fake.topKQueryMutex.Unlock()
	fake.TopKQueryStub = stub
}

func (fake *FakeClient) TopKQueryArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.topKQueryMutex.RLock()
	defer fake.topKQueryMutex.RUnlock()
	argsForCall := fake.topKQueryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TopKQueryReturns(result1 *redisa.BoolSliceCmd) {
	fake.topKQueryMutex.Lock()
	defer fake.topKQueryMutex.Unlock()
	fake.TopKQueryStub = nil
	fake.topKQueryReturns = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) TopKQueryReturnsOnCall(i int, result1 *redisa.BoolSliceCmd) {
	fake.topKQueryMutex.Lock()
	defer fake.topKQueryMutex.Unlock()
	fake.TopKQueryStub = nil
	if fake.topKQueryReturnsOnCall == nil {
		fake.topKQueryReturnsOnCall = make(map[int]struct {
			result1 *redisa.BoolSliceCmd
		})
	}
	fake.topKQueryReturnsOnCall[i] = struct {
		result1 *redisa.BoolSliceCmd
	}{result1}
}

func (fake *FakeClient) TopKReserve(arg1 context.Context, arg2 string, arg3 int64) *redisa.StatusCmd {
	fake.topKReserveMutex.Lock()
	ret, specificReturn := fake.topKReserveReturnsOnCall[len(fake.topKReserveArgsForCall)]
	fake.topKReserveArgsForCall = append(fake.topKReserveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.TopKReserveStub
	fakeReturns := fake.topKReserveReturns
	fake.recordInvocation("TopKReserve", []interface{}{arg1, arg2, arg3})
	fake.topKReserveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TopKReserveCallCount() int {
	fake.topKReserveMutex.RLock()
	defer fake.topKReserveMutex.RUnlock()
	return len(fake.topKReserveArgsForCall)
}

func (fake *FakeClient) TopKReserveCalls(stub func(context.Context, string, int64) *redisa.StatusCmd) {
	fake.topKReserveMutex.Lock()
	defer fake.topKReserveMutex.Unlock()
	fake.TopKReserveStub = stub
}

func (fake *FakeClient) TopKReserveArgsForCall(i int) (context.Context, string, int64) {
	fake.topKReserveMutex.RLock()
	defer fake.topKReserveMutex.RUnlock()
	argsForCall := fake.topKReserveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) TopKReserveReturns(result1 *redisa.StatusCmd) {
	fake.topKReserveMutex.Lock()
	defer fake.topKReserveMutex.Unlock()
	fake.TopKReserveStub = nil
	fake.topKReserveReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TopKReserveReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.topKReserveMutex.Lock()
	defer fake.topKReserveMutex.Unlock()
	fake.TopKReserveStub = nil
	if fake.topKReserveReturnsOnCall == nil {
		fake.topKReserveReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.topKReserveReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TopKReserveWithOptions(arg1 context.Context, arg2 string, arg3 int64, arg4 int64, arg5 int64, arg6 float64) *redisa.StatusCmd {
	fake.topKReserveWithOptionsMutex.Lock()
	ret, specificReturn := fake.topKReserveWithOptionsReturnsOnCall[len(fake.topKReserveWithOptionsArgsForCall)]
	fake.topKReserveWithOptionsArgsForCall = append(fake.topKReserveWithOptionsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
		arg5 int64
		arg6 float64
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.TopKReserveWithOptionsStub
	fakeReturns := fake.topKReserveWithOptionsReturns
	fake.recordInvocation("TopKReserveWithOptions", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.topKReserveWithOptionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TopKReserveWithOptionsCallCount() int {
	fake.topKReserveWithOptionsMutex.RLock()
	defer fake.topKReserveWithOptionsMutex.RUnlock()
	return len(fake.topKReserveWithOptionsArgsForCall)
}

func (fake *FakeClient) TopKReserveWithOptionsCalls(stub func(context.Context, string, int64, int64, int64, float64) *redisa.StatusCmd) {
	fake.topKReserveWithOptionsMutex.Lock()
	defer fake.topKReserveWithOptionsMutex.Unlock()
	fake.TopKReserveWithOptionsStub = stub
}

func (fake *FakeClient) TopKReserveWithOptionsArgsForCall(i int) (context.Context, string, int64, int64, int64, float64) {
	fake.topKReserveWithOptionsMutex.RLock()
	defer fake.topKReserveWithOptionsMutex.RUnlock()
	argsForCall := fake.topKReserveWithOptionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeClient) TopKReserveWithOptionsReturns(result1 *redisa.StatusCmd) {
	fake.topKReserveWithOptionsMutex.Lock()
	defer fake.topKReserveWithOptionsMutex.Unlock()
	fake.TopKReserveWithOptionsStub = nil
	fake.topKReserveWithOptionsReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TopKReserveWithOptionsReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.topKReserveWithOptionsMutex.Lock()
	defer fake.topKReserveWithOptionsMutex.Unlock()
	fake.TopKReserveWithOptionsStub = nil
	if fake.topKReserveWithOptionsReturnsOnCall == nil {
		fake.topKReserveWithOptionsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.topKReserveWithOptionsReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) Touch(arg1 context.Context, arg2 ...string) *redisa.IntCmd {
	fake.touchMutex.Lock()
	ret, specificReturn := fake.touchReturnsOnCall[len(fake.touchArgsForCall)]
	fake.touchArgsForCall = append(fake.touchArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.TouchStub
	fakeReturns := fake.touchReturns
	fake.recordInvocation("Touch", []interface{}{arg1, arg2})
	fake.touchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TouchCallCount() int {
	fake.touchMutex.RLock()
	defer fake.touchMutex.RUnlock()
	return len(fake.touchArgsForCall)
}

func (fake *FakeClient) TouchCalls(stub func(context.Context, ...string) *redisa.IntCmd) {
	fake.touchMutex.Lock()
	defer fake.touchMutex.Unlock()
	fake.TouchStub = stub
}

func (fake *FakeClient) TouchArgsForCall(i int) (context.Context, []string) {
	fake.touchMutex.RLock()
	defer fake.touchMutex.RUnlock()
	argsForCall := fake.touchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TouchReturns(result1 *redisa.IntCmd) {
	fake.touchMutex.Lock()
	defer fake.touchMutex.Unlock()
	fake.TouchStub = nil
	fake.touchReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TouchReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.touchMutex.Lock()
	defer fake.touchMutex.Unlock()
	fake.TouchStub = nil
	if fake.touchReturnsOnCall == nil {
		fake.touchReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.touchReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) TxPipeline() redisa.Pipeliner {
	fake.txPipelineMutex.Lock()
	ret, specificReturn := fake.txPipelineReturnsOnCall[len(fake.txPipelineArgsForCall)]
	fake.txPipelineArgsForCall = append(fake.txPipelineArgsForCall, struct {
	}{})
	stub := fake.TxPipelineStub
	fakeReturns := fake.txPipelineReturns
	fake.recordInvocation("TxPipeline", []interface{}{})
	fake.txPipelineMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TxPipelineCallCount() int {
	fake.txPipelineMutex.RLock()
	defer fake.txPipelineMutex.RUnlock()
	return len(fake.txPipelineArgsForCall)
}

func (fake *FakeClient) TxPipelineCalls(stub func() redisa.Pipeliner) {
	fake.txPipelineMutex.Lock()
	defer fake.txPipelineMutex.Unlock()
	fake.TxPipelineStub = stub
}

func (fake *FakeClient) TxPipelineReturns(result1 redisa.Pipeliner) {
	fake.txPipelineMutex.Lock()
	defer fake.txPipelineMutex.Unlock()
	fake.TxPipelineStub = nil
	fake.txPipelineReturns = struct {
		result1 redisa.Pipeliner
	}{result1}
}

func (fake *FakeClient) TxPipelineReturnsOnCall(i int, result1 redisa.Pipeliner) {
	fake.txPipelineMutex.Lock()
	defer fake.txPipelineMutex.Unlock()
	fake.TxPipelineStub = nil
	if fake.txPipelineReturnsOnCall == nil {
		fake.txPipelineReturnsOnCall = make(map[int]struct {
			result1 redisa.Pipeliner
		})
	}
	fake.txPipelineReturnsOnCall[i] = struct {
		result1 redisa.Pipeliner
	}{result1}
}

func (fake *FakeClient) TxPipelined(arg1 context.Context, arg2 func(redisa.Pipeliner) error) ([]redisa.Cmder, error) {
	fake.txPipelinedMutex.Lock()
	ret, specificReturn := fake.txPipelinedReturnsOnCall[len(fake.txPipelinedArgsForCall)]
	fake.txPipelinedArgsForCall = append(fake.txPipelinedArgsForCall, struct {
		arg1 context.Context
		arg2 func(redisa.Pipeliner) error
	}{arg1, arg2})
	stub := fake.TxPipelinedStub
	fakeReturns := fake.txPipelinedReturns
	fake.recordInvocation("TxPipelined", []interface{}{arg1, arg2})
	fake.txPipelinedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) TxPipelinedCallCount() int {
	fake.txPipelinedMutex.RLock()
	defer fake.txPipelinedMutex.RUnlock()
	return len(fake.txPipelinedArgsForCall)
}

func (fake *FakeClient) TxPipelinedCalls(stub func(context.Context, func(redisa.Pipeliner) error) ([]redisa.Cmder, error)) {
	fake.txPipelinedMutex.Lock()
	defer fake.txPipelinedMutex.Unlock()
	fake.TxPipelinedStub = stub
}

func (fake *FakeClient) TxPipelinedArgsForCall(i int) (context.Context, func(redisa.Pipeliner) error) {
	fake.txPipelinedMutex.RLock()
	defer fake.txPipelinedMutex.RUnlock()
	argsForCall := fake.txPipelinedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TxPipelinedReturns(result1 []redisa.Cmder, result2 error) {
	fake.txPipelinedMutex.Lock()
	defer fake.txPipelinedMutex.Unlock()
	fake.TxPipelinedStub = nil
	fake.txPipelinedReturns = struct {
		result1 []redisa.Cmder
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TxPipelinedReturnsOnCall(i int, result1 []redisa.Cmder, result2 error) {
	fake.txPipelinedMutex.Lock()
	defer fake.txPipelinedMutex.Unlock()
	fake.TxPipelinedStub = nil
	if fake.txPipelinedReturnsOnCall == nil {
		fake.txPipelinedReturnsOnCall = make(map[int]struct {
			result1 []redisa.Cmder
			result2 error
		})
	}
	fake.txPipelinedReturnsOnCall[i] = struct {
		result1 []redisa.Cmder
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Type(arg1 context.Context, arg2 string) *redisa.StatusCmd {
	fake.typeMutex.Lock()
	ret, specificReturn := fake.typeReturnsOnCall[len(fake.typeArgsForCall)]
	fake.typeArgsForCall = append(fake.typeArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TypeStub
	fakeReturns := fake.typeReturns
	fake.recordInvocation("Type", []interface{}{arg1, arg2})
	fake.typeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) TypeCallCount() int {
	fake.typeMutex.RLock()
	defer fake.typeMutex.RUnlock()
	return len(fake.typeArgsForCall)
}

func (fake *FakeClient) TypeCalls(stub func(context.Context, string) *redisa.StatusCmd) {
	fake.typeMutex.Lock()
	defer fake.typeMutex.Unlock()
	fake.TypeStub = stub
}

func (fake *FakeClient) TypeArgsForCall(i int) (context.Context, string) {
	fake.typeMutex.RLock()
	defer fake.typeMutex.RUnlock()
	argsForCall := fake.typeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TypeReturns(result1 *redisa.StatusCmd) {
	fake.typeMutex.Lock()
	defer fake.typeMutex.Unlock()
	fake.TypeStub = nil
	fake.typeReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) TypeReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.typeMutex.Lock()
	defer fake.typeMutex.Unlock()
	fake.TypeStub = nil
	if fake.typeReturnsOnCall == nil {
		fake.typeReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.typeReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) Unlink(arg1 context.Context, arg2 ...string) *redisa.IntCmd {
	fake.unlinkMutex.Lock()
	ret, specificReturn := fake.unlinkReturnsOnCall[len(fake.unlinkArgsForCall)]
	fake.unlinkArgsForCall = append(fake.unlinkArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.UnlinkStub
	fakeReturns := fake.unlinkReturns
	fake.recordInvocation("Unlink", []interface{}{arg1, arg2})
	fake.unlinkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) UnlinkCallCount() int {
	fake.unlinkMutex.RLock()
	defer fake.unlinkMutex.RUnlock()
	return len(fake.unlinkArgsForCall)
}

func (fake *FakeClient) UnlinkCalls(stub func(context.Context, ...string) *redisa.IntCmd) {
	fake.unlinkMutex.Lock()
	defer fake.unlinkMutex.Unlock()
	fake.UnlinkStub = stub
}

func (fake *FakeClient) UnlinkArgsForCall(i int) (context.Context, []string) {
	fake.unlinkMutex.RLock()
	defer fake.unlinkMutex.RUnlock()
	argsForCall := fake.unlinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) UnlinkReturns(result1 *redisa.IntCmd) {
	fake.unlinkMutex.Lock()
	defer fake.unlinkMutex.Unlock()
	fake.UnlinkStub = nil
	fake.unlinkReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) UnlinkReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.unlinkMutex.Lock()
	defer fake.unlinkMutex.Unlock()
	fake.UnlinkStub = nil
	if fake.unlinkReturnsOnCall == nil {
		fake.unlinkReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.unlinkReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) Watch(arg1 context.Context, arg2 func(*redisa.Tx) error, arg3 ...string) error {
	fake.watchMutex.Lock()
	ret, specificReturn := fake.watchReturnsOnCall[len(fake.watchArgsForCall)]
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
		arg1 context.Context
		arg2 func(*redisa.Tx) error
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.WatchStub
	fakeReturns := fake.watchReturns
	fake.recordInvocation("Watch", []interface{}{arg1, arg2, arg3})
	fake.watchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *FakeClient) WatchCalls(stub func(context.Context, func(*redisa.Tx) error, ...string) error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = stub
}

func (fake *FakeClient) WatchArgsForCall(i int) (context.Context, func(*redisa.Tx) error, []string) {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	argsForCall := fake.watchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) WatchReturns(result1 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WatchReturnsOnCall(i int, result1 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	if fake.watchReturnsOnCall == nil {
		fake.watchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.watchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) XAck(arg1 context.Context, arg2 string, arg3 string, arg4 ...string) *redisa.IntCmd {
	fake.xAckMutex.Lock()
	ret, specificReturn := fake.xAckReturnsOnCall[len(fake.xAckArgsForCall)]
	fake.xAckArgsForCall = append(fake.xAckArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []string
	}{arg1, arg2, arg3, arg4})
	stub := fake.XAckStub
	fakeReturns := fake.xAckReturns
	fake.recordInvocation("XAck", []interface{}{arg1, arg2, arg3, arg4})
	fake.xAckMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XAckCallCount() int {
	fake.xAckMutex.RLock()
	defer fake.xAckMutex.RUnlock()
	return len(fake.xAckArgsForCall)
}

func (fake *FakeClient) XAckCalls(stub func(context.Context, string, string, ...string) *redisa.IntCmd) {
	fake.xAckMutex.Lock()
	defer fake.xAckMutex.Unlock()
	fake.XAckStub = stub
}

func (fake *FakeClient) XAckArgsForCall(i int) (context.Context, string, string, []string) {
	fake.xAckMutex.RLock()
	defer fake.xAckMutex.RUnlock()
	argsForCall := fake.xAckArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) XAckReturns(result1 *redisa.IntCmd) {
	fake.xAckMutex.Lock()
	defer fake.xAckMutex.Unlock()
	fake.XAckStub = nil
	fake.xAckReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XAckReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.xAckMutex.Lock()
	defer fake.xAckMutex.Unlock()
	fake.XAckStub = nil
	if fake.xAckReturnsOnCall == nil {
		fake.xAckReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.xAckReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XAdd(arg1 context.Context, arg2 *redisa.XAddArgs) *redisa.StringCmd {
	fake.xAddMutex.Lock()
	ret, specificReturn := fake.xAddReturnsOnCall[len(fake.xAddArgsForCall)]
	fake.xAddArgsForCall = append(fake.xAddArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.XAddArgs
	}{arg1, arg2})
	stub := fake.XAddStub
	fakeReturns := fake.xAddReturns
	fake.recordInvocation("XAdd", []interface{}{arg1, arg2})
	fake.xAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XAddCallCount() int {
	fake.xAddMutex.RLock()
	defer fake.xAddMutex.RUnlock()
	return len(fake.xAddArgsForCall)
}

func (fake *FakeClient) XAddCalls(stub func(context.Context, *redisa.XAddArgs) *redisa.StringCmd) {
	fake.xAddMutex.Lock()
	defer fake.xAddMutex.Unlock()
	fake.XAddStub = stub
}

func (fake *FakeClient) XAddArgsForCall(i int) (context.Context, *redisa.XAddArgs) {
	fake.xAddMutex.RLock()
	defer fake.xAddMutex.RUnlock()
	argsForCall := fake.xAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) XAddReturns(result1 *redisa.StringCmd) {
	fake.xAddMutex.Lock()
	defer fake.xAddMutex.Unlock()
	fake.XAddStub = nil
	fake.xAddReturns = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) XAddReturnsOnCall(i int, result1 *redisa.StringCmd) {
	fake.xAddMutex.Lock()
	defer fake.xAddMutex.Unlock()
	fake.XAddStub = nil
	if fake.xAddReturnsOnCall == nil {
		fake.xAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringCmd
		})
	}
	fake.xAddReturnsOnCall[i] = struct {
		result1 *redisa.StringCmd
	}{result1}
}

func (fake *FakeClient) XAutoClaim(arg1 context.Context, arg2 *redisa.XAutoClaimArgs) *redisa.XAutoClaimCmd {
	fake.xAutoClaimMutex.Lock()
	ret, specificReturn := fake.xAutoClaimReturnsOnCall[len(fake.xAutoClaimArgsForCall)]
	fake.xAutoClaimArgsForCall = append(fake.xAutoClaimArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.XAutoClaimArgs
	}{arg1, arg2})
	stub := fake.XAutoClaimStub
	fakeReturns := fake.xAutoClaimReturns
	fake.recordInvocation("XAutoClaim", []interface{}{arg1, arg2})
	fake.xAutoClaimMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XAutoClaimCallCount() int {
	fake.xAutoClaimMutex.RLock()
	defer fake.xAutoClaimMutex.RUnlock()
	return len(fake.xAutoClaimArgsForCall)
}

func (fake *FakeClient) XAutoClaimCalls(stub func(context.Context, *redisa.XAutoClaimArgs) *redisa.XAutoClaimCmd) {
	fake.xAutoClaimMutex.Lock()
	defer fake.xAutoClaimMutex.Unlock()
	fake.XAutoClaimStub = stub
}

func (fake *FakeClient) XAutoClaimArgsForCall(i int) (context.Context, *redisa.XAutoClaimArgs) {
	fake.xAutoClaimMutex.RLock()
	defer fake.xAutoClaimMutex.RUnlock()
	argsForCall := fake.xAutoClaimArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) XAutoClaimReturns(result1 *redisa.XAutoClaimCmd) {
	fake.xAutoClaimMutex.Lock()
	defer fake.xAutoClaimMutex.Unlock()
	fake.XAutoClaimStub = nil
	fake.xAutoClaimReturns = struct {
		result1 *redisa.XAutoClaimCmd
	}{result1}
}

func (fake *FakeClient) XAutoClaimReturnsOnCall(i int, result1 *redisa.XAutoClaimCmd) {
	fake.xAutoClaimMutex.Lock()
	defer fake.xAutoClaimMutex.Unlock()
	fake.XAutoClaimStub = nil
	if fake.xAutoClaimReturnsOnCall == nil {
		fake.xAutoClaimReturnsOnCall = make(map[int]struct {
			result1 *redisa.XAutoClaimCmd
		})
	}
	fake.xAutoClaimReturnsOnCall[i] = struct {
		result1 *redisa.XAutoClaimCmd
	}{result1}
}

func (fake *FakeClient) XAutoClaimJustID(arg1 context.Context, arg2 *redisa.XAutoClaimArgs) *redisa.XAutoClaimJustIDCmd {
	fake.xAutoClaimJustIDMutex.Lock()
	ret, specificReturn := fake.xAutoClaimJustIDReturnsOnCall[len(fake.xAutoClaimJustIDArgsForCall)]
	fake.xAutoClaimJustIDArgsForCall = append(fake.xAutoClaimJustIDArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.XAutoClaimArgs
	}{arg1, arg2})
	stub := fake.XAutoClaimJustIDStub
	fakeReturns := fake.xAutoClaimJustIDReturns
	fake.recordInvocation("XAutoClaimJustID", []interface{}{arg1, arg2})
	fake.xAutoClaimJustIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XAutoClaimJustIDCallCount() int {
	fake.xAutoClaimJustIDMutex.RLock()
	defer fake.xAutoClaimJustIDMutex.RUnlock()
	return len(fake.xAutoClaimJustIDArgsForCall)
}

func (fake *FakeClient) XAutoClaimJustIDCalls(stub func(context.Context, *redisa.XAutoClaimArgs) *redisa.XAutoClaimJustIDCmd) {
	fake.xAutoClaimJustIDMutex.Lock()
	defer fake.xAutoClaimJustIDMutex.Unlock()
	fake.XAutoClaimJustIDStub = stub
}

func (fake *FakeClient) XAutoClaimJustIDArgsForCall(i int) (context.Context, *redisa.XAutoClaimArgs) {
	fake.xAutoClaimJustIDMutex.RLock()
	defer fake.xAutoClaimJustIDMutex.RUnlock()
	argsForCall := fake.xAutoClaimJustIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) XAutoClaimJustIDReturns(result1 *redisa.XAutoClaimJustIDCmd) {
	fake.xAutoClaimJustIDMutex.Lock()
	defer fake.xAutoClaimJustIDMutex.Unlock()
	fake.XAutoClaimJustIDStub = nil
	fake.xAutoClaimJustIDReturns = struct {
		result1 *redisa.XAutoClaimJustIDCmd
	}{result1}
}

func (fake *FakeClient) XAutoClaimJustIDReturnsOnCall(i int, result1 *redisa.XAutoClaimJustIDCmd) {
	fake.xAutoClaimJustIDMutex.Lock()
	defer fake.xAutoClaimJustIDMutex.Unlock()
	fake.XAutoClaimJustIDStub = nil
	if fake.xAutoClaimJustIDReturnsOnCall == nil {
		fake.xAutoClaimJustIDReturnsOnCall = make(map[int]struct {
			result1 *redisa.XAutoClaimJustIDCmd
		})
	}
	fake.xAutoClaimJustIDReturnsOnCall[i] = struct {
		result1 *redisa.XAutoClaimJustIDCmd
	}{result1}
}

func (fake *FakeClient) XClaim(arg1 context.Context, arg2 *redisa.XClaimArgs) *redisa.XMessageSliceCmd {
	fake.xClaimMutex.Lock()
	ret, specificReturn := fake.xClaimReturnsOnCall[len(fake.xClaimArgsForCall)]
	fake.xClaimArgsForCall = append(fake.xClaimArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.XClaimArgs
	}{arg1, arg2})
	stub := fake.XClaimStub
	fakeReturns := fake.xClaimReturns
	fake.recordInvocation("XClaim", []interface{}{arg1, arg2})
	fake.xClaimMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XClaimCallCount() int {
	fake.xClaimMutex.RLock()
	defer fake.xClaimMutex.RUnlock()
	return len(fake.xClaimArgsForCall)
}

func (fake *FakeClient) XClaimCalls(stub func(context.Context, *redisa.XClaimArgs) *redisa.XMessageSliceCmd) {
	fake.xClaimMutex.Lock()
	defer fake.xClaimMutex.Unlock()
	fake.XClaimStub = stub
}

func (fake *FakeClient) XClaimArgsForCall(i int) (context.Context, *redisa.XClaimArgs) {
	fake.xClaimMutex.RLock()
	defer fake.xClaimMutex.RUnlock()
	argsForCall := fake.xClaimArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) XClaimReturns(result1 *redisa.XMessageSliceCmd) {
	fake.xClaimMutex.Lock()
	defer fake.xClaimMutex.Unlock()
	fake.XClaimStub = nil
	fake.xClaimReturns = struct {
		result1 *redisa.XMessageSliceCmd
	}{result1}
}

func (fake *FakeClient) XClaimReturnsOnCall(i int, result1 *redisa.XMessageSliceCmd) {
	fake.xClaimMutex.Lock()
	defer fake.xClaimMutex.Unlock()
	fake.XClaimStub = nil
	if fake.xClaimReturnsOnCall == nil {
		fake.xClaimReturnsOnCall = make(map[int]struct {
			result1 *redisa.XMessageSliceCmd
		})
	}
	fake.xClaimReturnsOnCall[i] = struct {
		result1 *redisa.XMessageSliceCmd
	}{result1}
}

func (fake *FakeClient) XClaimJustID(arg1 context.Context, arg2 *redisa.XClaimArgs) *redisa.StringSliceCmd {
	fake.xClaimJustIDMutex.Lock()
	ret, specificReturn := fake.xClaimJustIDReturnsOnCall[len(fake.xClaimJustIDArgsForCall)]
	fake.xClaimJustIDArgsForCall = append(fake.xClaimJustIDArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.XClaimArgs
	}{arg1, arg2})
	stub := fake.XClaimJustIDStub
	fakeReturns := fake.xClaimJustIDReturns
	fake.recordInvocation("XClaimJustID", []interface{}{arg1, arg2})
	fake.xClaimJustIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XClaimJustIDCallCount() int {
	fake.xClaimJustIDMutex.RLock()
	defer fake.xClaimJustIDMutex.RUnlock()
	return len(fake.xClaimJustIDArgsForCall)
}

func (fake *FakeClient) XClaimJustIDCalls(stub func(context.Context, *redisa.XClaimArgs) *redisa.StringSliceCmd) {
	fake.xClaimJustIDMutex.Lock()
	defer fake.xClaimJustIDMutex.Unlock()
	fake.XClaimJustIDStub = stub
}

func (fake *FakeClient) XClaimJustIDArgsForCall(i int) (context.Context, *redisa.XClaimArgs) {
	fake.xClaimJustIDMutex.RLock()
	defer fake.xClaimJustIDMutex.RUnlock()
	argsForCall := fake.xClaimJustIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) XClaimJustIDReturns(result1 *redisa.StringSliceCmd) {
	fake.xClaimJustIDMutex.Lock()
	defer fake.xClaimJustIDMutex.Unlock()
	fake.XClaimJustIDStub = nil
	fake.xClaimJustIDReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) XClaimJustIDReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.xClaimJustIDMutex.Lock()
	defer fake.xClaimJustIDMutex.Unlock()
	fake.XClaimJustIDStub = nil
	if fake.xClaimJustIDReturnsOnCall == nil {
		fake.xClaimJustIDReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.xClaimJustIDReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) XDel(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntCmd {
	fake.xDelMutex.Lock()
	ret, specificReturn := fake.xDelReturnsOnCall[len(fake.xDelArgsForCall)]
	fake.xDelArgsForCall = append(fake.xDelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.XDelStub
	fakeReturns := fake.xDelReturns
	fake.recordInvocation("XDel", []interface{}{arg1, arg2, arg3})
	fake.xDelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XDelCallCount() int {
	fake.xDelMutex.RLock()
	defer fake.xDelMutex.RUnlock()
	return len(fake.xDelArgsForCall)
}

func (fake *FakeClient) XDelCalls(stub func(context.Context, string, ...string) *redisa.IntCmd) {
	fake.xDelMutex.Lock()
	defer fake.xDelMutex.Unlock()
	fake.XDelStub = stub
}

func (fake *FakeClient) XDelArgsForCall(i int) (context.Context, string, []string) {
	fake.xDelMutex.RLock()
	defer fake.xDelMutex.RUnlock()
	argsForCall := fake.xDelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) XDelReturns(result1 *redisa.IntCmd) {
	fake.xDelMutex.Lock()
	defer fake.xDelMutex.Unlock()
	fake.XDelStub = nil
	fake.xDelReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XDelReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.xDelMutex.Lock()
	defer fake.xDelMutex.Unlock()
	fake.XDelStub = nil
	if fake.xDelReturnsOnCall == nil {
		fake.xDelReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.xDelReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XGroupCreate(arg1 context.Context, arg2 string, arg3 string, arg4 string) *redisa.StatusCmd {
	fake.xGroupCreateMutex.Lock()
	ret, specificReturn := fake.xGroupCreateReturnsOnCall[len(fake.xGroupCreateArgsForCall)]
	fake.xGroupCreateArgsForCall = append(fake.xGroupCreateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.XGroupCreateStub
	fakeReturns := fake.xGroupCreateReturns
	fake.recordInvocation("XGroupCreate", []interface{}{arg1, arg2, arg3, arg4})
	fake.xGroupCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XGroupCreateCallCount() int {
	fake.xGroupCreateMutex.RLock()
	defer fake.xGroupCreateMutex.RUnlock()
	return len(fake.xGroupCreateArgsForCall)
}

func (fake *FakeClient) XGroupCreateCalls(stub func(context.Context, string, string, string) *redisa.StatusCmd) {
	fake.xGroupCreateMutex.Lock()
	defer fake.xGroupCreateMutex.Unlock()
	fake.XGroupCreateStub = stub
}

func (fake *FakeClient) XGroupCreateArgsForCall(i int) (context.Context, string, string, string) {
	fake.xGroupCreateMutex.RLock()
	defer fake.xGroupCreateMutex.RUnlock()
	argsForCall := fake.xGroupCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) XGroupCreateReturns(result1 *redisa.StatusCmd) {
	fake.xGroupCreateMutex.Lock()
	defer fake.xGroupCreateMutex.Unlock()
	fake.XGroupCreateStub = nil
	fake.xGroupCreateReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) XGroupCreateReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.xGroupCreateMutex.Lock()
	defer fake.xGroupCreateMutex.Unlock()
	fake.XGroupCreateStub = nil
	if fake.xGroupCreateReturnsOnCall == nil {
		fake.xGroupCreateReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.xGroupCreateReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) XGroupCreateConsumer(arg1 context.Context, arg2 string, arg3 string, arg4 string) *redisa.IntCmd {
	fake.xGroupCreateConsumerMutex.Lock()
	ret, specificReturn := fake.xGroupCreateConsumerReturnsOnCall[len(fake.xGroupCreateConsumerArgsForCall)]
	fake.xGroupCreateConsumerArgsForCall = append(fake.xGroupCreateConsumerArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.XGroupCreateConsumerStub
	fakeReturns := fake.xGroupCreateConsumerReturns
	fake.recordInvocation("XGroupCreateConsumer", []interface{}{arg1, arg2, arg3, arg4})
	fake.xGroupCreateConsumerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XGroupCreateConsumerCallCount() int {
	fake.xGroupCreateConsumerMutex.RLock()
	defer fake.xGroupCreateConsumerMutex.RUnlock()
	return len(fake.xGroupCreateConsumerArgsForCall)
}

func (fake *FakeClient) XGroupCreateConsumerCalls(stub func(context.Context, string, string, string) *redisa.IntCmd) {
	fake.xGroupCreateConsumerMutex.Lock()
	defer fake.xGroupCreateConsumerMutex.Unlock()
	fake.XGroupCreateConsumerStub = stub
}

func (fake *FakeClient) XGroupCreateConsumerArgsForCall(i int) (context.Context, string, string, string) {
	fake.xGroupCreateConsumerMutex.RLock()
	defer fake.xGroupCreateConsumerMutex.RUnlock()
	argsForCall := fake.xGroupCreateConsumerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) XGroupCreateConsumerReturns(result1 *redisa.IntCmd) {
	fake.xGroupCreateConsumerMutex.Lock()
	defer fake.xGroupCreateConsumerMutex.Unlock()
	fake.XGroupCreateConsumerStub = nil
	fake.xGroupCreateConsumerReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XGroupCreateConsumerReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.xGroupCreateConsumerMutex.Lock()
	defer fake.xGroupCreateConsumerMutex.Unlock()
	fake.XGroupCreateConsumerStub = nil
	if fake.xGroupCreateConsumerReturnsOnCall == nil {
		fake.xGroupCreateConsumerReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.xGroupCreateConsumerReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XGroupCreateMkStream(arg1 context.Context, arg2 string, arg3 string, arg4 string) *redisa.StatusCmd {
	fake.xGroupCreateMkStreamMutex.Lock()
	ret, specificReturn := fake.xGroupCreateMkStreamReturnsOnCall[len(fake.xGroupCreateMkStreamArgsForCall)]
	fake.xGroupCreateMkStreamArgsForCall = append(fake.xGroupCreateMkStreamArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.XGroupCreateMkStreamStub
	fakeReturns := fake.xGroupCreateMkStreamReturns
	fake.recordInvocation("XGroupCreateMkStream", []interface{}{arg1, arg2, arg3, arg4})
	fake.xGroupCreateMkStreamMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XGroupCreateMkStreamCallCount() int {
	fake.xGroupCreateMkStreamMutex.RLock()
	defer fake.xGroupCreateMkStreamMutex.RUnlock()
	return len(fake.xGroupCreateMkStreamArgsForCall)
}

func (fake *FakeClient) XGroupCreateMkStreamCalls(stub func(context.Context, string, string, string) *redisa.StatusCmd) {
	fake.xGroupCreateMkStreamMutex.Lock()
	defer fake.xGroupCreateMkStreamMutex.Unlock()
	fake.XGroupCreateMkStreamStub = stub
}

func (fake *FakeClient) XGroupCreateMkStreamArgsForCall(i int) (context.Context, string, string, string) {
	fake.xGroupCreateMkStreamMutex.RLock()
	defer fake.xGroupCreateMkStreamMutex.RUnlock()
	argsForCall := fake.xGroupCreateMkStreamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) XGroupCreateMkStreamReturns(result1 *redisa.StatusCmd) {
	fake.xGroupCreateMkStreamMutex.Lock()
	defer fake.xGroupCreateMkStreamMutex.Unlock()
	fake.XGroupCreateMkStreamStub = nil
	fake.xGroupCreateMkStreamReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) XGroupCreateMkStreamReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.xGroupCreateMkStreamMutex.Lock()
	defer fake.xGroupCreateMkStreamMutex.Unlock()
	fake.XGroupCreateMkStreamStub = nil
	if fake.xGroupCreateMkStreamReturnsOnCall == nil {
		fake.xGroupCreateMkStreamReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.xGroupCreateMkStreamReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) XGroupDelConsumer(arg1 context.Context, arg2 string, arg3 string, arg4 string) *redisa.IntCmd {
	fake.xGroupDelConsumerMutex.Lock()
	ret, specificReturn := fake.xGroupDelConsumerReturnsOnCall[len(fake.xGroupDelConsumerArgsForCall)]
	fake.xGroupDelConsumerArgsForCall = append(fake.xGroupDelConsumerArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.XGroupDelConsumerStub
	fakeReturns := fake.xGroupDelConsumerReturns
	fake.recordInvocation("XGroupDelConsumer", []interface{}{arg1, arg2, arg3, arg4})
	fake.xGroupDelConsumerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XGroupDelConsumerCallCount() int {
	fake.xGroupDelConsumerMutex.RLock()
	defer fake.xGroupDelConsumerMutex.RUnlock()
	return len(fake.xGroupDelConsumerArgsForCall)
}

func (fake *FakeClient) XGroupDelConsumerCalls(stub func(context.Context, string, string, string) *redisa.IntCmd) {
	fake.xGroupDelConsumerMutex.Lock()
	defer fake.xGroupDelConsumerMutex.Unlock()
	fake.XGroupDelConsumerStub = stub
}

func (fake *FakeClient) XGroupDelConsumerArgsForCall(i int) (context.Context, string, string, string) {
	fake.xGroupDelConsumerMutex.RLock()
	defer fake.xGroupDelConsumerMutex.RUnlock()
	argsForCall := fake.xGroupDelConsumerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) XGroupDelConsumerReturns(result1 *redisa.IntCmd) {
	fake.xGroupDelConsumerMutex.Lock()
	defer fake.xGroupDelConsumerMutex.Unlock()
	fake.XGroupDelConsumerStub = nil
	fake.xGroupDelConsumerReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XGroupDelConsumerReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.xGroupDelConsumerMutex.Lock()
	defer fake.xGroupDelConsumerMutex.Unlock()
	fake.XGroupDelConsumerStub = nil
	if fake.xGroupDelConsumerReturnsOnCall == nil {
		fake.xGroupDelConsumerReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.xGroupDelConsumerReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XGroupDestroy(arg1 context.Context, arg2 string, arg3 string) *redisa.IntCmd {
	fake.xGroupDestroyMutex.Lock()
	ret, specificReturn := fake.xGroupDestroyReturnsOnCall[len(fake.xGroupDestroyArgsForCall)]
	fake.xGroupDestroyArgsForCall = append(fake.xGroupDestroyArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.XGroupDestroyStub
	fakeReturns := fake.xGroupDestroyReturns
	fake.recordInvocation("XGroupDestroy", []interface{}{arg1, arg2, arg3})
	fake.xGroupDestroyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XGroupDestroyCallCount() int {
	fake.xGroupDestroyMutex.RLock()
	defer fake.xGroupDestroyMutex.RUnlock()
	return len(fake.xGroupDestroyArgsForCall)
}

func (fake *FakeClient) XGroupDestroyCalls(stub func(context.Context, string, string) *redisa.IntCmd) {
	fake.xGroupDestroyMutex.Lock()
	defer fake.xGroupDestroyMutex.Unlock()
	fake.XGroupDestroyStub = stub
}

func (fake *FakeClient) XGroupDestroyArgsForCall(i int) (context.Context, string, string) {
	fake.xGroupDestroyMutex.RLock()
	defer fake.xGroupDestroyMutex.RUnlock()
	argsForCall := fake.xGroupDestroyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) XGroupDestroyReturns(result1 *redisa.IntCmd) {
	fake.xGroupDestroyMutex.Lock()
	defer fake.xGroupDestroyMutex.Unlock()
	fake.XGroupDestroyStub = nil
	fake.xGroupDestroyReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XGroupDestroyReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.xGroupDestroyMutex.Lock()
	defer fake.xGroupDestroyMutex.Unlock()
	fake.XGroupDestroyStub = nil
	if fake.xGroupDestroyReturnsOnCall == nil {
		fake.xGroupDestroyReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.xGroupDestroyReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XGroupSetID(arg1 context.Context, arg2 string, arg3 string, arg4 string) *redisa.StatusCmd {
	fake.xGroupSetIDMutex.Lock()
	ret, specificReturn := fake.xGroupSetIDReturnsOnCall[len(fake.xGroupSetIDArgsForCall)]
	fake.xGroupSetIDArgsForCall = append(fake.xGroupSetIDArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.XGroupSetIDStub
	fakeReturns := fake.xGroupSetIDReturns
	fake.recordInvocation("XGroupSetID", []interface{}{arg1, arg2, arg3, arg4})
	fake.xGroupSetIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XGroupSetIDCallCount() int {
	fake.xGroupSetIDMutex.RLock()
	defer fake.xGroupSetIDMutex.RUnlock()
	return len(fake.xGroupSetIDArgsForCall)
}

func (fake *FakeClient) XGroupSetIDCalls(stub func(context.Context, string, string, string) *redisa.StatusCmd) {
	fake.xGroupSetIDMutex.Lock()
	defer fake.xGroupSetIDMutex.Unlock()
	fake.XGroupSetIDStub = stub
}

func (fake *FakeClient) XGroupSetIDArgsForCall(i int) (context.Context, string, string, string) {
	fake.xGroupSetIDMutex.RLock()
	defer fake.xGroupSetIDMutex.RUnlock()
	argsForCall := fake.xGroupSetIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) XGroupSetIDReturns(result1 *redisa.StatusCmd) {
	fake.xGroupSetIDMutex.Lock()
	defer fake.xGroupSetIDMutex.Unlock()
	fake.XGroupSetIDStub = nil
	fake.xGroupSetIDReturns = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) XGroupSetIDReturnsOnCall(i int, result1 *redisa.StatusCmd) {
	fake.xGroupSetIDMutex.Lock()
	defer fake.xGroupSetIDMutex.Unlock()
	fake.XGroupSetIDStub = nil
	if fake.xGroupSetIDReturnsOnCall == nil {
		fake.xGroupSetIDReturnsOnCall = make(map[int]struct {
			result1 *redisa.StatusCmd
		})
	}
	fake.xGroupSetIDReturnsOnCall[i] = struct {
		result1 *redisa.StatusCmd
	}{result1}
}

func (fake *FakeClient) XInfoConsumers(arg1 context.Context, arg2 string, arg3 string) *redisa.XInfoConsumersCmd {
	fake.xInfoConsumersMutex.Lock()
	ret, specificReturn := fake.xInfoConsumersReturnsOnCall[len(fake.xInfoConsumersArgsForCall)]
	fake.xInfoConsumersArgsForCall = append(fake.xInfoConsumersArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.XInfoConsumersStub
	fakeReturns := fake.xInfoConsumersReturns
	fake.recordInvocation("XInfoConsumers", []interface{}{arg1, arg2, arg3})
	fake.xInfoConsumersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XInfoConsumersCallCount() int {
	fake.xInfoConsumersMutex.RLock()
	defer fake.xInfoConsumersMutex.RUnlock()
	return len(fake.xInfoConsumersArgsForCall)
}

func (fake *FakeClient) XInfoConsumersCalls(stub func(context.Context, string, string) *redisa.XInfoConsumersCmd) {
	fake.xInfoConsumersMutex.Lock()
	defer fake.xInfoConsumersMutex.Unlock()
	fake.XInfoConsumersStub = stub
}

func (fake *FakeClient) XInfoConsumersArgsForCall(i int) (context.Context, string, string) {
	fake.xInfoConsumersMutex.RLock()
	defer fake.xInfoConsumersMutex.RUnlock()
	argsForCall := fake.xInfoConsumersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) XInfoConsumersReturns(result1 *redisa.XInfoConsumersCmd) {
	fake.xInfoConsumersMutex.Lock()
	defer fake.xInfoConsumersMutex.Unlock()
	fake.XInfoConsumersStub = nil
	fake.xInfoConsumersReturns = struct {
		result1 *redisa.XInfoConsumersCmd
	}{result1}
}

func (fake *FakeClient) XInfoConsumersReturnsOnCall(i int, result1 *redisa.XInfoConsumersCmd) {
	fake.xInfoConsumersMutex.Lock()
	defer fake.xInfoConsumersMutex.Unlock()
	fake.XInfoConsumersStub = nil
	if fake.xInfoConsumersReturnsOnCall == nil {
		fake.xInfoConsumersReturnsOnCall = make(map[int]struct {
			result1 *redisa.XInfoConsumersCmd
		})
	}
	fake.xInfoConsumersReturnsOnCall[i] = struct {
		result1 *redisa.XInfoConsumersCmd
	}{result1}
}

func (fake *FakeClient) XInfoGroups(arg1 context.Context, arg2 string) *redisa.XInfoGroupsCmd {
	fake.xInfoGroupsMutex.Lock()
	ret, specificReturn := fake.xInfoGroupsReturnsOnCall[len(fake.xInfoGroupsArgsForCall)]
	fake.xInfoGroupsArgsForCall = append(fake.xInfoGroupsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.XInfoGroupsStub
	fakeReturns := fake.xInfoGroupsReturns
	fake.recordInvocation("XInfoGroups", []interface{}{arg1, arg2})
	fake.xInfoGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XInfoGroupsCallCount() int {
	fake.xInfoGroupsMutex.RLock()
	defer fake.xInfoGroupsMutex.RUnlock()
	return len(fake.xInfoGroupsArgsForCall)
}

func (fake *FakeClient) XInfoGroupsCalls(stub func(context.Context, string) *redisa.XInfoGroupsCmd) {
	fake.xInfoGroupsMutex.Lock()
	defer fake.xInfoGroupsMutex.Unlock()
	fake.XInfoGroupsStub = stub
}

func (fake *FakeClient) XInfoGroupsArgsForCall(i int) (context.Context, string) {
	fake.xInfoGroupsMutex.RLock()
	defer fake.xInfoGroupsMutex.RUnlock()
	argsForCall := fake.xInfoGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) XInfoGroupsReturns(result1 *redisa.XInfoGroupsCmd) {
	fake.xInfoGroupsMutex.Lock()
	defer fake.xInfoGroupsMutex.Unlock()
	fake.XInfoGroupsStub = nil
	fake.xInfoGroupsReturns = struct {
		result1 *redisa.XInfoGroupsCmd
	}{result1}
}

func (fake *FakeClient) XInfoGroupsReturnsOnCall(i int, result1 *redisa.XInfoGroupsCmd) {
	fake.xInfoGroupsMutex.Lock()
	defer fake.xInfoGroupsMutex.Unlock()
	fake.XInfoGroupsStub = nil
	if fake.xInfoGroupsReturnsOnCall == nil {
		fake.xInfoGroupsReturnsOnCall = make(map[int]struct {
			result1 *redisa.XInfoGroupsCmd
		})
	}
	fake.xInfoGroupsReturnsOnCall[i] = struct {
		result1 *redisa.XInfoGroupsCmd
	}{result1}
}

func (fake *FakeClient) XInfoStream(arg1 context.Context, arg2 string) *redisa.XInfoStreamCmd {
	fake.xInfoStreamMutex.Lock()
	ret, specificReturn := fake.xInfoStreamReturnsOnCall[len(fake.xInfoStreamArgsForCall)]
	fake.xInfoStreamArgsForCall = append(fake.xInfoStreamArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.XInfoStreamStub
	fakeReturns := fake.xInfoStreamReturns
	fake.recordInvocation("XInfoStream", []interface{}{arg1, arg2})
	fake.xInfoStreamMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XInfoStreamCallCount() int {
	fake.xInfoStreamMutex.RLock()
	defer fake.xInfoStreamMutex.RUnlock()
	return len(fake.xInfoStreamArgsForCall)
}

func (fake *FakeClient) XInfoStreamCalls(stub func(context.Context, string) *redisa.XInfoStreamCmd) {
	fake.xInfoStreamMutex.Lock()
	defer fake.xInfoStreamMutex.Unlock()
	fake.XInfoStreamStub = stub
}

func (fake *FakeClient) XInfoStreamArgsForCall(i int) (context.Context, string) {
	fake.xInfoStreamMutex.RLock()
	defer fake.xInfoStreamMutex.RUnlock()
	argsForCall := fake.xInfoStreamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) XInfoStreamReturns(result1 *redisa.XInfoStreamCmd) {
	fake.xInfoStreamMutex.Lock()
	defer fake.xInfoStreamMutex.Unlock()
	fake.XInfoStreamStub = nil
	fake.xInfoStreamReturns = struct {
		result1 *redisa.XInfoStreamCmd
	}{result1}
}

func (fake *FakeClient) XInfoStreamReturnsOnCall(i int, result1 *redisa.XInfoStreamCmd) {
	fake.xInfoStreamMutex.Lock()
	defer fake.xInfoStreamMutex.Unlock()
	fake.XInfoStreamStub = nil
	if fake.xInfoStreamReturnsOnCall == nil {
		fake.xInfoStreamReturnsOnCall = make(map[int]struct {
			result1 *redisa.XInfoStreamCmd
		})
	}
	fake.xInfoStreamReturnsOnCall[i] = struct {
		result1 *redisa.XInfoStreamCmd
	}{result1}
}

func (fake *FakeClient) XInfoStreamFull(arg1 context.Context, arg2 string, arg3 int) *redisa.XInfoStreamFullCmd {
	fake.xInfoStreamFullMutex.Lock()
	ret, specificReturn := fake.xInfoStreamFullReturnsOnCall[len(fake.xInfoStreamFullArgsForCall)]
	fake.xInfoStreamFullArgsForCall = append(fake.xInfoStreamFullArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.XInfoStreamFullStub
	fakeReturns := fake.xInfoStreamFullReturns
	fake.recordInvocation("XInfoStreamFull", []interface{}{arg1, arg2, arg3})
	fake.xInfoStreamFullMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XInfoStreamFullCallCount() int {
	fake.xInfoStreamFullMutex.RLock()
	defer fake.xInfoStreamFullMutex.RUnlock()
	return len(fake.xInfoStreamFullArgsForCall)
}

func (fake *FakeClient) XInfoStreamFullCalls(stub func(context.Context, string, int) *redisa.XInfoStreamFullCmd) {
	fake.xInfoStreamFullMutex.Lock()
	defer fake.xInfoStreamFullMutex.Unlock()
	fake.XInfoStreamFullStub = stub
}

func (fake *FakeClient) XInfoStreamFullArgsForCall(i int) (context.Context, string, int) {
	fake.xInfoStreamFullMutex.RLock()
	defer fake.xInfoStreamFullMutex.RUnlock()
	argsForCall := fake.xInfoStreamFullArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) XInfoStreamFullReturns(result1 *redisa.XInfoStreamFullCmd) {
	fake.xInfoStreamFullMutex.Lock()
	defer fake.xInfoStreamFullMutex.Unlock()
	fake.XInfoStreamFullStub = nil
	fake.xInfoStreamFullReturns = struct {
		result1 *redisa.XInfoStreamFullCmd
	}{result1}
}

func (fake *FakeClient) XInfoStreamFullReturnsOnCall(i int, result1 *redisa.XInfoStreamFullCmd) {
	fake.xInfoStreamFullMutex.Lock()
	defer fake.xInfoStreamFullMutex.Unlock()
	fake.XInfoStreamFullStub = nil
	if fake.xInfoStreamFullReturnsOnCall == nil {
		fake.xInfoStreamFullReturnsOnCall = make(map[int]struct {
			result1 *redisa.XInfoStreamFullCmd
		})
	}
	fake.xInfoStreamFullReturnsOnCall[i] = struct {
		result1 *redisa.XInfoStreamFullCmd
	}{result1}
}

func (fake *FakeClient) XLen(arg1 context.Context, arg2 string) *redisa.IntCmd {
	fake.xLenMutex.Lock()
	ret, specificReturn := fake.xLenReturnsOnCall[len(fake.xLenArgsForCall)]
	fake.xLenArgsForCall = append(fake.xLenArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.XLenStub
	fakeReturns := fake.xLenReturns
	fake.recordInvocation("XLen", []interface{}{arg1, arg2})
	fake.xLenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XLenCallCount() int {
	fake.xLenMutex.RLock()
	defer fake.xLenMutex.RUnlock()
	return len(fake.xLenArgsForCall)
}

func (fake *FakeClient) XLenCalls(stub func(context.Context, string) *redisa.IntCmd) {
	fake.xLenMutex.Lock()
	defer fake.xLenMutex.Unlock()
	fake.XLenStub = stub
}

func (fake *FakeClient) XLenArgsForCall(i int) (context.Context, string) {
	fake.xLenMutex.RLock()
	defer fake.xLenMutex.RUnlock()
	argsForCall := fake.xLenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) XLenReturns(result1 *redisa.IntCmd) {
	fake.xLenMutex.Lock()
	defer fake.xLenMutex.Unlock()
	fake.XLenStub = nil
	fake.xLenReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XLenReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.xLenMutex.Lock()
	defer fake.xLenMutex.Unlock()
	fake.XLenStub = nil
	if fake.xLenReturnsOnCall == nil {
		fake.xLenReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.xLenReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XPending(arg1 context.Context, arg2 string, arg3 string) *redisa.XPendingCmd {
	fake.xPendingMutex.Lock()
	ret, specificReturn := fake.xPendingReturnsOnCall[len(fake.xPendingArgsForCall)]
	fake.xPendingArgsForCall = append(fake.xPendingArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.XPendingStub
	fakeReturns := fake.xPendingReturns
	fake.recordInvocation("XPending", []interface{}{arg1, arg2, arg3})
	fake.xPendingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XPendingCallCount() int {
	fake.xPendingMutex.RLock()
	defer fake.xPendingMutex.RUnlock()
	return len(fake.xPendingArgsForCall)
}

func (fake *FakeClient) XPendingCalls(stub func(context.Context, string, string) *redisa.XPendingCmd) {
	fake.xPendingMutex.Lock()
	defer fake.xPendingMutex.Unlock()
	fake.XPendingStub = stub
}

func (fake *FakeClient) XPendingArgsForCall(i int) (context.Context, string, string) {
	fake.xPendingMutex.RLock()
	defer fake.xPendingMutex.RUnlock()
	argsForCall := fake.xPendingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) XPendingReturns(result1 *redisa.XPendingCmd) {
	fake.xPendingMutex.Lock()
	defer fake.xPendingMutex.Unlock()
	fake.XPendingStub = nil
	fake.xPendingReturns = struct {
		result1 *redisa.XPendingCmd
	}{result1}
}

func (fake *FakeClient) XPendingReturnsOnCall(i int, result1 *redisa.XPendingCmd) {
	fake.xPendingMutex.Lock()
	defer fake.xPendingMutex.Unlock()
	fake.XPendingStub = nil
	if fake.xPendingReturnsOnCall == nil {
		fake.xPendingReturnsOnCall = make(map[int]struct {
			result1 *redisa.XPendingCmd
		})
	}
	fake.xPendingReturnsOnCall[i] = struct {
		result1 *redisa.XPendingCmd
	}{result1}
}

func (fake *FakeClient) XPendingExt(arg1 context.Context, arg2 *redisa.XPendingExtArgs) *redisa.XPendingExtCmd {
	fake.xPendingExtMutex.Lock()
	ret, specificReturn := fake.xPendingExtReturnsOnCall[len(fake.xPendingExtArgsForCall)]
	fake.xPendingExtArgsForCall = append(fake.xPendingExtArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.XPendingExtArgs
	}{arg1, arg2})
	stub := fake.XPendingExtStub
	fakeReturns := fake.xPendingExtReturns
	fake.recordInvocation("XPendingExt", []interface{}{arg1, arg2})
	fake.xPendingExtMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XPendingExtCallCount() int {
	fake.xPendingExtMutex.RLock()
	defer fake.xPendingExtMutex.RUnlock()
	return len(fake.xPendingExtArgsForCall)
}

func (fake *FakeClient) XPendingExtCalls(stub func(context.Context, *redisa.XPendingExtArgs) *redisa.XPendingExtCmd) {
	fake.xPendingExtMutex.Lock()
	defer fake.xPendingExtMutex.Unlock()
	fake.XPendingExtStub = stub
}

func (fake *FakeClient) XPendingExtArgsForCall(i int) (context.Context, *redisa.XPendingExtArgs) {
	fake.xPendingExtMutex.RLock()
	defer fake.xPendingExtMutex.RUnlock()
	argsForCall := fake.xPendingExtArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) XPendingExtReturns(result1 *redisa.XPendingExtCmd) {
	fake.xPendingExtMutex.Lock()
	defer fake.xPendingExtMutex.Unlock()
	fake.XPendingExtStub = nil
	fake.xPendingExtReturns = struct {
		result1 *redisa.XPendingExtCmd
	}{result1}
}

func (fake *FakeClient) XPendingExtReturnsOnCall(i int, result1 *redisa.XPendingExtCmd) {
	fake.xPendingExtMutex.Lock()
	defer fake.xPendingExtMutex.Unlock()
	fake.XPendingExtStub = nil
	if fake.xPendingExtReturnsOnCall == nil {
		fake.xPendingExtReturnsOnCall = make(map[int]struct {
			result1 *redisa.XPendingExtCmd
		})
	}
	fake.xPendingExtReturnsOnCall[i] = struct {
		result1 *redisa.XPendingExtCmd
	}{result1}
}

func (fake *FakeClient) XRange(arg1 context.Context, arg2 string, arg3 string, arg4 string) *redisa.XMessageSliceCmd {
	fake.xRangeMutex.Lock()
	ret, specificReturn := fake.xRangeReturnsOnCall[len(fake.xRangeArgsForCall)]
	fake.xRangeArgsForCall = append(fake.xRangeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.XRangeStub
	fakeReturns := fake.xRangeReturns
	fake.recordInvocation("XRange", []interface{}{arg1, arg2, arg3, arg4})
	fake.xRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XRangeCallCount() int {
	fake.xRangeMutex.RLock()
	defer fake.xRangeMutex.RUnlock()
	return len(fake.xRangeArgsForCall)
}

func (fake *FakeClient) XRangeCalls(stub func(context.Context, string, string, string) *redisa.XMessageSliceCmd) {
	fake.xRangeMutex.Lock()
	defer fake.xRangeMutex.Unlock()
	fake.XRangeStub = stub
}

func (fake *FakeClient) XRangeArgsForCall(i int) (context.Context, string, string, string) {
	fake.xRangeMutex.RLock()
	defer fake.xRangeMutex.RUnlock()
	argsForCall := fake.xRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) XRangeReturns(result1 *redisa.XMessageSliceCmd) {
	fake.xRangeMutex.Lock()
	defer fake.xRangeMutex.Unlock()
	fake.XRangeStub = nil
	fake.xRangeReturns = struct {
		result1 *redisa.XMessageSliceCmd
	}{result1}
}

func (fake *FakeClient) XRangeReturnsOnCall(i int, result1 *redisa.XMessageSliceCmd) {
	fake.xRangeMutex.Lock()
	defer fake.xRangeMutex.Unlock()
	fake.XRangeStub = nil
	if fake.xRangeReturnsOnCall == nil {
		fake.xRangeReturnsOnCall = make(map[int]struct {
			result1 *redisa.XMessageSliceCmd
		})
	}
	fake.xRangeReturnsOnCall[i] = struct {
		result1 *redisa.XMessageSliceCmd
	}{result1}
}

func (fake *FakeClient) XRangeN(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 int64) *redisa.XMessageSliceCmd {
	fake.xRangeNMutex.Lock()
	ret, specificReturn := fake.xRangeNReturnsOnCall[len(fake.xRangeNArgsForCall)]
	fake.xRangeNArgsForCall = append(fake.xRangeNArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 int64
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.XRangeNStub
	fakeReturns := fake.xRangeNReturns
	fake.recordInvocation("XRangeN", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.xRangeNMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XRangeNCallCount() int {
	fake.xRangeNMutex.RLock()
	defer fake.xRangeNMutex.RUnlock()
	return len(fake.xRangeNArgsForCall)
}

func (fake *FakeClient) XRangeNCalls(stub func(context.Context, string, string, string, int64) *redisa.XMessageSliceCmd) {
	fake.xRangeNMutex.Lock()
	defer fake.xRangeNMutex.Unlock()
	fake.XRangeNStub = stub
}

func (fake *FakeClient) XRangeNArgsForCall(i int) (context.Context, string, string, string, int64) {
	fake.xRangeNMutex.RLock()
	defer fake.xRangeNMutex.RUnlock()
	argsForCall := fake.xRangeNArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) XRangeNReturns(result1 *redisa.XMessageSliceCmd) {
	fake.xRangeNMutex.Lock()
	defer fake.xRangeNMutex.Unlock()
	fake.XRangeNStub = nil
	fake.xRangeNReturns = struct {
		result1 *redisa.XMessageSliceCmd
	}{result1}
}

func (fake *FakeClient) XRangeNReturnsOnCall(i int, result1 *redisa.XMessageSliceCmd) {
	fake.xRangeNMutex.Lock()
	defer fake.xRangeNMutex.Unlock()
	fake.XRangeNStub = nil
	if fake.xRangeNReturnsOnCall == nil {
		fake.xRangeNReturnsOnCall = make(map[int]struct {
			result1 *redisa.XMessageSliceCmd
		})
	}
	fake.xRangeNReturnsOnCall[i] = struct {
		result1 *redisa.XMessageSliceCmd
	}{result1}
}

func (fake *FakeClient) XRead(arg1 context.Context, arg2 *redisa.XReadArgs) *redisa.XStreamSliceCmd {
	fake.xReadMutex.Lock()
	ret, specificReturn := fake.xReadReturnsOnCall[len(fake.xReadArgsForCall)]
	fake.xReadArgsForCall = append(fake.xReadArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.XReadArgs
	}{arg1, arg2})
	stub := fake.XReadStub
	fakeReturns := fake.xReadReturns
	fake.recordInvocation("XRead", []interface{}{arg1, arg2})
	fake.xReadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XReadCallCount() int {
	fake.xReadMutex.RLock()
	defer fake.xReadMutex.RUnlock()
	return len(fake.xReadArgsForCall)
}

func (fake *FakeClient) XReadCalls(stub func(context.Context, *redisa.XReadArgs) *redisa.XStreamSliceCmd) {
	fake.xReadMutex.Lock()
	defer fake.xReadMutex.Unlock()
	fake.XReadStub = stub
}

func (fake *FakeClient) XReadArgsForCall(i int) (context.Context, *redisa.XReadArgs) {
	fake.xReadMutex.RLock()
	defer fake.xReadMutex.RUnlock()
	argsForCall := fake.xReadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) XReadReturns(result1 *redisa.XStreamSliceCmd) {
	fake.xReadMutex.Lock()
	defer fake.xReadMutex.Unlock()
	fake.XReadStub = nil
	fake.xReadReturns = struct {
		result1 *redisa.XStreamSliceCmd
	}{result1}
}

func (fake *FakeClient) XReadReturnsOnCall(i int, result1 *redisa.XStreamSliceCmd) {
	fake.xReadMutex.Lock()
	defer fake.xReadMutex.Unlock()
	fake.XReadStub = nil
	if fake.xReadReturnsOnCall == nil {
		fake.xReadReturnsOnCall = make(map[int]struct {
			result1 *redisa.XStreamSliceCmd
		})
	}
	fake.xReadReturnsOnCall[i] = struct {
		result1 *redisa.XStreamSliceCmd
	}{result1}
}

func (fake *FakeClient) XReadGroup(arg1 context.Context, arg2 *redisa.XReadGroupArgs) *redisa.XStreamSliceCmd {
	fake.xReadGroupMutex.Lock()
	ret, specificReturn := fake.xReadGroupReturnsOnCall[len(fake.xReadGroupArgsForCall)]
	fake.xReadGroupArgsForCall = append(fake.xReadGroupArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.XReadGroupArgs
	}{arg1, arg2})
	stub := fake.XReadGroupStub
	fakeReturns := fake.xReadGroupReturns
	fake.recordInvocation("XReadGroup", []interface{}{arg1, arg2})
	fake.xReadGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XReadGroupCallCount() int {
	fake.xReadGroupMutex.RLock()
	defer fake.xReadGroupMutex.RUnlock()
	return len(fake.xReadGroupArgsForCall)
}

func (fake *FakeClient) XReadGroupCalls(stub func(context.Context, *redisa.XReadGroupArgs) *redisa.XStreamSliceCmd) {
	fake.xReadGroupMutex.Lock()
	defer fake.xReadGroupMutex.Unlock()
	fake.XReadGroupStub = stub
}

func (fake *FakeClient) XReadGroupArgsForCall(i int) (context.Context, *redisa.XReadGroupArgs) {
	fake.xReadGroupMutex.RLock()
	defer fake.xReadGroupMutex.RUnlock()
	argsForCall := fake.xReadGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) XReadGroupReturns(result1 *redisa.XStreamSliceCmd) {
	fake.xReadGroupMutex.Lock()
	defer fake.xReadGroupMutex.Unlock()
	fake.XReadGroupStub = nil
	fake.xReadGroupReturns = struct {
		result1 *redisa.XStreamSliceCmd
	}{result1}
}

func (fake *FakeClient) XReadGroupReturnsOnCall(i int, result1 *redisa.XStreamSliceCmd) {
	fake.xReadGroupMutex.Lock()
	defer fake.xReadGroupMutex.Unlock()
	fake.XReadGroupStub = nil
	if fake.xReadGroupReturnsOnCall == nil {
		fake.xReadGroupReturnsOnCall = make(map[int]struct {
			result1 *redisa.XStreamSliceCmd
		})
	}
	fake.xReadGroupReturnsOnCall[i] = struct {
		result1 *redisa.XStreamSliceCmd
	}{result1}
}

func (fake *FakeClient) XReadStreams(arg1 context.Context, arg2 ...string) *redisa.XStreamSliceCmd {
	fake.xReadStreamsMutex.Lock()
	ret, specificReturn := fake.xReadStreamsReturnsOnCall[len(fake.xReadStreamsArgsForCall)]
	fake.xReadStreamsArgsForCall = append(fake.xReadStreamsArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.XReadStreamsStub
	fakeReturns := fake.xReadStreamsReturns
	fake.recordInvocation("XReadStreams", []interface{}{arg1, arg2})
	fake.xReadStreamsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XReadStreamsCallCount() int {
	fake.xReadStreamsMutex.RLock()
	defer fake.xReadStreamsMutex.RUnlock()
	return len(fake.xReadStreamsArgsForCall)
}

func (fake *FakeClient) XReadStreamsCalls(stub func(context.Context, ...string) *redisa.XStreamSliceCmd) {
	fake.xReadStreamsMutex.Lock()
	defer fake.xReadStreamsMutex.Unlock()
	fake.XReadStreamsStub = stub
}

func (fake *FakeClient) XReadStreamsArgsForCall(i int) (context.Context, []string) {
	fake.xReadStreamsMutex.RLock()
	defer fake.xReadStreamsMutex.RUnlock()
	argsForCall := fake.xReadStreamsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) XReadStreamsReturns(result1 *redisa.XStreamSliceCmd) {
	fake.xReadStreamsMutex.Lock()
	defer fake.xReadStreamsMutex.Unlock()
	fake.XReadStreamsStub = nil
	fake.xReadStreamsReturns = struct {
		result1 *redisa.XStreamSliceCmd
	}{result1}
}

func (fake *FakeClient) XReadStreamsReturnsOnCall(i int, result1 *redisa.XStreamSliceCmd) {
	fake.xReadStreamsMutex.Lock()
	defer fake.xReadStreamsMutex.Unlock()
	fake.XReadStreamsStub = nil
	if fake.xReadStreamsReturnsOnCall == nil {
		fake.xReadStreamsReturnsOnCall = make(map[int]struct {
			result1 *redisa.XStreamSliceCmd
		})
	}
	fake.xReadStreamsReturnsOnCall[i] = struct {
		result1 *redisa.XStreamSliceCmd
	}{result1}
}

func (fake *FakeClient) XRevRange(arg1 context.Context, arg2 string, arg3 string, arg4 string) *redisa.XMessageSliceCmd {
	fake.xRevRangeMutex.Lock()
	ret, specificReturn := fake.xRevRangeReturnsOnCall[len(fake.xRevRangeArgsForCall)]
	fake.xRevRangeArgsForCall = append(fake.xRevRangeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.XRevRangeStub
	fakeReturns := fake.xRevRangeReturns
	fake.recordInvocation("XRevRange", []interface{}{arg1, arg2, arg3, arg4})
	fake.xRevRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XRevRangeCallCount() int {
	fake.xRevRangeMutex.RLock()
	defer fake.xRevRangeMutex.RUnlock()
	return len(fake.xRevRangeArgsForCall)
}

func (fake *FakeClient) XRevRangeCalls(stub func(context.Context, string, string, string) *redisa.XMessageSliceCmd) {
	fake.xRevRangeMutex.Lock()
	defer fake.xRevRangeMutex.Unlock()
	fake.XRevRangeStub = stub
}

func (fake *FakeClient) XRevRangeArgsForCall(i int) (context.Context, string, string, string) {
	fake.xRevRangeMutex.RLock()
	defer fake.xRevRangeMutex.RUnlock()
	argsForCall := fake.xRevRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) XRevRangeReturns(result1 *redisa.XMessageSliceCmd) {
	fake.xRevRangeMutex.Lock()
	defer fake.xRevRangeMutex.Unlock()
	fake.XRevRangeStub = nil
	fake.xRevRangeReturns = struct {
		result1 *redisa.XMessageSliceCmd
	}{result1}
}

func (fake *FakeClient) XRevRangeReturnsOnCall(i int, result1 *redisa.XMessageSliceCmd) {
	fake.xRevRangeMutex.Lock()
	defer fake.xRevRangeMutex.Unlock()
	fake.XRevRangeStub = nil
	if fake.xRevRangeReturnsOnCall == nil {
		fake.xRevRangeReturnsOnCall = make(map[int]struct {
			result1 *redisa.XMessageSliceCmd
		})
	}
	fake.xRevRangeReturnsOnCall[i] = struct {
		result1 *redisa.XMessageSliceCmd
	}{result1}
}

func (fake *FakeClient) XRevRangeN(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 int64) *redisa.XMessageSliceCmd {
	fake.xRevRangeNMutex.Lock()
	ret, specificReturn := fake.xRevRangeNReturnsOnCall[len(fake.xRevRangeNArgsForCall)]
	fake.xRevRangeNArgsForCall = append(fake.xRevRangeNArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 int64
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.XRevRangeNStub
	fakeReturns := fake.xRevRangeNReturns
	fake.recordInvocation("XRevRangeN", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.xRevRangeNMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XRevRangeNCallCount() int {
	fake.xRevRangeNMutex.RLock()
	defer fake.xRevRangeNMutex.RUnlock()
	return len(fake.xRevRangeNArgsForCall)
}

func (fake *FakeClient) XRevRangeNCalls(stub func(context.Context, string, string, string, int64) *redisa.XMessageSliceCmd) {
	fake.xRevRangeNMutex.Lock()
	defer fake.xRevRangeNMutex.Unlock()
	fake.XRevRangeNStub = stub
}

func (fake *FakeClient) XRevRangeNArgsForCall(i int) (context.Context, string, string, string, int64) {
	fake.xRevRangeNMutex.RLock()
	defer fake.xRevRangeNMutex.RUnlock()
	argsForCall := fake.xRevRangeNArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) XRevRangeNReturns(result1 *redisa.XMessageSliceCmd) {
	fake.xRevRangeNMutex.Lock()
	defer fake.xRevRangeNMutex.Unlock()
	fake.XRevRangeNStub = nil
	fake.xRevRangeNReturns = struct {
		result1 *redisa.XMessageSliceCmd
	}{result1}
}

func (fake *FakeClient) XRevRangeNReturnsOnCall(i int, result1 *redisa.XMessageSliceCmd) {
	fake.xRevRangeNMutex.Lock()
	defer fake.xRevRangeNMutex.Unlock()
	fake.XRevRangeNStub = nil
	if fake.xRevRangeNReturnsOnCall == nil {
		fake.xRevRangeNReturnsOnCall = make(map[int]struct {
			result1 *redisa.XMessageSliceCmd
		})
	}
	fake.xRevRangeNReturnsOnCall[i] = struct {
		result1 *redisa.XMessageSliceCmd
	}{result1}
}

func (fake *FakeClient) XTrimMaxLen(arg1 context.Context, arg2 string, arg3 int64) *redisa.IntCmd {
	fake.xTrimMaxLenMutex.Lock()
	ret, specificReturn := fake.xTrimMaxLenReturnsOnCall[len(fake.xTrimMaxLenArgsForCall)]
	fake.xTrimMaxLenArgsForCall = append(fake.xTrimMaxLenArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.XTrimMaxLenStub
	fakeReturns := fake.xTrimMaxLenReturns
	fake.recordInvocation("XTrimMaxLen", []interface{}{arg1, arg2, arg3})
	fake.xTrimMaxLenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XTrimMaxLenCallCount() int {
	fake.xTrimMaxLenMutex.RLock()
	defer fake.xTrimMaxLenMutex.RUnlock()
	return len(fake.xTrimMaxLenArgsForCall)
}

func (fake *FakeClient) XTrimMaxLenCalls(stub func(context.Context, string, int64) *redisa.IntCmd) {
	fake.xTrimMaxLenMutex.Lock()
	defer fake.xTrimMaxLenMutex.Unlock()
	fake.XTrimMaxLenStub = stub
}

func (fake *FakeClient) XTrimMaxLenArgsForCall(i int) (context.Context, string, int64) {
	fake.xTrimMaxLenMutex.RLock()
	defer fake.xTrimMaxLenMutex.RUnlock()
	argsForCall := fake.xTrimMaxLenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) XTrimMaxLenReturns(result1 *redisa.IntCmd) {
	fake.xTrimMaxLenMutex.Lock()
	defer fake.xTrimMaxLenMutex.Unlock()
	fake.XTrimMaxLenStub = nil
	fake.xTrimMaxLenReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XTrimMaxLenReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.xTrimMaxLenMutex.Lock()
	defer fake.xTrimMaxLenMutex.Unlock()
	fake.XTrimMaxLenStub = nil
	if fake.xTrimMaxLenReturnsOnCall == nil {
		fake.xTrimMaxLenReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.xTrimMaxLenReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XTrimMaxLenApprox(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) *redisa.IntCmd {
	fake.xTrimMaxLenApproxMutex.Lock()
	ret, specificReturn := fake.xTrimMaxLenApproxReturnsOnCall[len(fake.xTrimMaxLenApproxArgsForCall)]
	fake.xTrimMaxLenApproxArgsForCall = append(fake.xTrimMaxLenApproxArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.XTrimMaxLenApproxStub
	fakeReturns := fake.xTrimMaxLenApproxReturns
	fake.recordInvocation("XTrimMaxLenApprox", []interface{}{arg1, arg2, arg3, arg4})
	fake.xTrimMaxLenApproxMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XTrimMaxLenApproxCallCount() int {
	fake.xTrimMaxLenApproxMutex.RLock()
	defer fake.xTrimMaxLenApproxMutex.RUnlock()
	return len(fake.xTrimMaxLenApproxArgsForCall)
}

func (fake *FakeClient) XTrimMaxLenApproxCalls(stub func(context.Context, string, int64, int64) *redisa.IntCmd) {
	fake.xTrimMaxLenApproxMutex.Lock()
	defer fake.xTrimMaxLenApproxMutex.Unlock()
	fake.XTrimMaxLenApproxStub = stub
}

func (fake *FakeClient) XTrimMaxLenApproxArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.xTrimMaxLenApproxMutex.RLock()
	defer fake.xTrimMaxLenApproxMutex.RUnlock()
	argsForCall := fake.xTrimMaxLenApproxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) XTrimMaxLenApproxReturns(result1 *redisa.IntCmd) {
	fake.xTrimMaxLenApproxMutex.Lock()
	defer fake.xTrimMaxLenApproxMutex.Unlock()
	fake.XTrimMaxLenApproxStub = nil
	fake.xTrimMaxLenApproxReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XTrimMaxLenApproxReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.xTrimMaxLenApproxMutex.Lock()
	defer fake.xTrimMaxLenApproxMutex.Unlock()
	fake.XTrimMaxLenApproxStub = nil
	if fake.xTrimMaxLenApproxReturnsOnCall == nil {
		fake.xTrimMaxLenApproxReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.xTrimMaxLenApproxReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XTrimMinID(arg1 context.Context, arg2 string, arg3 string) *redisa.IntCmd {
	fake.xTrimMinIDMutex.Lock()
	ret, specificReturn := fake.xTrimMinIDReturnsOnCall[len(fake.xTrimMinIDArgsForCall)]
	fake.xTrimMinIDArgsForCall = append(fake.xTrimMinIDArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.XTrimMinIDStub
	fakeReturns := fake.xTrimMinIDReturns
	fake.recordInvocation("XTrimMinID", []interface{}{arg1, arg2, arg3})
	fake.xTrimMinIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XTrimMinIDCallCount() int {
	fake.xTrimMinIDMutex.RLock()
	defer fake.xTrimMinIDMutex.RUnlock()
	return len(fake.xTrimMinIDArgsForCall)
}

func (fake *FakeClient) XTrimMinIDCalls(stub func(context.Context, string, string) *redisa.IntCmd) {
	fake.xTrimMinIDMutex.Lock()
	defer fake.xTrimMinIDMutex.Unlock()
	fake.XTrimMinIDStub = stub
}

func (fake *FakeClient) XTrimMinIDArgsForCall(i int) (context.Context, string, string) {
	fake.xTrimMinIDMutex.RLock()
	defer fake.xTrimMinIDMutex.RUnlock()
	argsForCall := fake.xTrimMinIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) XTrimMinIDReturns(result1 *redisa.IntCmd) {
	fake.xTrimMinIDMutex.Lock()
	defer fake.xTrimMinIDMutex.Unlock()
	fake.XTrimMinIDStub = nil
	fake.xTrimMinIDReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XTrimMinIDReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.xTrimMinIDMutex.Lock()
	defer fake.xTrimMinIDMutex.Unlock()
	fake.XTrimMinIDStub = nil
	if fake.xTrimMinIDReturnsOnCall == nil {
		fake.xTrimMinIDReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.xTrimMinIDReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XTrimMinIDApprox(arg1 context.Context, arg2 string, arg3 string, arg4 int64) *redisa.IntCmd {
	fake.xTrimMinIDApproxMutex.Lock()
	ret, specificReturn := fake.xTrimMinIDApproxReturnsOnCall[len(fake.xTrimMinIDApproxArgsForCall)]
	fake.xTrimMinIDApproxArgsForCall = append(fake.xTrimMinIDApproxArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.XTrimMinIDApproxStub
	fakeReturns := fake.xTrimMinIDApproxReturns
	fake.recordInvocation("XTrimMinIDApprox", []interface{}{arg1, arg2, arg3, arg4})
	fake.xTrimMinIDApproxMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) XTrimMinIDApproxCallCount() int {
	fake.xTrimMinIDApproxMutex.RLock()
	defer fake.xTrimMinIDApproxMutex.RUnlock()
	return len(fake.xTrimMinIDApproxArgsForCall)
}

func (fake *FakeClient) XTrimMinIDApproxCalls(stub func(context.Context, string, string, int64) *redisa.IntCmd) {
	fake.xTrimMinIDApproxMutex.Lock()
	defer fake.xTrimMinIDApproxMutex.Unlock()
	fake.XTrimMinIDApproxStub = stub
}

func (fake *FakeClient) XTrimMinIDApproxArgsForCall(i int) (context.Context, string, string, int64) {
	fake.xTrimMinIDApproxMutex.RLock()
	defer fake.xTrimMinIDApproxMutex.RUnlock()
	argsForCall := fake.xTrimMinIDApproxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) XTrimMinIDApproxReturns(result1 *redisa.IntCmd) {
	fake.xTrimMinIDApproxMutex.Lock()
	defer fake.xTrimMinIDApproxMutex.Unlock()
	fake.XTrimMinIDApproxStub = nil
	fake.xTrimMinIDApproxReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) XTrimMinIDApproxReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.xTrimMinIDApproxMutex.Lock()
	defer fake.xTrimMinIDApproxMutex.Unlock()
	fake.XTrimMinIDApproxStub = nil
	if fake.xTrimMinIDApproxReturnsOnCall == nil {
		fake.xTrimMinIDApproxReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.xTrimMinIDApproxReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZAdd(arg1 context.Context, arg2 string, arg3 ...redisa.Z) *redisa.IntCmd {
	fake.zAddMutex.Lock()
	ret, specificReturn := fake.zAddReturnsOnCall[len(fake.zAddArgsForCall)]
	fake.zAddArgsForCall = append(fake.zAddArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []redisa.Z
	}{arg1, arg2, arg3})
	stub := fake.ZAddStub
	fakeReturns := fake.zAddReturns
	fake.recordInvocation("ZAdd", []interface{}{arg1, arg2, arg3})
	fake.zAddMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZAddCallCount() int {
	fake.zAddMutex.RLock()
	defer fake.zAddMutex.RUnlock()
	return len(fake.zAddArgsForCall)
}

func (fake *FakeClient) ZAddCalls(stub func(context.Context, string, ...redisa.Z) *redisa.IntCmd) {
	fake.zAddMutex.Lock()
	defer fake.zAddMutex.Unlock()
	fake.ZAddStub = stub
}

func (fake *FakeClient) ZAddArgsForCall(i int) (context.Context, string, []redisa.Z) {
	fake.zAddMutex.RLock()
	defer fake.zAddMutex.RUnlock()
	argsForCall := fake.zAddArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZAddReturns(result1 *redisa.IntCmd) {
	fake.zAddMutex.Lock()
	defer fake.zAddMutex.Unlock()
	fake.ZAddStub = nil
	fake.zAddReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZAddReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zAddMutex.Lock()
	defer fake.zAddMutex.Unlock()
	fake.ZAddStub = nil
	if fake.zAddReturnsOnCall == nil {
		fake.zAddReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zAddReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZAddArgs(arg1 context.Context, arg2 string, arg3 redisa.ZAddArgs) *redisa.IntCmd {
	fake.zAddArgsMutex.Lock()
	ret, specificReturn := fake.zAddArgsReturnsOnCall[len(fake.zAddArgsArgsForCall)]
	fake.zAddArgsArgsForCall = append(fake.zAddArgsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 redisa.ZAddArgs
	}{arg1, arg2, arg3})
	stub := fake.ZAddArgsStub
	fakeReturns := fake.zAddArgsReturns
	fake.recordInvocation("ZAddArgs", []interface{}{arg1, arg2, arg3})
	fake.zAddArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZAddArgsCallCount() int {
	fake.zAddArgsMutex.RLock()
	defer fake.zAddArgsMutex.RUnlock()
	return len(fake.zAddArgsArgsForCall)
}

func (fake *FakeClient) ZAddArgsCalls(stub func(context.Context, string, redisa.ZAddArgs) *redisa.IntCmd) {
	fake.zAddArgsMutex.Lock()
	defer fake.zAddArgsMutex.Unlock()
	fake.ZAddArgsStub = stub
}

func (fake *FakeClient) ZAddArgsArgsForCall(i int) (context.Context, string, redisa.ZAddArgs) {
	fake.zAddArgsMutex.RLock()
	defer fake.zAddArgsMutex.RUnlock()
	argsForCall := fake.zAddArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZAddArgsReturns(result1 *redisa.IntCmd) {
	fake.zAddArgsMutex.Lock()
	defer fake.zAddArgsMutex.Unlock()
	fake.ZAddArgsStub = nil
	fake.zAddArgsReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZAddArgsReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zAddArgsMutex.Lock()
	defer fake.zAddArgsMutex.Unlock()
	fake.ZAddArgsStub = nil
	if fake.zAddArgsReturnsOnCall == nil {
		fake.zAddArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zAddArgsReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZAddArgsIncr(arg1 context.Context, arg2 string, arg3 redisa.ZAddArgs) *redisa.FloatCmd {
	fake.zAddArgsIncrMutex.Lock()
	ret, specificReturn := fake.zAddArgsIncrReturnsOnCall[len(fake.zAddArgsIncrArgsForCall)]
	fake.zAddArgsIncrArgsForCall = append(fake.zAddArgsIncrArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 redisa.ZAddArgs
	}{arg1, arg2, arg3})
	stub := fake.ZAddArgsIncrStub
	fakeReturns := fake.zAddArgsIncrReturns
	fake.recordInvocation("ZAddArgsIncr", []interface{}{arg1, arg2, arg3})
	fake.zAddArgsIncrMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZAddArgsIncrCallCount() int {
	fake.zAddArgsIncrMutex.RLock()
	defer fake.zAddArgsIncrMutex.RUnlock()
	return len(fake.zAddArgsIncrArgsForCall)
}

func (fake *FakeClient) ZAddArgsIncrCalls(stub func(context.Context, string, redisa.ZAddArgs) *redisa.FloatCmd) {
	fake.zAddArgsIncrMutex.Lock()
	defer fake.zAddArgsIncrMutex.Unlock()
	fake.ZAddArgsIncrStub = stub
}

func (fake *FakeClient) ZAddArgsIncrArgsForCall(i int) (context.Context, string, redisa.ZAddArgs) {
	fake.zAddArgsIncrMutex.RLock()
	defer fake.zAddArgsIncrMutex.RUnlock()
	argsForCall := fake.zAddArgsIncrArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZAddArgsIncrReturns(result1 *redisa.FloatCmd) {
	fake.zAddArgsIncrMutex.Lock()
	defer fake.zAddArgsIncrMutex.Unlock()
	fake.ZAddArgsIncrStub = nil
	fake.zAddArgsIncrReturns = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) ZAddArgsIncrReturnsOnCall(i int, result1 *redisa.FloatCmd) {
	fake.zAddArgsIncrMutex.Lock()
	defer fake.zAddArgsIncrMutex.Unlock()
	fake.ZAddArgsIncrStub = nil
	if fake.zAddArgsIncrReturnsOnCall == nil {
		fake.zAddArgsIncrReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatCmd
		})
	}
	fake.zAddArgsIncrReturnsOnCall[i] = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) ZAddGT(arg1 context.Context, arg2 string, arg3 ...redisa.Z) *redisa.IntCmd {
	fake.zAddGTMutex.Lock()
	ret, specificReturn := fake.zAddGTReturnsOnCall[len(fake.zAddGTArgsForCall)]
	fake.zAddGTArgsForCall = append(fake.zAddGTArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []redisa.Z
	}{arg1, arg2, arg3})
	stub := fake.ZAddGTStub
	fakeReturns := fake.zAddGTReturns
	fake.recordInvocation("ZAddGT", []interface{}{arg1, arg2, arg3})
	fake.zAddGTMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZAddGTCallCount() int {
	fake.zAddGTMutex.RLock()
	defer fake.zAddGTMutex.RUnlock()
	return len(fake.zAddGTArgsForCall)
}

func (fake *FakeClient) ZAddGTCalls(stub func(context.Context, string, ...redisa.Z) *redisa.IntCmd) {
	fake.zAddGTMutex.Lock()
	defer fake.zAddGTMutex.Unlock()
	fake.ZAddGTStub = stub
}

func (fake *FakeClient) ZAddGTArgsForCall(i int) (context.Context, string, []redisa.Z) {
	fake.zAddGTMutex.RLock()
	defer fake.zAddGTMutex.RUnlock()
	argsForCall := fake.zAddGTArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZAddGTReturns(result1 *redisa.IntCmd) {
	fake.zAddGTMutex.Lock()
	defer fake.zAddGTMutex.Unlock()
	fake.ZAddGTStub = nil
	fake.zAddGTReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZAddGTReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zAddGTMutex.Lock()
	defer fake.zAddGTMutex.Unlock()
	fake.ZAddGTStub = nil
	if fake.zAddGTReturnsOnCall == nil {
		fake.zAddGTReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zAddGTReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZAddLT(arg1 context.Context, arg2 string, arg3 ...redisa.Z) *redisa.IntCmd {
	fake.zAddLTMutex.Lock()
	ret, specificReturn := fake.zAddLTReturnsOnCall[len(fake.zAddLTArgsForCall)]
	fake.zAddLTArgsForCall = append(fake.zAddLTArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []redisa.Z
	}{arg1, arg2, arg3})
	stub := fake.ZAddLTStub
	fakeReturns := fake.zAddLTReturns
	fake.recordInvocation("ZAddLT", []interface{}{arg1, arg2, arg3})
	fake.zAddLTMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZAddLTCallCount() int {
	fake.zAddLTMutex.RLock()
	defer fake.zAddLTMutex.RUnlock()
	return len(fake.zAddLTArgsForCall)
}

func (fake *FakeClient) ZAddLTCalls(stub func(context.Context, string, ...redisa.Z) *redisa.IntCmd) {
	fake.zAddLTMutex.Lock()
	defer fake.zAddLTMutex.Unlock()
	fake.ZAddLTStub = stub
}

func (fake *FakeClient) ZAddLTArgsForCall(i int) (context.Context, string, []redisa.Z) {
	fake.zAddLTMutex.RLock()
	defer fake.zAddLTMutex.RUnlock()
	argsForCall := fake.zAddLTArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZAddLTReturns(result1 *redisa.IntCmd) {
	fake.zAddLTMutex.Lock()
	defer fake.zAddLTMutex.Unlock()
	fake.ZAddLTStub = nil
	fake.zAddLTReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZAddLTReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zAddLTMutex.Lock()
	defer fake.zAddLTMutex.Unlock()
	fake.ZAddLTStub = nil
	if fake.zAddLTReturnsOnCall == nil {
		fake.zAddLTReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zAddLTReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZAddNX(arg1 context.Context, arg2 string, arg3 ...redisa.Z) *redisa.IntCmd {
	fake.zAddNXMutex.Lock()
	ret, specificReturn := fake.zAddNXReturnsOnCall[len(fake.zAddNXArgsForCall)]
	fake.zAddNXArgsForCall = append(fake.zAddNXArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []redisa.Z
	}{arg1, arg2, arg3})
	stub := fake.ZAddNXStub
	fakeReturns := fake.zAddNXReturns
	fake.recordInvocation("ZAddNX", []interface{}{arg1, arg2, arg3})
	fake.zAddNXMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZAddNXCallCount() int {
	fake.zAddNXMutex.RLock()
	defer fake.zAddNXMutex.RUnlock()
	return len(fake.zAddNXArgsForCall)
}

func (fake *FakeClient) ZAddNXCalls(stub func(context.Context, string, ...redisa.Z) *redisa.IntCmd) {
	fake.zAddNXMutex.Lock()
	defer fake.zAddNXMutex.Unlock()
	fake.ZAddNXStub = stub
}

func (fake *FakeClient) ZAddNXArgsForCall(i int) (context.Context, string, []redisa.Z) {
	fake.zAddNXMutex.RLock()
	defer fake.zAddNXMutex.RUnlock()
	argsForCall := fake.zAddNXArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZAddNXReturns(result1 *redisa.IntCmd) {
	fake.zAddNXMutex.Lock()
	defer fake.zAddNXMutex.Unlock()
	fake.ZAddNXStub = nil
	fake.zAddNXReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZAddNXReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zAddNXMutex.Lock()
	defer fake.zAddNXMutex.Unlock()
	fake.ZAddNXStub = nil
	if fake.zAddNXReturnsOnCall == nil {
		fake.zAddNXReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zAddNXReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZAddXX(arg1 context.Context, arg2 string, arg3 ...redisa.Z) *redisa.IntCmd {
	fake.zAddXXMutex.Lock()
	ret, specificReturn := fake.zAddXXReturnsOnCall[len(fake.zAddXXArgsForCall)]
	fake.zAddXXArgsForCall = append(fake.zAddXXArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []redisa.Z
	}{arg1, arg2, arg3})
	stub := fake.ZAddXXStub
	fakeReturns := fake.zAddXXReturns
	fake.recordInvocation("ZAddXX", []interface{}{arg1, arg2, arg3})
	fake.zAddXXMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZAddXXCallCount() int {
	fake.zAddXXMutex.RLock()
	defer fake.zAddXXMutex.RUnlock()
	return len(fake.zAddXXArgsForCall)
}

func (fake *FakeClient) ZAddXXCalls(stub func(context.Context, string, ...redisa.Z) *redisa.IntCmd) {
	fake.zAddXXMutex.Lock()
	defer fake.zAddXXMutex.Unlock()
	fake.ZAddXXStub = stub
}

func (fake *FakeClient) ZAddXXArgsForCall(i int) (context.Context, string, []redisa.Z) {
	fake.zAddXXMutex.RLock()
	defer fake.zAddXXMutex.RUnlock()
	argsForCall := fake.zAddXXArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZAddXXReturns(result1 *redisa.IntCmd) {
	fake.zAddXXMutex.Lock()
	defer fake.zAddXXMutex.Unlock()
	fake.ZAddXXStub = nil
	fake.zAddXXReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZAddXXReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zAddXXMutex.Lock()
	defer fake.zAddXXMutex.Unlock()
	fake.ZAddXXStub = nil
	if fake.zAddXXReturnsOnCall == nil {
		fake.zAddXXReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zAddXXReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZCard(arg1 context.Context, arg2 string) *redisa.IntCmd {
	fake.zCardMutex.Lock()
	ret, specificReturn := fake.zCardReturnsOnCall[len(fake.zCardArgsForCall)]
	fake.zCardArgsForCall = append(fake.zCardArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ZCardStub
	fakeReturns := fake.zCardReturns
	fake.recordInvocation("ZCard", []interface{}{arg1, arg2})
	fake.zCardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZCardCallCount() int {
	fake.zCardMutex.RLock()
	defer fake.zCardMutex.RUnlock()
	return len(fake.zCardArgsForCall)
}

func (fake *FakeClient) ZCardCalls(stub func(context.Context, string) *redisa.IntCmd) {
	fake.zCardMutex.Lock()
	defer fake.zCardMutex.Unlock()
	fake.ZCardStub = stub
}

func (fake *FakeClient) ZCardArgsForCall(i int) (context.Context, string) {
	fake.zCardMutex.RLock()
	defer fake.zCardMutex.RUnlock()
	argsForCall := fake.zCardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ZCardReturns(result1 *redisa.IntCmd) {
	fake.zCardMutex.Lock()
	defer fake.zCardMutex.Unlock()
	fake.ZCardStub = nil
	fake.zCardReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZCardReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zCardMutex.Lock()
	defer fake.zCardMutex.Unlock()
	fake.ZCardStub = nil
	if fake.zCardReturnsOnCall == nil {
		fake.zCardReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zCardReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZCount(arg1 context.Context, arg2 string, arg3 string, arg4 string) *redisa.IntCmd {
	fake.zCountMutex.Lock()
	ret, specificReturn := fake.zCountReturnsOnCall[len(fake.zCountArgsForCall)]
	fake.zCountArgsForCall = append(fake.zCountArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ZCountStub
	fakeReturns := fake.zCountReturns
	fake.recordInvocation("ZCount", []interface{}{arg1, arg2, arg3, arg4})
	fake.zCountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZCountCallCount() int {
	fake.zCountMutex.RLock()
	defer fake.zCountMutex.RUnlock()
	return len(fake.zCountArgsForCall)
}

func (fake *FakeClient) ZCountCalls(stub func(context.Context, string, string, string) *redisa.IntCmd) {
	fake.zCountMutex.Lock()
	defer fake.zCountMutex.Unlock()
	fake.ZCountStub = stub
}

func (fake *FakeClient) ZCountArgsForCall(i int) (context.Context, string, string, string) {
	fake.zCountMutex.RLock()
	defer fake.zCountMutex.RUnlock()
	argsForCall := fake.zCountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ZCountReturns(result1 *redisa.IntCmd) {
	fake.zCountMutex.Lock()
	defer fake.zCountMutex.Unlock()
	fake.ZCountStub = nil
	fake.zCountReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZCountReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zCountMutex.Lock()
	defer fake.zCountMutex.Unlock()
	fake.ZCountStub = nil
	if fake.zCountReturnsOnCall == nil {
		fake.zCountReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zCountReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZDiff(arg1 context.Context, arg2 ...string) *redisa.StringSliceCmd {
	fake.zDiffMutex.Lock()
	ret, specificReturn := fake.zDiffReturnsOnCall[len(fake.zDiffArgsForCall)]
	fake.zDiffArgsForCall = append(fake.zDiffArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.ZDiffStub
	fakeReturns := fake.zDiffReturns
	fake.recordInvocation("ZDiff", []interface{}{arg1, arg2})
	fake.zDiffMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZDiffCallCount() int {
	fake.zDiffMutex.RLock()
	defer fake.zDiffMutex.RUnlock()
	return len(fake.zDiffArgsForCall)
}

func (fake *FakeClient) ZDiffCalls(stub func(context.Context, ...string) *redisa.StringSliceCmd) {
	fake.zDiffMutex.Lock()
	defer fake.zDiffMutex.Unlock()
	fake.ZDiffStub = stub
}

func (fake *FakeClient) ZDiffArgsForCall(i int) (context.Context, []string) {
	fake.zDiffMutex.RLock()
	defer fake.zDiffMutex.RUnlock()
	argsForCall := fake.zDiffArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ZDiffReturns(result1 *redisa.StringSliceCmd) {
	fake.zDiffMutex.Lock()
	defer fake.zDiffMutex.Unlock()
	fake.ZDiffStub = nil
	fake.zDiffReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZDiffReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.zDiffMutex.Lock()
	defer fake.zDiffMutex.Unlock()
	fake.ZDiffStub = nil
	if fake.zDiffReturnsOnCall == nil {
		fake.zDiffReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.zDiffReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZDiffStore(arg1 context.Context, arg2 string, arg3 ...string) *redisa.IntCmd {
	fake.zDiffStoreMutex.Lock()
	ret, specificReturn := fake.zDiffStoreReturnsOnCall[len(fake.zDiffStoreArgsForCall)]
	fake.zDiffStoreArgsForCall = append(fake.zDiffStoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.ZDiffStoreStub
	fakeReturns := fake.zDiffStoreReturns
	fake.recordInvocation("ZDiffStore", []interface{}{arg1, arg2, arg3})
	fake.zDiffStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZDiffStoreCallCount() int {
	fake.zDiffStoreMutex.RLock()
	defer fake.zDiffStoreMutex.RUnlock()
	return len(fake.zDiffStoreArgsForCall)
}

func (fake *FakeClient) ZDiffStoreCalls(stub func(context.Context, string, ...string) *redisa.IntCmd) {
	fake.zDiffStoreMutex.Lock()
	defer fake.zDiffStoreMutex.Unlock()
	fake.ZDiffStoreStub = stub
}

func (fake *FakeClient) ZDiffStoreArgsForCall(i int) (context.Context, string, []string) {
	fake.zDiffStoreMutex.RLock()
	defer fake.zDiffStoreMutex.RUnlock()
	argsForCall := fake.zDiffStoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZDiffStoreReturns(result1 *redisa.IntCmd) {
	fake.zDiffStoreMutex.Lock()
	defer fake.zDiffStoreMutex.Unlock()
	fake.ZDiffStoreStub = nil
	fake.zDiffStoreReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZDiffStoreReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zDiffStoreMutex.Lock()
	defer fake.zDiffStoreMutex.Unlock()
	fake.ZDiffStoreStub = nil
	if fake.zDiffStoreReturnsOnCall == nil {
		fake.zDiffStoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zDiffStoreReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZDiffWithScores(arg1 context.Context, arg2 ...string) *redisa.ZSliceCmd {
	fake.zDiffWithScoresMutex.Lock()
	ret, specificReturn := fake.zDiffWithScoresReturnsOnCall[len(fake.zDiffWithScoresArgsForCall)]
	fake.zDiffWithScoresArgsForCall = append(fake.zDiffWithScoresArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.ZDiffWithScoresStub
	fakeReturns := fake.zDiffWithScoresReturns
	fake.recordInvocation("ZDiffWithScores", []interface{}{arg1, arg2})
	fake.zDiffWithScoresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZDiffWithScoresCallCount() int {
	fake.zDiffWithScoresMutex.RLock()
	defer fake.zDiffWithScoresMutex.RUnlock()
	return len(fake.zDiffWithScoresArgsForCall)
}

func (fake *FakeClient) ZDiffWithScoresCalls(stub func(context.Context, ...string) *redisa.ZSliceCmd) {
	fake.zDiffWithScoresMutex.Lock()
	defer fake.zDiffWithScoresMutex.Unlock()
	fake.ZDiffWithScoresStub = stub
}

func (fake *FakeClient) ZDiffWithScoresArgsForCall(i int) (context.Context, []string) {
	fake.zDiffWithScoresMutex.RLock()
	defer fake.zDiffWithScoresMutex.RUnlock()
	argsForCall := fake.zDiffWithScoresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ZDiffWithScoresReturns(result1 *redisa.ZSliceCmd) {
	fake.zDiffWithScoresMutex.Lock()
	defer fake.zDiffWithScoresMutex.Unlock()
	fake.ZDiffWithScoresStub = nil
	fake.zDiffWithScoresReturns = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZDiffWithScoresReturnsOnCall(i int, result1 *redisa.ZSliceCmd) {
	fake.zDiffWithScoresMutex.Lock()
	defer fake.zDiffWithScoresMutex.Unlock()
	fake.ZDiffWithScoresStub = nil
	if fake.zDiffWithScoresReturnsOnCall == nil {
		fake.zDiffWithScoresReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZSliceCmd
		})
	}
	fake.zDiffWithScoresReturnsOnCall[i] = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZIncrBy(arg1 context.Context, arg2 string, arg3 float64, arg4 string) *redisa.FloatCmd {
	fake.zIncrByMutex.Lock()
	ret, specificReturn := fake.zIncrByReturnsOnCall[len(fake.zIncrByArgsForCall)]
	fake.zIncrByArgsForCall = append(fake.zIncrByArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 float64
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ZIncrByStub
	fakeReturns := fake.zIncrByReturns
	fake.recordInvocation("ZIncrBy", []interface{}{arg1, arg2, arg3, arg4})
	fake.zIncrByMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZIncrByCallCount() int {
	fake.zIncrByMutex.RLock()
	defer fake.zIncrByMutex.RUnlock()
	return len(fake.zIncrByArgsForCall)
}

func (fake *FakeClient) ZIncrByCalls(stub func(context.Context, string, float64, string) *redisa.FloatCmd) {
	fake.zIncrByMutex.Lock()
	defer fake.zIncrByMutex.Unlock()
	fake.ZIncrByStub = stub
}

func (fake *FakeClient) ZIncrByArgsForCall(i int) (context.Context, string, float64, string) {
	fake.zIncrByMutex.RLock()
	defer fake.zIncrByMutex.RUnlock()
	argsForCall := fake.zIncrByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ZIncrByReturns(result1 *redisa.FloatCmd) {
	fake.zIncrByMutex.Lock()
	defer fake.zIncrByMutex.Unlock()
	fake.ZIncrByStub = nil
	fake.zIncrByReturns = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) ZIncrByReturnsOnCall(i int, result1 *redisa.FloatCmd) {
	fake.zIncrByMutex.Lock()
	defer fake.zIncrByMutex.Unlock()
	fake.ZIncrByStub = nil
	if fake.zIncrByReturnsOnCall == nil {
		fake.zIncrByReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatCmd
		})
	}
	fake.zIncrByReturnsOnCall[i] = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) ZInter(arg1 context.Context, arg2 *redisa.ZStore) *redisa.StringSliceCmd {
	fake.zInterMutex.Lock()
	ret, specificReturn := fake.zInterReturnsOnCall[len(fake.zInterArgsForCall)]
	fake.zInterArgsForCall = append(fake.zInterArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.ZStore
	}{arg1, arg2})
	stub := fake.ZInterStub
	fakeReturns := fake.zInterReturns
	fake.recordInvocation("ZInter", []interface{}{arg1, arg2})
	fake.zInterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZInterCallCount() int {
	fake.zInterMutex.RLock()
	defer fake.zInterMutex.RUnlock()
	return len(fake.zInterArgsForCall)
}

func (fake *FakeClient) ZInterCalls(stub func(context.Context, *redisa.ZStore) *redisa.StringSliceCmd) {
	fake.zInterMutex.Lock()
	defer fake.zInterMutex.Unlock()
	fake.ZInterStub = stub
}

func (fake *FakeClient) ZInterArgsForCall(i int) (context.Context, *redisa.ZStore) {
	fake.zInterMutex.RLock()
	defer fake.zInterMutex.RUnlock()
	argsForCall := fake.zInterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ZInterReturns(result1 *redisa.StringSliceCmd) {
	fake.zInterMutex.Lock()
	defer fake.zInterMutex.Unlock()
	fake.ZInterStub = nil
	fake.zInterReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZInterReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.zInterMutex.Lock()
	defer fake.zInterMutex.Unlock()
	fake.ZInterStub = nil
	if fake.zInterReturnsOnCall == nil {
		fake.zInterReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.zInterReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZInterCard(arg1 context.Context, arg2 int64, arg3 ...string) *redisa.IntCmd {
	fake.zInterCardMutex.Lock()
	ret, specificReturn := fake.zInterCardReturnsOnCall[len(fake.zInterCardArgsForCall)]
	fake.zInterCardArgsForCall = append(fake.zInterCardArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.ZInterCardStub
	fakeReturns := fake.zInterCardReturns
	fake.recordInvocation("ZInterCard", []interface{}{arg1, arg2, arg3})
	fake.zInterCardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZInterCardCallCount() int {
	fake.zInterCardMutex.RLock()
	defer fake.zInterCardMutex.RUnlock()
	return len(fake.zInterCardArgsForCall)
}

func (fake *FakeClient) ZInterCardCalls(stub func(context.Context, int64, ...string) *redisa.IntCmd) {
	fake.zInterCardMutex.Lock()
	defer fake.zInterCardMutex.Unlock()
	fake.ZInterCardStub = stub
}

func (fake *FakeClient) ZInterCardArgsForCall(i int) (context.Context, int64, []string) {
	fake.zInterCardMutex.RLock()
	defer fake.zInterCardMutex.RUnlock()
	argsForCall := fake.zInterCardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZInterCardReturns(result1 *redisa.IntCmd) {
	fake.zInterCardMutex.Lock()
	defer fake.zInterCardMutex.Unlock()
	fake.ZInterCardStub = nil
	fake.zInterCardReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZInterCardReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zInterCardMutex.Lock()
	defer fake.zInterCardMutex.Unlock()
	fake.ZInterCardStub = nil
	if fake.zInterCardReturnsOnCall == nil {
		fake.zInterCardReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zInterCardReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZInterStore(arg1 context.Context, arg2 string, arg3 *redisa.ZStore) *redisa.IntCmd {
	fake.zInterStoreMutex.Lock()
	ret, specificReturn := fake.zInterStoreReturnsOnCall[len(fake.zInterStoreArgsForCall)]
	fake.zInterStoreArgsForCall = append(fake.zInterStoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZStore
	}{arg1, arg2, arg3})
	stub := fake.ZInterStoreStub
	fakeReturns := fake.zInterStoreReturns
	fake.recordInvocation("ZInterStore", []interface{}{arg1, arg2, arg3})
	fake.zInterStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZInterStoreCallCount() int {
	fake.zInterStoreMutex.RLock()
	defer fake.zInterStoreMutex.RUnlock()
	return len(fake.zInterStoreArgsForCall)
}

func (fake *FakeClient) ZInterStoreCalls(stub func(context.Context, string, *redisa.ZStore) *redisa.IntCmd) {
	fake.zInterStoreMutex.Lock()
	defer fake.zInterStoreMutex.Unlock()
	fake.ZInterStoreStub = stub
}

func (fake *FakeClient) ZInterStoreArgsForCall(i int) (context.Context, string, *redisa.ZStore) {
	fake.zInterStoreMutex.RLock()
	defer fake.zInterStoreMutex.RUnlock()
	argsForCall := fake.zInterStoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZInterStoreReturns(result1 *redisa.IntCmd) {
	fake.zInterStoreMutex.Lock()
	defer fake.zInterStoreMutex.Unlock()
	fake.ZInterStoreStub = nil
	fake.zInterStoreReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZInterStoreReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zInterStoreMutex.Lock()
	defer fake.zInterStoreMutex.Unlock()
	fake.ZInterStoreStub = nil
	if fake.zInterStoreReturnsOnCall == nil {
		fake.zInterStoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zInterStoreReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZInterWithScores(arg1 context.Context, arg2 *redisa.ZStore) *redisa.ZSliceCmd {
	fake.zInterWithScoresMutex.Lock()
	ret, specificReturn := fake.zInterWithScoresReturnsOnCall[len(fake.zInterWithScoresArgsForCall)]
	fake.zInterWithScoresArgsForCall = append(fake.zInterWithScoresArgsForCall, struct {
		arg1 context.Context
		arg2 *redisa.ZStore
	}{arg1, arg2})
	stub := fake.ZInterWithScoresStub
	fakeReturns := fake.zInterWithScoresReturns
	fake.recordInvocation("ZInterWithScores", []interface{}{arg1, arg2})
	fake.zInterWithScoresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZInterWithScoresCallCount() int {
	fake.zInterWithScoresMutex.RLock()
	defer fake.zInterWithScoresMutex.RUnlock()
	return len(fake.zInterWithScoresArgsForCall)
}

func (fake *FakeClient) ZInterWithScoresCalls(stub func(context.Context, *redisa.ZStore) *redisa.ZSliceCmd) {
	fake.zInterWithScoresMutex.Lock()
	defer fake.zInterWithScoresMutex.Unlock()
	fake.ZInterWithScoresStub = stub
}

func (fake *FakeClient) ZInterWithScoresArgsForCall(i int) (context.Context, *redisa.ZStore) {
	fake.zInterWithScoresMutex.RLock()
	defer fake.zInterWithScoresMutex.RUnlock()
	argsForCall := fake.zInterWithScoresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ZInterWithScoresReturns(result1 *redisa.ZSliceCmd) {
	fake.zInterWithScoresMutex.Lock()
	defer fake.zInterWithScoresMutex.Unlock()
	fake.ZInterWithScoresStub = nil
	fake.zInterWithScoresReturns = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZInterWithScoresReturnsOnCall(i int, result1 *redisa.ZSliceCmd) {
	fake.zInterWithScoresMutex.Lock()
	defer fake.zInterWithScoresMutex.Unlock()
	fake.ZInterWithScoresStub = nil
	if fake.zInterWithScoresReturnsOnCall == nil {
		fake.zInterWithScoresReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZSliceCmd
		})
	}
	fake.zInterWithScoresReturnsOnCall[i] = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZLexCount(arg1 context.Context, arg2 string, arg3 string, arg4 string) *redisa.IntCmd {
	fake.zLexCountMutex.Lock()
	ret, specificReturn := fake.zLexCountReturnsOnCall[len(fake.zLexCountArgsForCall)]
	fake.zLexCountArgsForCall = append(fake.zLexCountArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ZLexCountStub
	fakeReturns := fake.zLexCountReturns
	fake.recordInvocation("ZLexCount", []interface{}{arg1, arg2, arg3, arg4})
	fake.zLexCountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZLexCountCallCount() int {
	fake.zLexCountMutex.RLock()
	defer fake.zLexCountMutex.RUnlock()
	return len(fake.zLexCountArgsForCall)
}

func (fake *FakeClient) ZLexCountCalls(stub func(context.Context, string, string, string) *redisa.IntCmd) {
	fake.zLexCountMutex.Lock()
	defer fake.zLexCountMutex.Unlock()
	fake.ZLexCountStub = stub
}

func (fake *FakeClient) ZLexCountArgsForCall(i int) (context.Context, string, string, string) {
	fake.zLexCountMutex.RLock()
	defer fake.zLexCountMutex.RUnlock()
	argsForCall := fake.zLexCountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ZLexCountReturns(result1 *redisa.IntCmd) {
	fake.zLexCountMutex.Lock()
	defer fake.zLexCountMutex.Unlock()
	fake.ZLexCountStub = nil
	fake.zLexCountReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZLexCountReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zLexCountMutex.Lock()
	defer fake.zLexCountMutex.Unlock()
	fake.ZLexCountStub = nil
	if fake.zLexCountReturnsOnCall == nil {
		fake.zLexCountReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zLexCountReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZMPop(arg1 context.Context, arg2 string, arg3 int64, arg4 ...string) *redisa.ZSliceWithKeyCmd {
	fake.zMPopMutex.Lock()
	ret, specificReturn := fake.zMPopReturnsOnCall[len(fake.zMPopArgsForCall)]
	fake.zMPopArgsForCall = append(fake.zMPopArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 []string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ZMPopStub
	fakeReturns := fake.zMPopReturns
	fake.recordInvocation("ZMPop", []interface{}{arg1, arg2, arg3, arg4})
	fake.zMPopMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZMPopCallCount() int {
	fake.zMPopMutex.RLock()
	defer fake.zMPopMutex.RUnlock()
	return len(fake.zMPopArgsForCall)
}

func (fake *FakeClient) ZMPopCalls(stub func(context.Context, string, int64, ...string) *redisa.ZSliceWithKeyCmd) {
	fake.zMPopMutex.Lock()
	defer fake.zMPopMutex.Unlock()
	fake.ZMPopStub = stub
}

func (fake *FakeClient) ZMPopArgsForCall(i int) (context.Context, string, int64, []string) {
	fake.zMPopMutex.RLock()
	defer fake.zMPopMutex.RUnlock()
	argsForCall := fake.zMPopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ZMPopReturns(result1 *redisa.ZSliceWithKeyCmd) {
	fake.zMPopMutex.Lock()
	defer fake.zMPopMutex.Unlock()
	fake.ZMPopStub = nil
	fake.zMPopReturns = struct {
		result1 *redisa.ZSliceWithKeyCmd
	}{result1}
}

func (fake *FakeClient) ZMPopReturnsOnCall(i int, result1 *redisa.ZSliceWithKeyCmd) {
	fake.zMPopMutex.Lock()
	defer fake.zMPopMutex.Unlock()
	fake.ZMPopStub = nil
	if fake.zMPopReturnsOnCall == nil {
		fake.zMPopReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZSliceWithKeyCmd
		})
	}
	fake.zMPopReturnsOnCall[i] = struct {
		result1 *redisa.ZSliceWithKeyCmd
	}{result1}
}

func (fake *FakeClient) ZMScore(arg1 context.Context, arg2 string, arg3 ...string) *redisa.FloatSliceCmd {
	fake.zMScoreMutex.Lock()
	ret, specificReturn := fake.zMScoreReturnsOnCall[len(fake.zMScoreArgsForCall)]
	fake.zMScoreArgsForCall = append(fake.zMScoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.ZMScoreStub
	fakeReturns := fake.zMScoreReturns
	fake.recordInvocation("ZMScore", []interface{}{arg1, arg2, arg3})
	fake.zMScoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZMScoreCallCount() int {
	fake.zMScoreMutex.RLock()
	defer fake.zMScoreMutex.RUnlock()
	return len(fake.zMScoreArgsForCall)
}

func (fake *FakeClient) ZMScoreCalls(stub func(context.Context, string, ...string) *redisa.FloatSliceCmd) {
	fake.zMScoreMutex.Lock()
	defer fake.zMScoreMutex.Unlock()
	fake.ZMScoreStub = stub
}

func (fake *FakeClient) ZMScoreArgsForCall(i int) (context.Context, string, []string) {
	fake.zMScoreMutex.RLock()
	defer fake.zMScoreMutex.RUnlock()
	argsForCall := fake.zMScoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZMScoreReturns(result1 *redisa.FloatSliceCmd) {
	fake.zMScoreMutex.Lock()
	defer fake.zMScoreMutex.Unlock()
	fake.ZMScoreStub = nil
	fake.zMScoreReturns = struct {
		result1 *redisa.FloatSliceCmd
	}{result1}
}

func (fake *FakeClient) ZMScoreReturnsOnCall(i int, result1 *redisa.FloatSliceCmd) {
	fake.zMScoreMutex.Lock()
	defer fake.zMScoreMutex.Unlock()
	fake.ZMScoreStub = nil
	if fake.zMScoreReturnsOnCall == nil {
		fake.zMScoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatSliceCmd
		})
	}
	fake.zMScoreReturnsOnCall[i] = struct {
		result1 *redisa.FloatSliceCmd
	}{result1}
}

func (fake *FakeClient) ZPopMax(arg1 context.Context, arg2 string, arg3 ...int64) *redisa.ZSliceCmd {
	fake.zPopMaxMutex.Lock()
	ret, specificReturn := fake.zPopMaxReturnsOnCall[len(fake.zPopMaxArgsForCall)]
	fake.zPopMaxArgsForCall = append(fake.zPopMaxArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []int64
	}{arg1, arg2, arg3})
	stub := fake.ZPopMaxStub
	fakeReturns := fake.zPopMaxReturns
	fake.recordInvocation("ZPopMax", []interface{}{arg1, arg2, arg3})
	fake.zPopMaxMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZPopMaxCallCount() int {
	fake.zPopMaxMutex.RLock()
	defer fake.zPopMaxMutex.RUnlock()
	return len(fake.zPopMaxArgsForCall)
}

func (fake *FakeClient) ZPopMaxCalls(stub func(context.Context, string, ...int64) *redisa.ZSliceCmd) {
	fake.zPopMaxMutex.Lock()
	defer fake.zPopMaxMutex.Unlock()
	fake.ZPopMaxStub = stub
}

func (fake *FakeClient) ZPopMaxArgsForCall(i int) (context.Context, string, []int64) {
	fake.zPopMaxMutex.RLock()
	defer fake.zPopMaxMutex.RUnlock()
	argsForCall := fake.zPopMaxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZPopMaxReturns(result1 *redisa.ZSliceCmd) {
	fake.zPopMaxMutex.Lock()
	defer fake.zPopMaxMutex.Unlock()
	fake.ZPopMaxStub = nil
	fake.zPopMaxReturns = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZPopMaxReturnsOnCall(i int, result1 *redisa.ZSliceCmd) {
	fake.zPopMaxMutex.Lock()
	defer fake.zPopMaxMutex.Unlock()
	fake.ZPopMaxStub = nil
	if fake.zPopMaxReturnsOnCall == nil {
		fake.zPopMaxReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZSliceCmd
		})
	}
	fake.zPopMaxReturnsOnCall[i] = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZPopMin(arg1 context.Context, arg2 string, arg3 ...int64) *redisa.ZSliceCmd {
	fake.zPopMinMutex.Lock()
	ret, specificReturn := fake.zPopMinReturnsOnCall[len(fake.zPopMinArgsForCall)]
	fake.zPopMinArgsForCall = append(fake.zPopMinArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []int64
	}{arg1, arg2, arg3})
	stub := fake.ZPopMinStub
	fakeReturns := fake.zPopMinReturns
	fake.recordInvocation("ZPopMin", []interface{}{arg1, arg2, arg3})
	fake.zPopMinMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZPopMinCallCount() int {
	fake.zPopMinMutex.RLock()
	defer fake.zPopMinMutex.RUnlock()
	return len(fake.zPopMinArgsForCall)
}

func (fake *FakeClient) ZPopMinCalls(stub func(context.Context, string, ...int64) *redisa.ZSliceCmd) {
	fake.zPopMinMutex.Lock()
	defer fake.zPopMinMutex.Unlock()
	fake.ZPopMinStub = stub
}

func (fake *FakeClient) ZPopMinArgsForCall(i int) (context.Context, string, []int64) {
	fake.zPopMinMutex.RLock()
	defer fake.zPopMinMutex.RUnlock()
	argsForCall := fake.zPopMinArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZPopMinReturns(result1 *redisa.ZSliceCmd) {
	fake.zPopMinMutex.Lock()
	defer fake.zPopMinMutex.Unlock()
	fake.ZPopMinStub = nil
	fake.zPopMinReturns = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZPopMinReturnsOnCall(i int, result1 *redisa.ZSliceCmd) {
	fake.zPopMinMutex.Lock()
	defer fake.zPopMinMutex.Unlock()
	fake.ZPopMinStub = nil
	if fake.zPopMinReturnsOnCall == nil {
		fake.zPopMinReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZSliceCmd
		})
	}
	fake.zPopMinReturnsOnCall[i] = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRandMember(arg1 context.Context, arg2 string, arg3 int) *redisa.StringSliceCmd {
	fake.zRandMemberMutex.Lock()
	ret, specificReturn := fake.zRandMemberReturnsOnCall[len(fake.zRandMemberArgsForCall)]
	fake.zRandMemberArgsForCall = append(fake.zRandMemberArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ZRandMemberStub
	fakeReturns := fake.zRandMemberReturns
	fake.recordInvocation("ZRandMember", []interface{}{arg1, arg2, arg3})
	fake.zRandMemberMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRandMemberCallCount() int {
	fake.zRandMemberMutex.RLock()
	defer fake.zRandMemberMutex.RUnlock()
	return len(fake.zRandMemberArgsForCall)
}

func (fake *FakeClient) ZRandMemberCalls(stub func(context.Context, string, int) *redisa.StringSliceCmd) {
	fake.zRandMemberMutex.Lock()
	defer fake.zRandMemberMutex.Unlock()
	fake.ZRandMemberStub = stub
}

func (fake *FakeClient) ZRandMemberArgsForCall(i int) (context.Context, string, int) {
	fake.zRandMemberMutex.RLock()
	defer fake.zRandMemberMutex.RUnlock()
	argsForCall := fake.zRandMemberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRandMemberReturns(result1 *redisa.StringSliceCmd) {
	fake.zRandMemberMutex.Lock()
	defer fake.zRandMemberMutex.Unlock()
	fake.ZRandMemberStub = nil
	fake.zRandMemberReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRandMemberReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.zRandMemberMutex.Lock()
	defer fake.zRandMemberMutex.Unlock()
	fake.ZRandMemberStub = nil
	if fake.zRandMemberReturnsOnCall == nil {
		fake.zRandMemberReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.zRandMemberReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRandMemberWithScores(arg1 context.Context, arg2 string, arg3 int) *redisa.ZSliceCmd {
	fake.zRandMemberWithScoresMutex.Lock()
	ret, specificReturn := fake.zRandMemberWithScoresReturnsOnCall[len(fake.zRandMemberWithScoresArgsForCall)]
	fake.zRandMemberWithScoresArgsForCall = append(fake.zRandMemberWithScoresArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ZRandMemberWithScoresStub
	fakeReturns := fake.zRandMemberWithScoresReturns
	fake.recordInvocation("ZRandMemberWithScores", []interface{}{arg1, arg2, arg3})
	fake.zRandMemberWithScoresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRandMemberWithScoresCallCount() int {
	fake.zRandMemberWithScoresMutex.RLock()
	defer fake.zRandMemberWithScoresMutex.RUnlock()
	return len(fake.zRandMemberWithScoresArgsForCall)
}

func (fake *FakeClient) ZRandMemberWithScoresCalls(stub func(context.Context, string, int) *redisa.ZSliceCmd) {
	fake.zRandMemberWithScoresMutex.Lock()
	defer fake.zRandMemberWithScoresMutex.Unlock()
	fake.ZRandMemberWithScoresStub = stub
}

func (fake *FakeClient) ZRandMemberWithScoresArgsForCall(i int) (context.Context, string, int) {
	fake.zRandMemberWithScoresMutex.RLock()
	defer fake.zRandMemberWithScoresMutex.RUnlock()
	argsForCall := fake.zRandMemberWithScoresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRandMemberWithScoresReturns(result1 *redisa.ZSliceCmd) {
	fake.zRandMemberWithScoresMutex.Lock()
	defer fake.zRandMemberWithScoresMutex.Unlock()
	fake.ZRandMemberWithScoresStub = nil
	fake.zRandMemberWithScoresReturns = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRandMemberWithScoresReturnsOnCall(i int, result1 *redisa.ZSliceCmd) {
	fake.zRandMemberWithScoresMutex.Lock()
	defer fake.zRandMemberWithScoresMutex.Unlock()
	fake.ZRandMemberWithScoresStub = nil
	if fake.zRandMemberWithScoresReturnsOnCall == nil {
		fake.zRandMemberWithScoresReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZSliceCmd
		})
	}
	fake.zRandMemberWithScoresReturnsOnCall[i] = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRange(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) *redisa.StringSliceCmd {
	fake.zRangeMutex.Lock()
	ret, specificReturn := fake.zRangeReturnsOnCall[len(fake.zRangeArgsForCall)]
	fake.zRangeArgsForCall = append(fake.zRangeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.ZRangeStub
	fakeReturns := fake.zRangeReturns
	fake.recordInvocation("ZRange", []interface{}{arg1, arg2, arg3, arg4})
	fake.zRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRangeCallCount() int {
	fake.zRangeMutex.RLock()
	defer fake.zRangeMutex.RUnlock()
	return len(fake.zRangeArgsForCall)
}

func (fake *FakeClient) ZRangeCalls(stub func(context.Context, string, int64, int64) *redisa.StringSliceCmd) {
	fake.zRangeMutex.Lock()
	defer fake.zRangeMutex.Unlock()
	fake.ZRangeStub = stub
}

func (fake *FakeClient) ZRangeArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.zRangeMutex.RLock()
	defer fake.zRangeMutex.RUnlock()
	argsForCall := fake.zRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ZRangeReturns(result1 *redisa.StringSliceCmd) {
	fake.zRangeMutex.Lock()
	defer fake.zRangeMutex.Unlock()
	fake.ZRangeStub = nil
	fake.zRangeReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRangeReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.zRangeMutex.Lock()
	defer fake.zRangeMutex.Unlock()
	fake.ZRangeStub = nil
	if fake.zRangeReturnsOnCall == nil {
		fake.zRangeReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.zRangeReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRangeArgs(arg1 context.Context, arg2 redisa.ZRangeArgs) *redisa.StringSliceCmd {
	fake.zRangeArgsMutex.Lock()
	ret, specificReturn := fake.zRangeArgsReturnsOnCall[len(fake.zRangeArgsArgsForCall)]
	fake.zRangeArgsArgsForCall = append(fake.zRangeArgsArgsForCall, struct {
		arg1 context.Context
		arg2 redisa.ZRangeArgs
	}{arg1, arg2})
	stub := fake.ZRangeArgsStub
	fakeReturns := fake.zRangeArgsReturns
	fake.recordInvocation("ZRangeArgs", []interface{}{arg1, arg2})
	fake.zRangeArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRangeArgsCallCount() int {
	fake.zRangeArgsMutex.RLock()
	defer fake.zRangeArgsMutex.RUnlock()
	return len(fake.zRangeArgsArgsForCall)
}

func (fake *FakeClient) ZRangeArgsCalls(stub func(context.Context, redisa.ZRangeArgs) *redisa.StringSliceCmd) {
	fake.zRangeArgsMutex.Lock()
	defer fake.zRangeArgsMutex.Unlock()
	fake.ZRangeArgsStub = stub
}

func (fake *FakeClient) ZRangeArgsArgsForCall(i int) (context.Context, redisa.ZRangeArgs) {
	fake.zRangeArgsMutex.RLock()
	defer fake.zRangeArgsMutex.RUnlock()
	argsForCall := fake.zRangeArgsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ZRangeArgsReturns(result1 *redisa.StringSliceCmd) {
	fake.zRangeArgsMutex.Lock()
	defer fake.zRangeArgsMutex.Unlock()
	fake.ZRangeArgsStub = nil
	fake.zRangeArgsReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRangeArgsReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.zRangeArgsMutex.Lock()
	defer fake.zRangeArgsMutex.Unlock()
	fake.ZRangeArgsStub = nil
	if fake.zRangeArgsReturnsOnCall == nil {
		fake.zRangeArgsReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.zRangeArgsReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRangeArgsWithScores(arg1 context.Context, arg2 redisa.ZRangeArgs) *redisa.ZSliceCmd {
	fake.zRangeArgsWithScoresMutex.Lock()
	ret, specificReturn := fake.zRangeArgsWithScoresReturnsOnCall[len(fake.zRangeArgsWithScoresArgsForCall)]
	fake.zRangeArgsWithScoresArgsForCall = append(fake.zRangeArgsWithScoresArgsForCall, struct {
		arg1 context.Context
		arg2 redisa.ZRangeArgs
	}{arg1, arg2})
	stub := fake.ZRangeArgsWithScoresStub
	fakeReturns := fake.zRangeArgsWithScoresReturns
	fake.recordInvocation("ZRangeArgsWithScores", []interface{}{arg1, arg2})
	fake.zRangeArgsWithScoresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRangeArgsWithScoresCallCount() int {
	fake.zRangeArgsWithScoresMutex.RLock()
	defer fake.zRangeArgsWithScoresMutex.RUnlock()
	return len(fake.zRangeArgsWithScoresArgsForCall)
}

func (fake *FakeClient) ZRangeArgsWithScoresCalls(stub func(context.Context, redisa.ZRangeArgs) *redisa.ZSliceCmd) {
	fake.zRangeArgsWithScoresMutex.Lock()
	defer fake.zRangeArgsWithScoresMutex.Unlock()
	fake.ZRangeArgsWithScoresStub = stub
}

func (fake *FakeClient) ZRangeArgsWithScoresArgsForCall(i int) (context.Context, redisa.ZRangeArgs) {
	fake.zRangeArgsWithScoresMutex.RLock()
	defer fake.zRangeArgsWithScoresMutex.RUnlock()
	argsForCall := fake.zRangeArgsWithScoresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ZRangeArgsWithScoresReturns(result1 *redisa.ZSliceCmd) {
	fake.zRangeArgsWithScoresMutex.Lock()
	defer fake.zRangeArgsWithScoresMutex.Unlock()
	fake.ZRangeArgsWithScoresStub = nil
	fake.zRangeArgsWithScoresReturns = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRangeArgsWithScoresReturnsOnCall(i int, result1 *redisa.ZSliceCmd) {
	fake.zRangeArgsWithScoresMutex.Lock()
	defer fake.zRangeArgsWithScoresMutex.Unlock()
	fake.ZRangeArgsWithScoresStub = nil
	if fake.zRangeArgsWithScoresReturnsOnCall == nil {
		fake.zRangeArgsWithScoresReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZSliceCmd
		})
	}
	fake.zRangeArgsWithScoresReturnsOnCall[i] = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRangeByLex(arg1 context.Context, arg2 string, arg3 *redisa.ZRangeBy) *redisa.StringSliceCmd {
	fake.zRangeByLexMutex.Lock()
	ret, specificReturn := fake.zRangeByLexReturnsOnCall[len(fake.zRangeByLexArgsForCall)]
	fake.zRangeByLexArgsForCall = append(fake.zRangeByLexArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZRangeBy
	}{arg1, arg2, arg3})
	stub := fake.ZRangeByLexStub
	fakeReturns := fake.zRangeByLexReturns
	fake.recordInvocation("ZRangeByLex", []interface{}{arg1, arg2, arg3})
	fake.zRangeByLexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRangeByLexCallCount() int {
	fake.zRangeByLexMutex.RLock()
	defer fake.zRangeByLexMutex.RUnlock()
	return len(fake.zRangeByLexArgsForCall)
}

func (fake *FakeClient) ZRangeByLexCalls(stub func(context.Context, string, *redisa.ZRangeBy) *redisa.StringSliceCmd) {
	fake.zRangeByLexMutex.Lock()
	defer fake.zRangeByLexMutex.Unlock()
	fake.ZRangeByLexStub = stub
}

func (fake *FakeClient) ZRangeByLexArgsForCall(i int) (context.Context, string, *redisa.ZRangeBy) {
	fake.zRangeByLexMutex.RLock()
	defer fake.zRangeByLexMutex.RUnlock()
	argsForCall := fake.zRangeByLexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRangeByLexReturns(result1 *redisa.StringSliceCmd) {
	fake.zRangeByLexMutex.Lock()
	defer fake.zRangeByLexMutex.Unlock()
	fake.ZRangeByLexStub = nil
	fake.zRangeByLexReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRangeByLexReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.zRangeByLexMutex.Lock()
	defer fake.zRangeByLexMutex.Unlock()
	fake.ZRangeByLexStub = nil
	if fake.zRangeByLexReturnsOnCall == nil {
		fake.zRangeByLexReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.zRangeByLexReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRangeByScore(arg1 context.Context, arg2 string, arg3 *redisa.ZRangeBy) *redisa.StringSliceCmd {
	fake.zRangeByScoreMutex.Lock()
	ret, specificReturn := fake.zRangeByScoreReturnsOnCall[len(fake.zRangeByScoreArgsForCall)]
	fake.zRangeByScoreArgsForCall = append(fake.zRangeByScoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZRangeBy
	}{arg1, arg2, arg3})
	stub := fake.ZRangeByScoreStub
	fakeReturns := fake.zRangeByScoreReturns
	fake.recordInvocation("ZRangeByScore", []interface{}{arg1, arg2, arg3})
	fake.zRangeByScoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRangeByScoreCallCount() int {
	fake.zRangeByScoreMutex.RLock()
	defer fake.zRangeByScoreMutex.RUnlock()
	return len(fake.zRangeByScoreArgsForCall)
}

func (fake *FakeClient) ZRangeByScoreCalls(stub func(context.Context, string, *redisa.ZRangeBy) *redisa.StringSliceCmd) {
	fake.zRangeByScoreMutex.Lock()
	defer fake.zRangeByScoreMutex.Unlock()
	fake.ZRangeByScoreStub = stub
}

func (fake *FakeClient) ZRangeByScoreArgsForCall(i int) (context.Context, string, *redisa.ZRangeBy) {
	fake.zRangeByScoreMutex.RLock()
	defer fake.zRangeByScoreMutex.RUnlock()
	argsForCall := fake.zRangeByScoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRangeByScoreReturns(result1 *redisa.StringSliceCmd) {
	fake.zRangeByScoreMutex.Lock()
	defer fake.zRangeByScoreMutex.Unlock()
	fake.ZRangeByScoreStub = nil
	fake.zRangeByScoreReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRangeByScoreReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.zRangeByScoreMutex.Lock()
	defer fake.zRangeByScoreMutex.Unlock()
	fake.ZRangeByScoreStub = nil
	if fake.zRangeByScoreReturnsOnCall == nil {
		fake.zRangeByScoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.zRangeByScoreReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRangeByScoreWithScores(arg1 context.Context, arg2 string, arg3 *redisa.ZRangeBy) *redisa.ZSliceCmd {
	fake.zRangeByScoreWithScoresMutex.Lock()
	ret, specificReturn := fake.zRangeByScoreWithScoresReturnsOnCall[len(fake.zRangeByScoreWithScoresArgsForCall)]
	fake.zRangeByScoreWithScoresArgsForCall = append(fake.zRangeByScoreWithScoresArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZRangeBy
	}{arg1, arg2, arg3})
	stub := fake.ZRangeByScoreWithScoresStub
	fakeReturns := fake.zRangeByScoreWithScoresReturns
	fake.recordInvocation("ZRangeByScoreWithScores", []interface{}{arg1, arg2, arg3})
	fake.zRangeByScoreWithScoresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRangeByScoreWithScoresCallCount() int {
	fake.zRangeByScoreWithScoresMutex.RLock()
	defer fake.zRangeByScoreWithScoresMutex.RUnlock()
	return len(fake.zRangeByScoreWithScoresArgsForCall)
}

func (fake *FakeClient) ZRangeByScoreWithScoresCalls(stub func(context.Context, string, *redisa.ZRangeBy) *redisa.ZSliceCmd) {
	fake.zRangeByScoreWithScoresMutex.Lock()
	defer fake.zRangeByScoreWithScoresMutex.Unlock()
	fake.ZRangeByScoreWithScoresStub = stub
}

func (fake *FakeClient) ZRangeByScoreWithScoresArgsForCall(i int) (context.Context, string, *redisa.ZRangeBy) {
	fake.zRangeByScoreWithScoresMutex.RLock()
	defer fake.zRangeByScoreWithScoresMutex.RUnlock()
	argsForCall := fake.zRangeByScoreWithScoresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRangeByScoreWithScoresReturns(result1 *redisa.ZSliceCmd) {
	fake.zRangeByScoreWithScoresMutex.Lock()
	defer fake.zRangeByScoreWithScoresMutex.Unlock()
	fake.ZRangeByScoreWithScoresStub = nil
	fake.zRangeByScoreWithScoresReturns = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRangeByScoreWithScoresReturnsOnCall(i int, result1 *redisa.ZSliceCmd) {
	fake.zRangeByScoreWithScoresMutex.Lock()
	defer fake.zRangeByScoreWithScoresMutex.Unlock()
	fake.ZRangeByScoreWithScoresStub = nil
	if fake.zRangeByScoreWithScoresReturnsOnCall == nil {
		fake.zRangeByScoreWithScoresReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZSliceCmd
		})
	}
	fake.zRangeByScoreWithScoresReturnsOnCall[i] = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRangeStore(arg1 context.Context, arg2 string, arg3 redisa.ZRangeArgs) *redisa.IntCmd {
	fake.zRangeStoreMutex.Lock()
	ret, specificReturn := fake.zRangeStoreReturnsOnCall[len(fake.zRangeStoreArgsForCall)]
	fake.zRangeStoreArgsForCall = append(fake.zRangeStoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 redisa.ZRangeArgs
	}{arg1, arg2, arg3})
	stub := fake.ZRangeStoreStub
	fakeReturns := fake.zRangeStoreReturns
	fake.recordInvocation("ZRangeStore", []interface{}{arg1, arg2, arg3})
	fake.zRangeStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRangeStoreCallCount() int {
	fake.zRangeStoreMutex.RLock()
	defer fake.zRangeStoreMutex.RUnlock()
	return len(fake.zRangeStoreArgsForCall)
}

func (fake *FakeClient) ZRangeStoreCalls(stub func(context.Context, string, redisa.ZRangeArgs) *redisa.IntCmd) {
	fake.zRangeStoreMutex.Lock()
	defer fake.zRangeStoreMutex.Unlock()
	fake.ZRangeStoreStub = stub
}

func (fake *FakeClient) ZRangeStoreArgsForCall(i int) (context.Context, string, redisa.ZRangeArgs) {
	fake.zRangeStoreMutex.RLock()
	defer fake.zRangeStoreMutex.RUnlock()
	argsForCall := fake.zRangeStoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRangeStoreReturns(result1 *redisa.IntCmd) {
	fake.zRangeStoreMutex.Lock()
	defer fake.zRangeStoreMutex.Unlock()
	fake.ZRangeStoreStub = nil
	fake.zRangeStoreReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRangeStoreReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zRangeStoreMutex.Lock()
	defer fake.zRangeStoreMutex.Unlock()
	fake.ZRangeStoreStub = nil
	if fake.zRangeStoreReturnsOnCall == nil {
		fake.zRangeStoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zRangeStoreReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRangeWithScores(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) *redisa.ZSliceCmd {
	fake.zRangeWithScoresMutex.Lock()
	ret, specificReturn := fake.zRangeWithScoresReturnsOnCall[len(fake.zRangeWithScoresArgsForCall)]
	fake.zRangeWithScoresArgsForCall = append(fake.zRangeWithScoresArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.ZRangeWithScoresStub
	fakeReturns := fake.zRangeWithScoresReturns
	fake.recordInvocation("ZRangeWithScores", []interface{}{arg1, arg2, arg3, arg4})
	fake.zRangeWithScoresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRangeWithScoresCallCount() int {
	fake.zRangeWithScoresMutex.RLock()
	defer fake.zRangeWithScoresMutex.RUnlock()
	return len(fake.zRangeWithScoresArgsForCall)
}

func (fake *FakeClient) ZRangeWithScoresCalls(stub func(context.Context, string, int64, int64) *redisa.ZSliceCmd) {
	fake.zRangeWithScoresMutex.Lock()
	defer fake.zRangeWithScoresMutex.Unlock()
	fake.ZRangeWithScoresStub = stub
}

func (fake *FakeClient) ZRangeWithScoresArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.zRangeWithScoresMutex.RLock()
	defer fake.zRangeWithScoresMutex.RUnlock()
	argsForCall := fake.zRangeWithScoresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ZRangeWithScoresReturns(result1 *redisa.ZSliceCmd) {
	fake.zRangeWithScoresMutex.Lock()
	defer fake.zRangeWithScoresMutex.Unlock()
	fake.ZRangeWithScoresStub = nil
	fake.zRangeWithScoresReturns = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRangeWithScoresReturnsOnCall(i int, result1 *redisa.ZSliceCmd) {
	fake.zRangeWithScoresMutex.Lock()
	defer fake.zRangeWithScoresMutex.Unlock()
	fake.ZRangeWithScoresStub = nil
	if fake.zRangeWithScoresReturnsOnCall == nil {
		fake.zRangeWithScoresReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZSliceCmd
		})
	}
	fake.zRangeWithScoresReturnsOnCall[i] = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRank(arg1 context.Context, arg2 string, arg3 string) *redisa.IntCmd {
	fake.zRankMutex.Lock()
	ret, specificReturn := fake.zRankReturnsOnCall[len(fake.zRankArgsForCall)]
	fake.zRankArgsForCall = append(fake.zRankArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ZRankStub
	fakeReturns := fake.zRankReturns
	fake.recordInvocation("ZRank", []interface{}{arg1, arg2, arg3})
	fake.zRankMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRankCallCount() int {
	fake.zRankMutex.RLock()
	defer fake.zRankMutex.RUnlock()
	return len(fake.zRankArgsForCall)
}

func (fake *FakeClient) ZRankCalls(stub func(context.Context, string, string) *redisa.IntCmd) {
	fake.zRankMutex.Lock()
	defer fake.zRankMutex.Unlock()
	fake.ZRankStub = stub
}

func (fake *FakeClient) ZRankArgsForCall(i int) (context.Context, string, string) {
	fake.zRankMutex.RLock()
	defer fake.zRankMutex.RUnlock()
	argsForCall := fake.zRankArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRankReturns(result1 *redisa.IntCmd) {
	fake.zRankMutex.Lock()
	defer fake.zRankMutex.Unlock()
	fake.ZRankStub = nil
	fake.zRankReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRankReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zRankMutex.Lock()
	defer fake.zRankMutex.Unlock()
	fake.ZRankStub = nil
	if fake.zRankReturnsOnCall == nil {
		fake.zRankReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zRankReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRankWithScore(arg1 context.Context, arg2 string, arg3 string) *redisa.RankWithScoreCmd {
	fake.zRankWithScoreMutex.Lock()
	ret, specificReturn := fake.zRankWithScoreReturnsOnCall[len(fake.zRankWithScoreArgsForCall)]
	fake.zRankWithScoreArgsForCall = append(fake.zRankWithScoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ZRankWithScoreStub
	fakeReturns := fake.zRankWithScoreReturns
	fake.recordInvocation("ZRankWithScore", []interface{}{arg1, arg2, arg3})
	fake.zRankWithScoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRankWithScoreCallCount() int {
	fake.zRankWithScoreMutex.RLock()
	defer fake.zRankWithScoreMutex.RUnlock()
	return len(fake.zRankWithScoreArgsForCall)
}

func (fake *FakeClient) ZRankWithScoreCalls(stub func(context.Context, string, string) *redisa.RankWithScoreCmd) {
	fake.zRankWithScoreMutex.Lock()
	defer fake.zRankWithScoreMutex.Unlock()
	fake.ZRankWithScoreStub = stub
}

func (fake *FakeClient) ZRankWithScoreArgsForCall(i int) (context.Context, string, string) {
	fake.zRankWithScoreMutex.RLock()
	defer fake.zRankWithScoreMutex.RUnlock()
	argsForCall := fake.zRankWithScoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRankWithScoreReturns(result1 *redisa.RankWithScoreCmd) {
	fake.zRankWithScoreMutex.Lock()
	defer fake.zRankWithScoreMutex.Unlock()
	fake.ZRankWithScoreStub = nil
	fake.zRankWithScoreReturns = struct {
		result1 *redisa.RankWithScoreCmd
	}{result1}
}

func (fake *FakeClient) ZRankWithScoreReturnsOnCall(i int, result1 *redisa.RankWithScoreCmd) {
	fake.zRankWithScoreMutex.Lock()
	defer fake.zRankWithScoreMutex.Unlock()
	fake.ZRankWithScoreStub = nil
	if fake.zRankWithScoreReturnsOnCall == nil {
		fake.zRankWithScoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.RankWithScoreCmd
		})
	}
	fake.zRankWithScoreReturnsOnCall[i] = struct {
		result1 *redisa.RankWithScoreCmd
	}{result1}
}

func (fake *FakeClient) ZRem(arg1 context.Context, arg2 string, arg3 ...interface{}) *redisa.IntCmd {
	fake.zRemMutex.Lock()
	ret, specificReturn := fake.zRemReturnsOnCall[len(fake.zRemArgsForCall)]
	fake.zRemArgsForCall = append(fake.zRemArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.ZRemStub
	fakeReturns := fake.zRemReturns
	fake.recordInvocation("ZRem", []interface{}{arg1, arg2, arg3})
	fake.zRemMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRemCallCount() int {
	fake.zRemMutex.RLock()
	defer fake.zRemMutex.RUnlock()
	return len(fake.zRemArgsForCall)
}

func (fake *FakeClient) ZRemCalls(stub func(context.Context, string, ...interface{}) *redisa.IntCmd) {
	fake.zRemMutex.Lock()
	defer fake.zRemMutex.Unlock()
	fake.ZRemStub = stub
}

func (fake *FakeClient) ZRemArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.zRemMutex.RLock()
	defer fake.zRemMutex.RUnlock()
	argsForCall := fake.zRemArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRemReturns(result1 *redisa.IntCmd) {
	fake.zRemMutex.Lock()
	defer fake.zRemMutex.Unlock()
	fake.ZRemStub = nil
	fake.zRemReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRemReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zRemMutex.Lock()
	defer fake.zRemMutex.Unlock()
	fake.ZRemStub = nil
	if fake.zRemReturnsOnCall == nil {
		fake.zRemReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zRemReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRemRangeByLex(arg1 context.Context, arg2 string, arg3 string, arg4 string) *redisa.IntCmd {
	fake.zRemRangeByLexMutex.Lock()
	ret, specificReturn := fake.zRemRangeByLexReturnsOnCall[len(fake.zRemRangeByLexArgsForCall)]
	fake.zRemRangeByLexArgsForCall = append(fake.zRemRangeByLexArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ZRemRangeByLexStub
	fakeReturns := fake.zRemRangeByLexReturns
	fake.recordInvocation("ZRemRangeByLex", []interface{}{arg1, arg2, arg3, arg4})
	fake.zRemRangeByLexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRemRangeByLexCallCount() int {
	fake.zRemRangeByLexMutex.RLock()
	defer fake.zRemRangeByLexMutex.RUnlock()
	return len(fake.zRemRangeByLexArgsForCall)
}

func (fake *FakeClient) ZRemRangeByLexCalls(stub func(context.Context, string, string, string) *redisa.IntCmd) {
	fake.zRemRangeByLexMutex.Lock()
	defer fake.zRemRangeByLexMutex.Unlock()
	fake.ZRemRangeByLexStub = stub
}

func (fake *FakeClient) ZRemRangeByLexArgsForCall(i int) (context.Context, string, string, string) {
	fake.zRemRangeByLexMutex.RLock()
	defer fake.zRemRangeByLexMutex.RUnlock()
	argsForCall := fake.zRemRangeByLexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ZRemRangeByLexReturns(result1 *redisa.IntCmd) {
	fake.zRemRangeByLexMutex.Lock()
	defer fake.zRemRangeByLexMutex.Unlock()
	fake.ZRemRangeByLexStub = nil
	fake.zRemRangeByLexReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRemRangeByLexReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zRemRangeByLexMutex.Lock()
	defer fake.zRemRangeByLexMutex.Unlock()
	fake.ZRemRangeByLexStub = nil
	if fake.zRemRangeByLexReturnsOnCall == nil {
		fake.zRemRangeByLexReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zRemRangeByLexReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRemRangeByRank(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) *redisa.IntCmd {
	fake.zRemRangeByRankMutex.Lock()
	ret, specificReturn := fake.zRemRangeByRankReturnsOnCall[len(fake.zRemRangeByRankArgsForCall)]
	fake.zRemRangeByRankArgsForCall = append(fake.zRemRangeByRankArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.ZRemRangeByRankStub
	fakeReturns := fake.zRemRangeByRankReturns
	fake.recordInvocation("ZRemRangeByRank", []interface{}{arg1, arg2, arg3, arg4})
	fake.zRemRangeByRankMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRemRangeByRankCallCount() int {
	fake.zRemRangeByRankMutex.RLock()
	defer fake.zRemRangeByRankMutex.RUnlock()
	return len(fake.zRemRangeByRankArgsForCall)
}

func (fake *FakeClient) ZRemRangeByRankCalls(stub func(context.Context, string, int64, int64) *redisa.IntCmd) {
	fake.zRemRangeByRankMutex.Lock()
	defer fake.zRemRangeByRankMutex.Unlock()
	fake.ZRemRangeByRankStub = stub
}

func (fake *FakeClient) ZRemRangeByRankArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.zRemRangeByRankMutex.RLock()
	defer fake.zRemRangeByRankMutex.RUnlock()
	argsForCall := fake.zRemRangeByRankArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ZRemRangeByRankReturns(result1 *redisa.IntCmd) {
	fake.zRemRangeByRankMutex.Lock()
	defer fake.zRemRangeByRankMutex.Unlock()
	fake.ZRemRangeByRankStub = nil
	fake.zRemRangeByRankReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRemRangeByRankReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zRemRangeByRankMutex.Lock()
	defer fake.zRemRangeByRankMutex.Unlock()
	fake.ZRemRangeByRankStub = nil
	if fake.zRemRangeByRankReturnsOnCall == nil {
		fake.zRemRangeByRankReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zRemRangeByRankReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRemRangeByScore(arg1 context.Context, arg2 string, arg3 string, arg4 string) *redisa.IntCmd {
	fake.zRemRangeByScoreMutex.Lock()
	ret, specificReturn := fake.zRemRangeByScoreReturnsOnCall[len(fake.zRemRangeByScoreArgsForCall)]
	fake.zRemRangeByScoreArgsForCall = append(fake.zRemRangeByScoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ZRemRangeByScoreStub
	fakeReturns := fake.zRemRangeByScoreReturns
	fake.recordInvocation("ZRemRangeByScore", []interface{}{arg1, arg2, arg3, arg4})
	fake.zRemRangeByScoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRemRangeByScoreCallCount() int {
	fake.zRemRangeByScoreMutex.RLock()
	defer fake.zRemRangeByScoreMutex.RUnlock()
	return len(fake.zRemRangeByScoreArgsForCall)
}

func (fake *FakeClient) ZRemRangeByScoreCalls(stub func(context.Context, string, string, string) *redisa.IntCmd) {
	fake.zRemRangeByScoreMutex.Lock()
	defer fake.zRemRangeByScoreMutex.Unlock()
	fake.ZRemRangeByScoreStub = stub
}

func (fake *FakeClient) ZRemRangeByScoreArgsForCall(i int) (context.Context, string, string, string) {
	fake.zRemRangeByScoreMutex.RLock()
	defer fake.zRemRangeByScoreMutex.RUnlock()
	argsForCall := fake.zRemRangeByScoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ZRemRangeByScoreReturns(result1 *redisa.IntCmd) {
	fake.zRemRangeByScoreMutex.Lock()
	defer fake.zRemRangeByScoreMutex.Unlock()
	fake.ZRemRangeByScoreStub = nil
	fake.zRemRangeByScoreReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRemRangeByScoreReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zRemRangeByScoreMutex.Lock()
	defer fake.zRemRangeByScoreMutex.Unlock()
	fake.ZRemRangeByScoreStub = nil
	if fake.zRemRangeByScoreReturnsOnCall == nil {
		fake.zRemRangeByScoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zRemRangeByScoreReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRevRange(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) *redisa.StringSliceCmd {
	fake.zRevRangeMutex.Lock()
	ret, specificReturn := fake.zRevRangeReturnsOnCall[len(fake.zRevRangeArgsForCall)]
	fake.zRevRangeArgsForCall = append(fake.zRevRangeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.ZRevRangeStub
	fakeReturns := fake.zRevRangeReturns
	fake.recordInvocation("ZRevRange", []interface{}{arg1, arg2, arg3, arg4})
	fake.zRevRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRevRangeCallCount() int {
	fake.zRevRangeMutex.RLock()
	defer fake.zRevRangeMutex.RUnlock()
	return len(fake.zRevRangeArgsForCall)
}

func (fake *FakeClient) ZRevRangeCalls(stub func(context.Context, string, int64, int64) *redisa.StringSliceCmd) {
	fake.zRevRangeMutex.Lock()
	defer fake.zRevRangeMutex.Unlock()
	fake.ZRevRangeStub = stub
}

func (fake *FakeClient) ZRevRangeArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.zRevRangeMutex.RLock()
	defer fake.zRevRangeMutex.RUnlock()
	argsForCall := fake.zRevRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ZRevRangeReturns(result1 *redisa.StringSliceCmd) {
	fake.zRevRangeMutex.Lock()
	defer fake.zRevRangeMutex.Unlock()
	fake.ZRevRangeStub = nil
	fake.zRevRangeReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRevRangeReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.zRevRangeMutex.Lock()
	defer fake.zRevRangeMutex.Unlock()
	fake.ZRevRangeStub = nil
	if fake.zRevRangeReturnsOnCall == nil {
		fake.zRevRangeReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.zRevRangeReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRevRangeByLex(arg1 context.Context, arg2 string, arg3 *redisa.ZRangeBy) *redisa.StringSliceCmd {
	fake.zRevRangeByLexMutex.Lock()
	ret, specificReturn := fake.zRevRangeByLexReturnsOnCall[len(fake.zRevRangeByLexArgsForCall)]
	fake.zRevRangeByLexArgsForCall = append(fake.zRevRangeByLexArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZRangeBy
	}{arg1, arg2, arg3})
	stub := fake.ZRevRangeByLexStub
	fakeReturns := fake.zRevRangeByLexReturns
	fake.recordInvocation("ZRevRangeByLex", []interface{}{arg1, arg2, arg3})
	fake.zRevRangeByLexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRevRangeByLexCallCount() int {
	fake.zRevRangeByLexMutex.RLock()
	defer fake.zRevRangeByLexMutex.RUnlock()
	return len(fake.zRevRangeByLexArgsForCall)
}

func (fake *FakeClient) ZRevRangeByLexCalls(stub func(context.Context, string, *redisa.ZRangeBy) *redisa.StringSliceCmd) {
	fake.zRevRangeByLexMutex.Lock()
	defer fake.zRevRangeByLexMutex.Unlock()
	fake.ZRevRangeByLexStub = stub
}

func (fake *FakeClient) ZRevRangeByLexArgsForCall(i int) (context.Context, string, *redisa.ZRangeBy) {
	fake.zRevRangeByLexMutex.RLock()
	defer fake.zRevRangeByLexMutex.RUnlock()
	argsForCall := fake.zRevRangeByLexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRevRangeByLexReturns(result1 *redisa.StringSliceCmd) {
	fake.zRevRangeByLexMutex.Lock()
	defer fake.zRevRangeByLexMutex.Unlock()
	fake.ZRevRangeByLexStub = nil
	fake.zRevRangeByLexReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRevRangeByLexReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.zRevRangeByLexMutex.Lock()
	defer fake.zRevRangeByLexMutex.Unlock()
	fake.ZRevRangeByLexStub = nil
	if fake.zRevRangeByLexReturnsOnCall == nil {
		fake.zRevRangeByLexReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.zRevRangeByLexReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRevRangeByScore(arg1 context.Context, arg2 string, arg3 *redisa.ZRangeBy) *redisa.StringSliceCmd {
	fake.zRevRangeByScoreMutex.Lock()
	ret, specificReturn := fake.zRevRangeByScoreReturnsOnCall[len(fake.zRevRangeByScoreArgsForCall)]
	fake.zRevRangeByScoreArgsForCall = append(fake.zRevRangeByScoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZRangeBy
	}{arg1, arg2, arg3})
	stub := fake.ZRevRangeByScoreStub
	fakeReturns := fake.zRevRangeByScoreReturns
	fake.recordInvocation("ZRevRangeByScore", []interface{}{arg1, arg2, arg3})
	fake.zRevRangeByScoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRevRangeByScoreCallCount() int {
	fake.zRevRangeByScoreMutex.RLock()
	defer fake.zRevRangeByScoreMutex.RUnlock()
	return len(fake.zRevRangeByScoreArgsForCall)
}

func (fake *FakeClient) ZRevRangeByScoreCalls(stub func(context.Context, string, *redisa.ZRangeBy) *redisa.StringSliceCmd) {
	fake.zRevRangeByScoreMutex.Lock()
	defer fake.zRevRangeByScoreMutex.Unlock()
	fake.ZRevRangeByScoreStub = stub
}

func (fake *FakeClient) ZRevRangeByScoreArgsForCall(i int) (context.Context, string, *redisa.ZRangeBy) {
	fake.zRevRangeByScoreMutex.RLock()
	defer fake.zRevRangeByScoreMutex.RUnlock()
	argsForCall := fake.zRevRangeByScoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRevRangeByScoreReturns(result1 *redisa.StringSliceCmd) {
	fake.zRevRangeByScoreMutex.Lock()
	defer fake.zRevRangeByScoreMutex.Unlock()
	fake.ZRevRangeByScoreStub = nil
	fake.zRevRangeByScoreReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRevRangeByScoreReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.zRevRangeByScoreMutex.Lock()
	defer fake.zRevRangeByScoreMutex.Unlock()
	fake.ZRevRangeByScoreStub = nil
	if fake.zRevRangeByScoreReturnsOnCall == nil {
		fake.zRevRangeByScoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.zRevRangeByScoreReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRevRangeByScoreWithScores(arg1 context.Context, arg2 string, arg3 *redisa.ZRangeBy) *redisa.ZSliceCmd {
	fake.zRevRangeByScoreWithScoresMutex.Lock()
	ret, specificReturn := fake.zRevRangeByScoreWithScoresReturnsOnCall[len(fake.zRevRangeByScoreWithScoresArgsForCall)]
	fake.zRevRangeByScoreWithScoresArgsForCall = append(fake.zRevRangeByScoreWithScoresArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZRangeBy
	}{arg1, arg2, arg3})
	stub := fake.ZRevRangeByScoreWithScoresStub
	fakeReturns := fake.zRevRangeByScoreWithScoresReturns
	fake.recordInvocation("ZRevRangeByScoreWithScores", []interface{}{arg1, arg2, arg3})
	fake.zRevRangeByScoreWithScoresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRevRangeByScoreWithScoresCallCount() int {
	fake.zRevRangeByScoreWithScoresMutex.RLock()
	defer fake.zRevRangeByScoreWithScoresMutex.RUnlock()
	return len(fake.zRevRangeByScoreWithScoresArgsForCall)
}

func (fake *FakeClient) ZRevRangeByScoreWithScoresCalls(stub func(context.Context, string, *redisa.ZRangeBy) *redisa.ZSliceCmd) {
	fake.zRevRangeByScoreWithScoresMutex.Lock()
	defer fake.zRevRangeByScoreWithScoresMutex.Unlock()
	fake.ZRevRangeByScoreWithScoresStub = stub
}

func (fake *FakeClient) ZRevRangeByScoreWithScoresArgsForCall(i int) (context.Context, string, *redisa.ZRangeBy) {
	fake.zRevRangeByScoreWithScoresMutex.RLock()
	defer fake.zRevRangeByScoreWithScoresMutex.RUnlock()
	argsForCall := fake.zRevRangeByScoreWithScoresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRevRangeByScoreWithScoresReturns(result1 *redisa.ZSliceCmd) {
	fake.zRevRangeByScoreWithScoresMutex.Lock()
	defer fake.zRevRangeByScoreWithScoresMutex.Unlock()
	fake.ZRevRangeByScoreWithScoresStub = nil
	fake.zRevRangeByScoreWithScoresReturns = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRevRangeByScoreWithScoresReturnsOnCall(i int, result1 *redisa.ZSliceCmd) {
	fake.zRevRangeByScoreWithScoresMutex.Lock()
	defer fake.zRevRangeByScoreWithScoresMutex.Unlock()
	fake.ZRevRangeByScoreWithScoresStub = nil
	if fake.zRevRangeByScoreWithScoresReturnsOnCall == nil {
		fake.zRevRangeByScoreWithScoresReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZSliceCmd
		})
	}
	fake.zRevRangeByScoreWithScoresReturnsOnCall[i] = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRevRangeWithScores(arg1 context.Context, arg2 string, arg3 int64, arg4 int64) *redisa.ZSliceCmd {
	fake.zRevRangeWithScoresMutex.Lock()
	ret, specificReturn := fake.zRevRangeWithScoresReturnsOnCall[len(fake.zRevRangeWithScoresArgsForCall)]
	fake.zRevRangeWithScoresArgsForCall = append(fake.zRevRangeWithScoresArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.ZRevRangeWithScoresStub
	fakeReturns := fake.zRevRangeWithScoresReturns
	fake.recordInvocation("ZRevRangeWithScores", []interface{}{arg1, arg2, arg3, arg4})
	fake.zRevRangeWithScoresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRevRangeWithScoresCallCount() int {
	fake.zRevRangeWithScoresMutex.RLock()
	defer fake.zRevRangeWithScoresMutex.RUnlock()
	return len(fake.zRevRangeWithScoresArgsForCall)
}

func (fake *FakeClient) ZRevRangeWithScoresCalls(stub func(context.Context, string, int64, int64) *redisa.ZSliceCmd) {
	fake.zRevRangeWithScoresMutex.Lock()
	defer fake.zRevRangeWithScoresMutex.Unlock()
	fake.ZRevRangeWithScoresStub = stub
}

func (fake *FakeClient) ZRevRangeWithScoresArgsForCall(i int) (context.Context, string, int64, int64) {
	fake.zRevRangeWithScoresMutex.RLock()
	defer fake.zRevRangeWithScoresMutex.RUnlock()
	argsForCall := fake.zRevRangeWithScoresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) ZRevRangeWithScoresReturns(result1 *redisa.ZSliceCmd) {
	fake.zRevRangeWithScoresMutex.Lock()
	defer fake.zRevRangeWithScoresMutex.Unlock()
	fake.ZRevRangeWithScoresStub = nil
	fake.zRevRangeWithScoresReturns = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRevRangeWithScoresReturnsOnCall(i int, result1 *redisa.ZSliceCmd) {
	fake.zRevRangeWithScoresMutex.Lock()
	defer fake.zRevRangeWithScoresMutex.Unlock()
	fake.ZRevRangeWithScoresStub = nil
	if fake.zRevRangeWithScoresReturnsOnCall == nil {
		fake.zRevRangeWithScoresReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZSliceCmd
		})
	}
	fake.zRevRangeWithScoresReturnsOnCall[i] = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZRevRank(arg1 context.Context, arg2 string, arg3 string) *redisa.IntCmd {
	fake.zRevRankMutex.Lock()
	ret, specificReturn := fake.zRevRankReturnsOnCall[len(fake.zRevRankArgsForCall)]
	fake.zRevRankArgsForCall = append(fake.zRevRankArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ZRevRankStub
	fakeReturns := fake.zRevRankReturns
	fake.recordInvocation("ZRevRank", []interface{}{arg1, arg2, arg3})
	fake.zRevRankMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRevRankCallCount() int {
	fake.zRevRankMutex.RLock()
	defer fake.zRevRankMutex.RUnlock()
	return len(fake.zRevRankArgsForCall)
}

func (fake *FakeClient) ZRevRankCalls(stub func(context.Context, string, string) *redisa.IntCmd) {
	fake.zRevRankMutex.Lock()
	defer fake.zRevRankMutex.Unlock()
	fake.ZRevRankStub = stub
}

func (fake *FakeClient) ZRevRankArgsForCall(i int) (context.Context, string, string) {
	fake.zRevRankMutex.RLock()
	defer fake.zRevRankMutex.RUnlock()
	argsForCall := fake.zRevRankArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRevRankReturns(result1 *redisa.IntCmd) {
	fake.zRevRankMutex.Lock()
	defer fake.zRevRankMutex.Unlock()
	fake.ZRevRankStub = nil
	fake.zRevRankReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRevRankReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zRevRankMutex.Lock()
	defer fake.zRevRankMutex.Unlock()
	fake.ZRevRankStub = nil
	if fake.zRevRankReturnsOnCall == nil {
		fake.zRevRankReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zRevRankReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZRevRankWithScore(arg1 context.Context, arg2 string, arg3 string) *redisa.RankWithScoreCmd {
	fake.zRevRankWithScoreMutex.Lock()
	ret, specificReturn := fake.zRevRankWithScoreReturnsOnCall[len(fake.zRevRankWithScoreArgsForCall)]
	fake.zRevRankWithScoreArgsForCall = append(fake.zRevRankWithScoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ZRevRankWithScoreStub
	fakeReturns := fake.zRevRankWithScoreReturns
	fake.recordInvocation("ZRevRankWithScore", []interface{}{arg1, arg2, arg3})
	fake.zRevRankWithScoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZRevRankWithScoreCallCount() int {
	fake.zRevRankWithScoreMutex.RLock()
	defer fake.zRevRankWithScoreMutex.RUnlock()
	return len(fake.zRevRankWithScoreArgsForCall)
}

func (fake *FakeClient) ZRevRankWithScoreCalls(stub func(context.Context, string, string) *redisa.RankWithScoreCmd) {
	fake.zRevRankWithScoreMutex.Lock()
	defer fake.zRevRankWithScoreMutex.Unlock()
	fake.ZRevRankWithScoreStub = stub
}

func (fake *FakeClient) ZRevRankWithScoreArgsForCall(i int) (context.Context, string, string) {
	fake.zRevRankWithScoreMutex.RLock()
	defer fake.zRevRankWithScoreMutex.RUnlock()
	argsForCall := fake.zRevRankWithScoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZRevRankWithScoreReturns(result1 *redisa.RankWithScoreCmd) {
	fake.zRevRankWithScoreMutex.Lock()
	defer fake.zRevRankWithScoreMutex.Unlock()
	fake.ZRevRankWithScoreStub = nil
	fake.zRevRankWithScoreReturns = struct {
		result1 *redisa.RankWithScoreCmd
	}{result1}
}

func (fake *FakeClient) ZRevRankWithScoreReturnsOnCall(i int, result1 *redisa.RankWithScoreCmd) {
	fake.zRevRankWithScoreMutex.Lock()
	defer fake.zRevRankWithScoreMutex.Unlock()
	fake.ZRevRankWithScoreStub = nil
	if fake.zRevRankWithScoreReturnsOnCall == nil {
		fake.zRevRankWithScoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.RankWithScoreCmd
		})
	}
	fake.zRevRankWithScoreReturnsOnCall[i] = struct {
		result1 *redisa.RankWithScoreCmd
	}{result1}
}

func (fake *FakeClient) ZScan(arg1 context.Context, arg2 string, arg3 uint64, arg4 string, arg5 int64) *redisa.ScanCmd {
	fake.zScanMutex.Lock()
	ret, specificReturn := fake.zScanReturnsOnCall[len(fake.zScanArgsForCall)]
	fake.zScanArgsForCall = append(fake.zScanArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 uint64
		arg4 string
		arg5 int64
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ZScanStub
	fakeReturns := fake.zScanReturns
	fake.recordInvocation("ZScan", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.zScanMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZScanCallCount() int {
	fake.zScanMutex.RLock()
	defer fake.zScanMutex.RUnlock()
	return len(fake.zScanArgsForCall)
}

func (fake *FakeClient) ZScanCalls(stub func(context.Context, string, uint64, string, int64) *redisa.ScanCmd) {
	fake.zScanMutex.Lock()
	defer fake.zScanMutex.Unlock()
	fake.ZScanStub = stub
}

func (fake *FakeClient) ZScanArgsForCall(i int) (context.Context, string, uint64, string, int64) {
	fake.zScanMutex.RLock()
	defer fake.zScanMutex.RUnlock()
	argsForCall := fake.zScanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) ZScanReturns(result1 *redisa.ScanCmd) {
	fake.zScanMutex.Lock()
	defer fake.zScanMutex.Unlock()
	fake.ZScanStub = nil
	fake.zScanReturns = struct {
		result1 *redisa.ScanCmd
	}{result1}
}

func (fake *FakeClient) ZScanReturnsOnCall(i int, result1 *redisa.ScanCmd) {
	fake.zScanMutex.Lock()
	defer fake.zScanMutex.Unlock()
	fake.ZScanStub = nil
	if fake.zScanReturnsOnCall == nil {
		fake.zScanReturnsOnCall = make(map[int]struct {
			result1 *redisa.ScanCmd
		})
	}
	fake.zScanReturnsOnCall[i] = struct {
		result1 *redisa.ScanCmd
	}{result1}
}

func (fake *FakeClient) ZScore(arg1 context.Context, arg2 string, arg3 string) *redisa.FloatCmd {
	fake.zScoreMutex.Lock()
	ret, specificReturn := fake.zScoreReturnsOnCall[len(fake.zScoreArgsForCall)]
	fake.zScoreArgsForCall = append(fake.zScoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ZScoreStub
	fakeReturns := fake.zScoreReturns
	fake.recordInvocation("ZScore", []interface{}{arg1, arg2, arg3})
	fake.zScoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZScoreCallCount() int {
	fake.zScoreMutex.RLock()
	defer fake.zScoreMutex.RUnlock()
	return len(fake.zScoreArgsForCall)
}

func (fake *FakeClient) ZScoreCalls(stub func(context.Context, string, string) *redisa.FloatCmd) {
	fake.zScoreMutex.Lock()
	defer fake.zScoreMutex.Unlock()
	fake.ZScoreStub = stub
}

func (fake *FakeClient) ZScoreArgsForCall(i int) (context.Context, string, string) {
	fake.zScoreMutex.RLock()
	defer fake.zScoreMutex.RUnlock()
	argsForCall := fake.zScoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZScoreReturns(result1 *redisa.FloatCmd) {
	fake.zScoreMutex.Lock()
	defer fake.zScoreMutex.Unlock()
	fake.ZScoreStub = nil
	fake.zScoreReturns = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) ZScoreReturnsOnCall(i int, result1 *redisa.FloatCmd) {
	fake.zScoreMutex.Lock()
	defer fake.zScoreMutex.Unlock()
	fake.ZScoreStub = nil
	if fake.zScoreReturnsOnCall == nil {
		fake.zScoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.FloatCmd
		})
	}
	fake.zScoreReturnsOnCall[i] = struct {
		result1 *redisa.FloatCmd
	}{result1}
}

func (fake *FakeClient) ZUnion(arg1 context.Context, arg2 redisa.ZStore) *redisa.StringSliceCmd {
	fake.zUnionMutex.Lock()
	ret, specificReturn := fake.zUnionReturnsOnCall[len(fake.zUnionArgsForCall)]
	fake.zUnionArgsForCall = append(fake.zUnionArgsForCall, struct {
		arg1 context.Context
		arg2 redisa.ZStore
	}{arg1, arg2})
	stub := fake.ZUnionStub
	fakeReturns := fake.zUnionReturns
	fake.recordInvocation("ZUnion", []interface{}{arg1, arg2})
	fake.zUnionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZUnionCallCount() int {
	fake.zUnionMutex.RLock()
	defer fake.zUnionMutex.RUnlock()
	return len(fake.zUnionArgsForCall)
}

func (fake *FakeClient) ZUnionCalls(stub func(context.Context, redisa.ZStore) *redisa.StringSliceCmd) {
	fake.zUnionMutex.Lock()
	defer fake.zUnionMutex.Unlock()
	fake.ZUnionStub = stub
}

func (fake *FakeClient) ZUnionArgsForCall(i int) (context.Context, redisa.ZStore) {
	fake.zUnionMutex.RLock()
	defer fake.zUnionMutex.RUnlock()
	argsForCall := fake.zUnionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ZUnionReturns(result1 *redisa.StringSliceCmd) {
	fake.zUnionMutex.Lock()
	defer fake.zUnionMutex.Unlock()
	fake.ZUnionStub = nil
	fake.zUnionReturns = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZUnionReturnsOnCall(i int, result1 *redisa.StringSliceCmd) {
	fake.zUnionMutex.Lock()
	defer fake.zUnionMutex.Unlock()
	fake.ZUnionStub = nil
	if fake.zUnionReturnsOnCall == nil {
		fake.zUnionReturnsOnCall = make(map[int]struct {
			result1 *redisa.StringSliceCmd
		})
	}
	fake.zUnionReturnsOnCall[i] = struct {
		result1 *redisa.StringSliceCmd
	}{result1}
}

func (fake *FakeClient) ZUnionStore(arg1 context.Context, arg2 string, arg3 *redisa.ZStore) *redisa.IntCmd {
	fake.zUnionStoreMutex.Lock()
	ret, specificReturn := fake.zUnionStoreReturnsOnCall[len(fake.zUnionStoreArgsForCall)]
	fake.zUnionStoreArgsForCall = append(fake.zUnionStoreArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *redisa.ZStore
	}{arg1, arg2, arg3})
	stub := fake.ZUnionStoreStub
	fakeReturns := fake.zUnionStoreReturns
	fake.recordInvocation("ZUnionStore", []interface{}{arg1, arg2, arg3})
	fake.zUnionStoreMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZUnionStoreCallCount() int {
	fake.zUnionStoreMutex.RLock()
	defer fake.zUnionStoreMutex.RUnlock()
	return len(fake.zUnionStoreArgsForCall)
}

func (fake *FakeClient) ZUnionStoreCalls(stub func(context.Context, string, *redisa.ZStore) *redisa.IntCmd) {
	fake.zUnionStoreMutex.Lock()
	defer fake.zUnionStoreMutex.Unlock()
	fake.ZUnionStoreStub = stub
}

func (fake *FakeClient) ZUnionStoreArgsForCall(i int) (context.Context, string, *redisa.ZStore) {
	fake.zUnionStoreMutex.RLock()
	defer fake.zUnionStoreMutex.RUnlock()
	argsForCall := fake.zUnionStoreArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ZUnionStoreReturns(result1 *redisa.IntCmd) {
	fake.zUnionStoreMutex.Lock()
	defer fake.zUnionStoreMutex.Unlock()
	fake.ZUnionStoreStub = nil
	fake.zUnionStoreReturns = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZUnionStoreReturnsOnCall(i int, result1 *redisa.IntCmd) {
	fake.zUnionStoreMutex.Lock()
	defer fake.zUnionStoreMutex.Unlock()
	fake.ZUnionStoreStub = nil
	if fake.zUnionStoreReturnsOnCall == nil {
		fake.zUnionStoreReturnsOnCall = make(map[int]struct {
			result1 *redisa.IntCmd
		})
	}
	fake.zUnionStoreReturnsOnCall[i] = struct {
		result1 *redisa.IntCmd
	}{result1}
}

func (fake *FakeClient) ZUnionWithScores(arg1 context.Context, arg2 redisa.ZStore) *redisa.ZSliceCmd {
	fake.zUnionWithScoresMutex.Lock()
	ret, specificReturn := fake.zUnionWithScoresReturnsOnCall[len(fake.zUnionWithScoresArgsForCall)]
	fake.zUnionWithScoresArgsForCall = append(fake.zUnionWithScoresArgsForCall, struct {
		arg1 context.Context
		arg2 redisa.ZStore
	}{arg1, arg2})
	stub := fake.ZUnionWithScoresStub
	fakeReturns := fake.zUnionWithScoresReturns
	fake.recordInvocation("ZUnionWithScores", []interface{}{arg1, arg2})
	fake.zUnionWithScoresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ZUnionWithScoresCallCount() int {
	fake.zUnionWithScoresMutex.RLock()
	defer fake.zUnionWithScoresMutex.RUnlock()
	return len(fake.zUnionWithScoresArgsForCall)
}

func (fake *FakeClient) ZUnionWithScoresCalls(stub func(context.Context, redisa.ZStore) *redisa.ZSliceCmd) {
	fake.zUnionWithScoresMutex.Lock()
	defer fake.zUnionWithScoresMutex.Unlock()
	fake.ZUnionWithScoresStub = stub
}

func (fake *FakeClient) ZUnionWithScoresArgsForCall(i int) (context.Context, redisa.ZStore) {
	fake.zUnionWithScoresMutex.RLock()
	defer fake.zUnionWithScoresMutex.RUnlock()
	argsForCall := fake.zUnionWithScoresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ZUnionWithScoresReturns(result1 *redisa.ZSliceCmd) {
	fake.zUnionWithScoresMutex.Lock()
	defer fake.zUnionWithScoresMutex.Unlock()
	fake.ZUnionWithScoresStub = nil
	fake.zUnionWithScoresReturns = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) ZUnionWithScoresReturnsOnCall(i int, result1 *redisa.ZSliceCmd) {
	fake.zUnionWithScoresMutex.Lock()
	defer fake.zUnionWithScoresMutex.Unlock()
	fake.ZUnionWithScoresStub = nil
	if fake.zUnionWithScoresReturnsOnCall == nil {
		fake.zUnionWithScoresReturnsOnCall = make(map[int]struct {
			result1 *redisa.ZSliceCmd
		})
	}
	fake.zUnionWithScoresReturnsOnCall[i] = struct {
		result1 *redisa.ZSliceCmd
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.aCLDryRunMutex.RLock()
	defer fake.aCLDryRunMutex.RUnlock()
	fake.aCLLogMutex.RLock()
	defer fake.aCLLogMutex.RUnlock()
	fake.aCLLogResetMutex.RLock()
	defer fake.aCLLogResetMutex.RUnlock()
	fake.appendMutex.RLock()
	defer fake.appendMutex.RUnlock()
	fake.bFAddMutex.RLock()
	defer fake.bFAddMutex.RUnlock()
	fake.bFCardMutex.RLock()
	defer fake.bFCardMutex.RUnlock()
	fake.bFExistsMutex.RLock()
	defer fake.bFExistsMutex.RUnlock()
	fake.bFInfoMutex.RLock()
	defer fake.bFInfoMutex.RUnlock()
	fake.bFInfoArgMutex.RLock()
	defer fake.bFInfoArgMutex.RUnlock()
	fake.bFInfoCapacityMutex.RLock()
	defer fake.bFInfoCapacityMutex.RUnlock()
	fake.bFInfoExpansionMutex.RLock()
	defer fake.bFInfoExpansionMutex.RUnlock()
	fake.bFInfoFiltersMutex.RLock()
	defer fake.bFInfoFiltersMutex.RUnlock()
	fake.bFInfoItemsMutex.RLock()
	defer fake.bFInfoItemsMutex.RUnlock()
	fake.bFInfoSizeMutex.RLock()
	defer fake.bFInfoSizeMutex.RUnlock()
	fake.bFInsertMutex.RLock()
	defer fake.bFInsertMutex.RUnlock()
	fake.bFLoadChunkMutex.RLock()
	defer fake.bFLoadChunkMutex.RUnlock()
	fake.bFMAddMutex.RLock()
	defer fake.bFMAddMutex.RUnlock()
	fake.bFMExistsMutex.RLock()
	defer fake.bFMExistsMutex.RUnlock()
	fake.bFReserveMutex.RLock()
	defer fake.bFReserveMutex.RUnlock()
	fake.bFReserveExpansionMutex.RLock()
	defer fake.bFReserveExpansionMutex.RUnlock()
	fake.bFReserveNonScalingMutex.RLock()
	defer fake.bFReserveNonScalingMutex.RUnlock()
	fake.bFReserveWithArgsMutex.RLock()
	defer fake.bFReserveWithArgsMutex.RUnlock()
	fake.bFScanDumpMutex.RLock()
	defer fake.bFScanDumpMutex.RUnlock()
	fake.bLMPopMutex.RLock()
	defer fake.bLMPopMutex.RUnlock()
	fake.bLMoveMutex.RLock()
	defer fake.bLMoveMutex.RUnlock()
	fake.bLPopMutex.RLock()
	defer fake.bLPopMutex.RUnlock()
	fake.bRPopMutex.RLock()
	defer fake.bRPopMutex.RUnlock()
	fake.bRPopLPushMutex.RLock()
	defer fake.bRPopLPushMutex.RUnlock()
	fake.bZMPopMutex.RLock()
	defer fake.bZMPopMutex.RUnlock()
	fake.bZPopMaxMutex.RLock()
	defer fake.bZPopMaxMutex.RUnlock()
	fake.bZPopMinMutex.RLock()
	defer fake.bZPopMinMutex.RUnlock()
	fake.bgRewriteAOFMutex.RLock()
	defer fake.bgRewriteAOFMutex.RUnlock()
	fake.bgSaveMutex.RLock()
	defer fake.bgSaveMutex.RUnlock()
	fake.bitCountMutex.RLock()
	defer fake.bitCountMutex.RUnlock()
	fake.bitFieldMutex.RLock()
	defer fake.bitFieldMutex.RUnlock()
	fake.bitFieldROMutex.RLock()
	defer fake.bitFieldROMutex.RUnlock()
	fake.bitOpAndMutex.RLock()
	defer fake.bitOpAndMutex.RUnlock()
	fake.bitOpNotMutex.RLock()
	defer fake.bitOpNotMutex.RUnlock()
	fake.bitOpOrMutex.RLock()
	defer fake.bitOpOrMutex.RUnlock()
	fake.bitOpXorMutex.RLock()
	defer fake.bitOpXorMutex.RUnlock()
	fake.bitPosMutex.RLock()
	defer fake.bitPosMutex.RUnlock()
	fake.bitPosSpanMutex.RLock()
	defer fake.bitPosSpanMutex.RUnlock()
	fake.cFAddMutex.RLock()
	defer fake.cFAddMutex.RUnlock()
	fake.cFAddNXMutex.RLock()
	defer fake.cFAddNXMutex.RUnlock()
	fake.cFCountMutex.RLock()
	defer fake.cFCountMutex.RUnlock()
	fake.cFDelMutex.RLock()
	defer fake.cFDelMutex.RUnlock()
	fake.cFExistsMutex.RLock()
	defer fake.cFExistsMutex.RUnlock()
	fake.cFInfoMutex.RLock()
	defer fake.cFInfoMutex.RUnlock()
	fake.cFInsertMutex.RLock()
	defer fake.cFInsertMutex.RUnlock()
	fake.cFInsertNXMutex.RLock()
	defer fake.cFInsertNXMutex.RUnlock()
	fake.cFLoadChunkMutex.RLock()
	defer fake.cFLoadChunkMutex.RUnlock()
	fake.cFMExistsMutex.RLock()
	defer fake.cFMExistsMutex.RUnlock()
	fake.cFReserveMutex.RLock()
	defer fake.cFReserveMutex.RUnlock()
	fake.cFReserveBucketSizeMutex.RLock()
	defer fake.cFReserveBucketSizeMutex.RUnlock()
	fake.cFReserveExpansionMutex.RLock()
	defer fake.cFReserveExpansionMutex.RUnlock()
	fake.cFReserveMaxIterationsMutex.RLock()
	defer fake.cFReserveMaxIterationsMutex.RUnlock()
	fake.cFReserveWithArgsMutex.RLock()
	defer fake.cFReserveWithArgsMutex.RUnlock()
	fake.cFScanDumpMutex.RLock()
	defer fake.cFScanDumpMutex.RUnlock()
	fake.cMSIncrByMutex.RLock()
	defer fake.cMSIncrByMutex.RUnlock()
	fake.cMSInfoMutex.RLock()
	defer fake.cMSInfoMutex.RUnlock()
	fake.cMSInitByDimMutex.RLock()
	defer fake.cMSInitByDimMutex.RUnlock()
	fake.cMSInitByProbMutex.RLock()
	defer fake.cMSInitByProbMutex.RUnlock()
	fake.cMSMergeMutex.RLock()
	defer fake.cMSMergeMutex.RUnlock()
	fake.cMSMergeWithWeightMutex.RLock()
	defer fake.cMSMergeWithWeightMutex.RUnlock()
	fake.cMSQueryMutex.RLock()
	defer fake.cMSQueryMutex.RUnlock()
	fake.clientGetNameMutex.RLock()
	defer fake.clientGetNameMutex.RUnlock()
	fake.clientIDMutex.RLock()
	defer fake.clientIDMutex.RUnlock()
	fake.clientInfoMutex.RLock()
	defer fake.clientInfoMutex.RUnlock()
	fake.clientKillMutex.RLock()
	defer fake.clientKillMutex.RUnlock()
	fake.clientKillByFilterMutex.RLock()
	defer fake.clientKillByFilterMutex.RUnlock()
	fake.clientListMutex.RLock()
	defer fake.clientListMutex.RUnlock()
	fake.clientPauseMutex.RLock()
	defer fake.clientPauseMutex.RUnlock()
	fake.clientUnblockMutex.RLock()
	defer fake.clientUnblockMutex.RUnlock()
	fake.clientUnblockWithErrorMutex.RLock()
	defer fake.clientUnblockWithErrorMutex.RUnlock()
	fake.clientUnpauseMutex.RLock()
	defer fake.clientUnpauseMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.clusterAddSlotsMutex.RLock()
	defer fake.clusterAddSlotsMutex.RUnlock()
	fake.clusterAddSlotsRangeMutex.RLock()
	defer fake.clusterAddSlotsRangeMutex.RUnlock()
	fake.clusterCountFailureReportsMutex.RLock()
	defer fake.clusterCountFailureReportsMutex.RUnlock()
	fake.clusterCountKeysInSlotMutex.RLock()
	defer fake.clusterCountKeysInSlotMutex.RUnlock()
	fake.clusterDelSlotsMutex.RLock()
	defer fake.clusterDelSlotsMutex.RUnlock()
	fake.clusterDelSlotsRangeMutex.RLock()
	defer fake.clusterDelSlotsRangeMutex.RUnlock()
	fake.clusterFailoverMutex.RLock()
	defer fake.clusterFailoverMutex.RUnlock()
	fake.clusterForgetMutex.RLock()
	defer fake.clusterForgetMutex.RUnlock()
	fake.clusterGetKeysInSlotMutex.RLock()
	defer fake.clusterGetKeysInSlotMutex.RUnlock()
	fake.clusterInfoMutex.RLock()
	defer fake.clusterInfoMutex.RUnlock()
	fake.clusterKeySlotMutex.RLock()
	defer fake.clusterKeySlotMutex.RUnlock()
	fake.clusterLinksMutex.RLock()
	defer fake.clusterLinksMutex.RUnlock()
	fake.clusterMeetMutex.RLock()
	defer fake.clusterMeetMutex.RUnlock()
	fake.clusterMyShardIDMutex.RLock()
	defer fake.clusterMyShardIDMutex.RUnlock()
	fake.clusterNodesMutex.RLock()
	defer fake.clusterNodesMutex.RUnlock()
	fake.clusterReplicateMutex.RLock()
	defer fake.clusterReplicateMutex.RUnlock()
	fake.clusterResetHardMutex.RLock()
	defer fake.clusterResetHardMutex.RUnlock()
	fake.clusterResetSoftMutex.RLock()
	defer fake.clusterResetSoftMutex.RUnlock()
	fake.clusterSaveConfigMutex.RLock()
	defer fake.clusterSaveConfigMutex.RUnlock()
	fake.clusterShardsMutex.RLock()
	defer fake.clusterShardsMutex.RUnlock()
	fake.clusterSlavesMutex.RLock()
	defer fake.clusterSlavesMutex.RUnlock()
	fake.clusterSlotsMutex.RLock()
	defer fake.clusterSlotsMutex.RUnlock()
	fake.commandMutex.RLock()
	defer fake.commandMutex.RUnlock()
	fake.commandGetKeysMutex.RLock()
	defer fake.commandGetKeysMutex.RUnlock()
	fake.commandGetKeysAndFlagsMutex.RLock()
	defer fake.commandGetKeysAndFlagsMutex.RUnlock()
	fake.commandListMutex.RLock()
	defer fake.commandListMutex.RUnlock()
	fake.configGetMutex.RLock()
	defer fake.configGetMutex.RUnlock()
	fake.configResetStatMutex.RLock()
	defer fake.configResetStatMutex.RUnlock()
	fake.configRewriteMutex.RLock()
	defer fake.configRewriteMutex.RUnlock()
	fake.configSetMutex.RLock()
	defer fake.configSetMutex.RUnlock()
	fake.copyMutex.RLock()
	defer fake.copyMutex.RUnlock()
	fake.dBSizeMutex.RLock()
	defer fake.dBSizeMutex.RUnlock()
	fake.debugObjectMutex.RLock()
	defer fake.debugObjectMutex.RUnlock()
	fake.decrMutex.RLock()
	defer fake.decrMutex.RUnlock()
	fake.decrByMutex.RLock()
	defer fake.decrByMutex.RUnlock()
	fake.delMutex.RLock()
	defer fake.delMutex.RUnlock()
	fake.dumpMutex.RLock()
	defer fake.dumpMutex.RUnlock()
	fake.echoMutex.RLock()
	defer fake.echoMutex.RUnlock()
	fake.evalMutex.RLock()
	defer fake.evalMutex.RUnlock()
	fake.evalROMutex.RLock()
	defer fake.evalROMutex.RUnlock()
	fake.evalShaMutex.RLock()
	defer fake.evalShaMutex.RUnlock()
	fake.evalShaROMutex.RLock()
	defer fake.evalShaROMutex.RUnlock()
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	fake.expireMutex.RLock()
	defer fake.expireMutex.RUnlock()
	fake.expireAtMutex.RLock()
	defer fake.expireAtMutex.RUnlock()
	fake.expireGTMutex.RLock()
	defer fake.expireGTMutex.RUnlock()
	fake.expireLTMutex.RLock()
	defer fake.expireLTMutex.RUnlock()
	fake.expireNXMutex.RLock()
	defer fake.expireNXMutex.RUnlock()
	fake.expireTimeMutex.RLock()
	defer fake.expireTimeMutex.RUnlock()
	fake.expireXXMutex.RLock()
	defer fake.expireXXMutex.RUnlock()
	fake.fCallMutex.RLock()
	defer fake.fCallMutex.RUnlock()
	fake.fCallROMutex.RLock()
	defer fake.fCallROMutex.RUnlock()
	fake.fCallRoMutex.RLock()
	defer fake.fCallRoMutex.RUnlock()
	fake.fTAggregateMutex.RLock()
	defer fake.fTAggregateMutex.RUnlock()
	fake.fTAggregateWithArgsMutex.RLock()
	defer fake.fTAggregateWithArgsMutex.RUnlock()
	fake.fTAliasAddMutex.RLock()
	defer fake.fTAliasAddMutex.RUnlock()
	fake.fTAliasDelMutex.RLock()
	defer fake.fTAliasDelMutex.RUnlock()
	fake.fTAliasUpdateMutex.RLock()
	defer fake.fTAliasUpdateMutex.RUnlock()
	fake.fTAlterMutex.RLock()
	defer fake.fTAlterMutex.RUnlock()
	fake.fTConfigGetMutex.RLock()
	defer fake.fTConfigGetMutex.RUnlock()
	fake.fTConfigSetMutex.RLock()
	defer fake.fTConfigSetMutex.RUnlock()
	fake.fTCreateMutex.RLock()
	defer fake.fTCreateMutex.RUnlock()
	fake.fTCursorDelMutex.RLock()
	defer fake.fTCursorDelMutex.RUnlock()
	fake.fTCursorReadMutex.RLock()
	defer fake.fTCursorReadMutex.RUnlock()
	fake.fTDictAddMutex.RLock()
	defer fake.fTDictAddMutex.RUnlock()
	fake.fTDictDelMutex.RLock()
	defer fake.fTDictDelMutex.RUnlock()
	fake.fTDictDumpMutex.RLock()
	defer fake.fTDictDumpMutex.RUnlock()
	fake.fTDropIndexMutex.RLock()
	defer fake.fTDropIndexMutex.RUnlock()
	fake.fTDropIndexWithArgsMutex.RLock()
	defer fake.fTDropIndexWithArgsMutex.RUnlock()
	fake.fTExplainMutex.RLock()
	defer fake.fTExplainMutex.RUnlock()
	fake.fTExplainWithArgsMutex.RLock()
	defer fake.fTExplainWithArgsMutex.RUnlock()
	fake.fTInfoMutex.RLock()
	defer fake.fTInfoMutex.RUnlock()
	fake.fTSearchMutex.RLock()
	defer fake.fTSearchMutex.RUnlock()
	fake.fTSearchWithArgsMutex.RLock()
	defer fake.fTSearchWithArgsMutex.RUnlock()
	fake.fTSpellCheckMutex.RLock()
	defer fake.fTSpellCheckMutex.RUnlock()
	fake.fTSpellCheckWithArgsMutex.RLock()
	defer fake.fTSpellCheckWithArgsMutex.RUnlock()
	fake.fTSynDumpMutex.RLock()
	defer fake.fTSynDumpMutex.RUnlock()
	fake.fTSynUpdateMutex.RLock()
	defer fake.fTSynUpdateMutex.RUnlock()
	fake.fTSynUpdateWithArgsMutex.RLock()
	defer fake.fTSynUpdateWithArgsMutex.RUnlock()
	fake.fTTagValsMutex.RLock()
	defer fake.fTTagValsMutex.RUnlock()
	fake.fT_ListMutex.RLock()
	defer fake.fT_ListMutex.RUnlock()
	fake.flushAllMutex.RLock()
	defer fake.flushAllMutex.RUnlock()
	fake.flushAllAsyncMutex.RLock()
	defer fake.flushAllAsyncMutex.RUnlock()
	fake.flushDBMutex.RLock()
	defer fake.flushDBMutex.RUnlock()
	fake.flushDBAsyncMutex.RLock()
	defer fake.flushDBAsyncMutex.RUnlock()
	fake.functionDeleteMutex.RLock()
	defer fake.functionDeleteMutex.RUnlock()
	fake.functionDumpMutex.RLock()
	defer fake.functionDumpMutex.RUnlock()
	fake.functionFlushMutex.RLock()
	defer fake.functionFlushMutex.RUnlock()
	fake.functionFlushAsyncMutex.RLock()
	defer fake.functionFlushAsyncMutex.RUnlock()
	fake.functionKillMutex.RLock()
	defer fake.functionKillMutex.RUnlock()
	fake.functionListMutex.RLock()
	defer fake.functionListMutex.RUnlock()
	fake.functionLoadMutex.RLock()
	defer fake.functionLoadMutex.RUnlock()
	fake.functionLoadReplaceMutex.RLock()
	defer fake.functionLoadReplaceMutex.RUnlock()
	fake.functionRestoreMutex.RLock()
	defer fake.functionRestoreMutex.RUnlock()
	fake.functionStatsMutex.RLock()
	defer fake.functionStatsMutex.RUnlock()
	fake.geoAddMutex.RLock()
	defer fake.geoAddMutex.RUnlock()
	fake.geoDistMutex.RLock()
	defer fake.geoDistMutex.RUnlock()
	fake.geoHashMutex.RLock()
	defer fake.geoHashMutex.RUnlock()
	fake.geoPosMutex.RLock()
	defer fake.geoPosMutex.RUnlock()
	fake.geoRadiusMutex.RLock()
	defer fake.geoRadiusMutex.RUnlock()
	fake.geoRadiusByMemberMutex.RLock()
	defer fake.geoRadiusByMemberMutex.RUnlock()
	fake.geoRadiusByMemberStoreMutex.RLock()
	defer fake.geoRadiusByMemberStoreMutex.RUnlock()
	fake.geoRadiusStoreMutex.RLock()
	defer fake.geoRadiusStoreMutex.RUnlock()
	fake.geoSearchMutex.RLock()
	defer fake.geoSearchMutex.RUnlock()
	fake.geoSearchLocationMutex.RLock()
	defer fake.geoSearchLocationMutex.RUnlock()
	fake.geoSearchStoreMutex.RLock()
	defer fake.geoSearchStoreMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getBitMutex.RLock()
	defer fake.getBitMutex.RUnlock()
	fake.getDelMutex.RLock()
	defer fake.getDelMutex.RUnlock()
	fake.getExMutex.RLock()
	defer fake.getExMutex.RUnlock()
	fake.getRangeMutex.RLock()
	defer fake.getRangeMutex.RUnlock()
	fake.getSetMutex.RLock()
	defer fake.getSetMutex.RUnlock()
	fake.hDelMutex.RLock()
	defer fake.hDelMutex.RUnlock()
	fake.hExistsMutex.RLock()
	defer fake.hExistsMutex.RUnlock()
	fake.hExpireMutex.RLock()
	defer fake.hExpireMutex.RUnlock()
	fake.hExpireAtMutex.RLock()
	defer fake.hExpireAtMutex.RUnlock()
	fake.hExpireAtWithArgsMutex.RLock()
	defer fake.hExpireAtWithArgsMutex.RUnlock()
	fake.hExpireTimeMutex.RLock()
	defer fake.hExpireTimeMutex.RUnlock()
	fake.hExpireWithArgsMutex.RLock()
	defer fake.hExpireWithArgsMutex.RUnlock()
	fake.hGetMutex.RLock()
	defer fake.hGetMutex.RUnlock()
	fake.hGetAllMutex.RLock()
	defer fake.hGetAllMutex.RUnlock()
	fake.hIncrByMutex.RLock()
	defer fake.hIncrByMutex.RUnlock()
	fake.hIncrByFloatMutex.RLock()
	defer fake.hIncrByFloatMutex.RUnlock()
	fake.hKeysMutex.RLock()
	defer fake.hKeysMutex.RUnlock()
	fake.hLenMutex.RLock()
	defer fake.hLenMutex.RUnlock()
	fake.hMGetMutex.RLock()
	defer fake.hMGetMutex.RUnlock()
	fake.hMSetMutex.RLock()
	defer fake.hMSetMutex.RUnlock()
	fake.hPExpireMutex.RLock()
	defer fake.hPExpireMutex.RUnlock()
	fake.hPExpireAtMutex.RLock()
	defer fake.hPExpireAtMutex.RUnlock()
	fake.hPExpireAtWithArgsMutex.RLock()
	defer fake.hPExpireAtWithArgsMutex.RUnlock()
	fake.hPExpireTimeMutex.RLock()
	defer fake.hPExpireTimeMutex.RUnlock()
	fake.hPExpireWithArgsMutex.RLock()
	defer fake.hPExpireWithArgsMutex.RUnlock()
	fake.hPTTLMutex.RLock()
	defer fake.hPTTLMutex.RUnlock()
	fake.hPersistMutex.RLock()
	defer fake.hPersistMutex.RUnlock()
	fake.hRandFieldMutex.RLock()
	defer fake.hRandFieldMutex.RUnlock()
	fake.hRandFieldWithValuesMutex.RLock()
	defer fake.hRandFieldWithValuesMutex.RUnlock()
	fake.hScanMutex.RLock()
	defer fake.hScanMutex.RUnlock()
	fake.hScanNoValuesMutex.RLock()
	defer fake.hScanNoValuesMutex.RUnlock()
	fake.hSetMutex.RLock()
	defer fake.hSetMutex.RUnlock()
	fake.hSetNXMutex.RLock()
	defer fake.hSetNXMutex.RUnlock()
	fake.hTTLMutex.RLock()
	defer fake.hTTLMutex.RUnlock()
	fake.hValsMutex.RLock()
	defer fake.hValsMutex.RUnlock()
	fake.incrMutex.RLock()
	defer fake.incrMutex.RUnlock()
	fake.incrByMutex.RLock()
	defer fake.incrByMutex.RUnlock()
	fake.incrByFloatMutex.RLock()
	defer fake.incrByFloatMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.jSONArrAppendMutex.RLock()
	defer fake.jSONArrAppendMutex.RUnlock()
	fake.jSONArrIndexMutex.RLock()
	defer fake.jSONArrIndexMutex.RUnlock()
	fake.jSONArrIndexWithArgsMutex.RLock()
	defer fake.jSONArrIndexWithArgsMutex.RUnlock()
	fake.jSONArrInsertMutex.RLock()
	defer fake.jSONArrInsertMutex.RUnlock()
	fake.jSONArrLenMutex.RLock()
	defer fake.jSONArrLenMutex.RUnlock()
	fake.jSONArrPopMutex.RLock()
	defer fake.jSONArrPopMutex.RUnlock()
	fake.jSONArrTrimMutex.RLock()
	defer fake.jSONArrTrimMutex.RUnlock()
	fake.jSONArrTrimWithArgsMutex.RLock()
	defer fake.jSONArrTrimWithArgsMutex.RUnlock()
	fake.jSONClearMutex.RLock()
	defer fake.jSONClearMutex.RUnlock()
	fake.jSONDebugMemoryMutex.RLock()
	defer fake.jSONDebugMemoryMutex.RUnlock()
	fake.jSONDelMutex.RLock()
	defer fake.jSONDelMutex.RUnlock()
	fake.jSONForgetMutex.RLock()
	defer fake.jSONForgetMutex.RUnlock()
	fake.jSONGetMutex.RLock()
	defer fake.jSONGetMutex.RUnlock()
	fake.jSONGetWithArgsMutex.RLock()
	defer fake.jSONGetWithArgsMutex.RUnlock()
	fake.jSONMGetMutex.RLock()
	defer fake.jSONMGetMutex.RUnlock()
	fake.jSONMSetMutex.RLock()
	defer fake.jSONMSetMutex.RUnlock()
	fake.jSONMSetArgsMutex.RLock()
	defer fake.jSONMSetArgsMutex.RUnlock()
	fake.jSONMergeMutex.RLock()
	defer fake.jSONMergeMutex.RUnlock()
	fake.jSONNumIncrByMutex.RLock()
	defer fake.jSONNumIncrByMutex.RUnlock()
	fake.jSONObjKeysMutex.RLock()
	defer fake.jSONObjKeysMutex.RUnlock()
	fake.jSONObjLenMutex.RLock()
	defer fake.jSONObjLenMutex.RUnlock()
	fake.jSONSetMutex.RLock()
	defer fake.jSONSetMutex.RUnlock()
	fake.jSONSetModeMutex.RLock()
	defer fake.jSONSetModeMutex.RUnlock()
	fake.jSONStrAppendMutex.RLock()
	defer fake.jSONStrAppendMutex.RUnlock()
	fake.jSONStrLenMutex.RLock()
	defer fake.jSONStrLenMutex.RUnlock()
	fake.jSONToggleMutex.RLock()
	defer fake.jSONToggleMutex.RUnlock()
	fake.jSONTypeMutex.RLock()
	defer fake.jSONTypeMutex.RUnlock()
	fake.keysMutex.RLock()
	defer fake.keysMutex.RUnlock()
	fake.lCSMutex.RLock()
	defer fake.lCSMutex.RUnlock()
	fake.lIndexMutex.RLock()
	defer fake.lIndexMutex.RUnlock()
	fake.lInsertMutex.RLock()
	defer fake.lInsertMutex.RUnlock()
	fake.lInsertAfterMutex.RLock()
	defer fake.lInsertAfterMutex.RUnlock()
	fake.lInsertBeforeMutex.RLock()
	defer fake.lInsertBeforeMutex.RUnlock()
	fake.lLenMutex.RLock()
	defer fake.lLenMutex.RUnlock()
	fake.lMPopMutex.RLock()
	defer fake.lMPopMutex.RUnlock()
	fake.lMoveMutex.RLock()
	defer fake.lMoveMutex.RUnlock()
	fake.lPopMutex.RLock()
	defer fake.lPopMutex.RUnlock()
	fake.lPopCountMutex.RLock()
	defer fake.lPopCountMutex.RUnlock()
	fake.lPosMutex.RLock()
	defer fake.lPosMutex.RUnlock()
	fake.lPosCountMutex.RLock()
	defer fake.lPosCountMutex.RUnlock()
	fake.lPushMutex.RLock()
	defer fake.lPushMutex.RUnlock()
	fake.lPushXMutex.RLock()
	defer fake.lPushXMutex.RUnlock()
	fake.lRangeMutex.RLock()
	defer fake.lRangeMutex.RUnlock()
	fake.lRemMutex.RLock()
	defer fake.lRemMutex.RUnlock()
	fake.lSetMutex.RLock()
	defer fake.lSetMutex.RUnlock()
	fake.lTrimMutex.RLock()
	defer fake.lTrimMutex.RUnlock()
	fake.lastSaveMutex.RLock()
	defer fake.lastSaveMutex.RUnlock()
	fake.mGetMutex.RLock()
	defer fake.mGetMutex.RUnlock()
	fake.mSetMutex.RLock()
	defer fake.mSetMutex.RUnlock()
	fake.mSetNXMutex.RLock()
	defer fake.mSetNXMutex.RUnlock()
	fake.memoryUsageMutex.RLock()
	defer fake.memoryUsageMutex.RUnlock()
	fake.migrateMutex.RLock()
	defer fake.migrateMutex.RUnlock()
	fake.moduleLoadexMutex.RLock()
	defer fake.moduleLoadexMutex.RUnlock()
	fake.moveMutex.RLock()
	defer fake.moveMutex.RUnlock()
	fake.objectEncodingMutex.RLock()
	defer fake.objectEncodingMutex.RUnlock()
	fake.objectFreqMutex.RLock()
	defer fake.objectFreqMutex.RUnlock()
	fake.objectIdleTimeMutex.RLock()
	defer fake.objectIdleTimeMutex.RUnlock()
	fake.objectRefCountMutex.RLock()
	defer fake.objectRefCountMutex.RUnlock()
	fake.pExpireMutex.RLock()
	defer fake.pExpireMutex.RUnlock()
	fake.pExpireAtMutex.RLock()
	defer fake.pExpireAtMutex.RUnlock()
	fake.pExpireTimeMutex.RLock()
	defer fake.pExpireTimeMutex.RUnlock()
	fake.pFAddMutex.RLock()
	defer fake.pFAddMutex.RUnlock()
	fake.pFCountMutex.RLock()
	defer fake.pFCountMutex.RUnlock()
	fake.pFMergeMutex.RLock()
	defer fake.pFMergeMutex.RUnlock()
	fake.pTTLMutex.RLock()
	defer fake.pTTLMutex.RUnlock()
	fake.persistMutex.RLock()
	defer fake.persistMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	fake.pipelinedMutex.RLock()
	defer fake.pipelinedMutex.RUnlock()
	fake.pubSubChannelsMutex.RLock()
	defer fake.pubSubChannelsMutex.RUnlock()
	fake.pubSubNumPatMutex.RLock()
	defer fake.pubSubNumPatMutex.RUnlock()
	fake.pubSubNumSubMutex.RLock()
	defer fake.pubSubNumSubMutex.RUnlock()
	fake.pubSubShardChannelsMutex.RLock()
	defer fake.pubSubShardChannelsMutex.RUnlock()
	fake.pubSubShardNumSubMutex.RLock()
	defer fake.pubSubShardNumSubMutex.RUnlock()
	fake.publishMutex.RLock()
	defer fake.publishMutex.RUnlock()
	fake.quitMutex.RLock()
	defer fake.quitMutex.RUnlock()
	fake.rPopMutex.RLock()
	defer fake.rPopMutex.RUnlock()
	fake.rPopCountMutex.RLock()
	defer fake.rPopCountMutex.RUnlock()
	fake.rPopLPushMutex.RLock()
	defer fake.rPopLPushMutex.RUnlock()
	fake.rPushMutex.RLock()
	defer fake.rPushMutex.RUnlock()
	fake.rPushXMutex.RLock()
	defer fake.rPushXMutex.RUnlock()
	fake.randomKeyMutex.RLock()
	defer fake.randomKeyMutex.RUnlock()
	fake.readOnlyMutex.RLock()
	defer fake.readOnlyMutex.RUnlock()
	fake.readWriteMutex.RLock()
	defer fake.readWriteMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	fake.renameNXMutex.RLock()
	defer fake.renameNXMutex.RUnlock()
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	fake.restoreReplaceMutex.RLock()
	defer fake.restoreReplaceMutex.RUnlock()
	fake.sAddMutex.RLock()
	defer fake.sAddMutex.RUnlock()
	fake.sCardMutex.RLock()
	defer fake.sCardMutex.RUnlock()
	fake.sDiffMutex.RLock()
	defer fake.sDiffMutex.RUnlock()
	fake.sDiffStoreMutex.RLock()
	defer fake.sDiffStoreMutex.RUnlock()
	fake.sInterMutex.RLock()
	defer fake.sInterMutex.RUnlock()
	fake.sInterCardMutex.RLock()
	defer fake.sInterCardMutex.RUnlock()
	fake.sInterStoreMutex.RLock()
	defer fake.sInterStoreMutex.RUnlock()
	fake.sIsMemberMutex.RLock()
	defer fake.sIsMemberMutex.RUnlock()
	fake.sMIsMemberMutex.RLock()
	defer fake.sMIsMemberMutex.RUnlock()
	fake.sMembersMutex.RLock()
	defer fake.sMembersMutex.RUnlock()
	fake.sMembersMapMutex.RLock()
	defer fake.sMembersMapMutex.RUnlock()
	fake.sMoveMutex.RLock()
	defer fake.sMoveMutex.RUnlock()
	fake.sPopMutex.RLock()
	defer fake.sPopMutex.RUnlock()
	fake.sPopNMutex.RLock()
	defer fake.sPopNMutex.RUnlock()
	fake.sPublishMutex.RLock()
	defer fake.sPublishMutex.RUnlock()
	fake.sRandMemberMutex.RLock()
	defer fake.sRandMemberMutex.RUnlock()
	fake.sRandMemberNMutex.RLock()
	defer fake.sRandMemberNMutex.RUnlock()
	fake.sRemMutex.RLock()
	defer fake.sRemMutex.RUnlock()
	fake.sScanMutex.RLock()
	defer fake.sScanMutex.RUnlock()
	fake.sUnionMutex.RLock()
	defer fake.sUnionMutex.RUnlock()
	fake.sUnionStoreMutex.RLock()
	defer fake.sUnionStoreMutex.RUnlock()
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	fake.scanMutex.RLock()
	defer fake.scanMutex.RUnlock()
	fake.scanTypeMutex.RLock()
	defer fake.scanTypeMutex.RUnlock()
	fake.scriptExistsMutex.RLock()
	defer fake.scriptExistsMutex.RUnlock()
	fake.scriptFlushMutex.RLock()
	defer fake.scriptFlushMutex.RUnlock()
	fake.scriptKillMutex.RLock()
	defer fake.scriptKillMutex.RUnlock()
	fake.scriptLoadMutex.RLock()
	defer fake.scriptLoadMutex.RUnlock()
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	fake.setArgsMutex.RLock()
	defer fake.setArgsMutex.RUnlock()
	fake.setBitMutex.RLock()
	defer fake.setBitMutex.RUnlock()
	fake.setExMutex.RLock()
	defer fake.setExMutex.RUnlock()
	fake.setNXMutex.RLock()
	defer fake.setNXMutex.RUnlock()
	fake.setRangeMutex.RLock()
	defer fake.setRangeMutex.RUnlock()
	fake.setXXMutex.RLock()
	defer fake.setXXMutex.RUnlock()
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	fake.shutdownNoSaveMutex.RLock()
	defer fake.shutdownNoSaveMutex.RUnlock()
	fake.shutdownSaveMutex.RLock()
	defer fake.shutdownSaveMutex.RUnlock()
	fake.slaveOfMutex.RLock()
	defer fake.slaveOfMutex.RUnlock()
	fake.slowLogGetMutex.RLock()
	defer fake.slowLogGetMutex.RUnlock()
	fake.sortMutex.RLock()
	defer fake.sortMutex.RUnlock()
	fake.sortInterfacesMutex.RLock()
	defer fake.sortInterfacesMutex.RUnlock()
	fake.sortROMutex.RLock()
	defer fake.sortROMutex.RUnlock()
	fake.sortStoreMutex.RLock()
	defer fake.sortStoreMutex.RUnlock()
	fake.strLenMutex.RLock()
	defer fake.strLenMutex.RUnlock()
	fake.tDigestAddMutex.RLock()
	defer fake.tDigestAddMutex.RUnlock()
	fake.tDigestByRankMutex.RLock()
	defer fake.tDigestByRankMutex.RUnlock()
	fake.tDigestByRevRankMutex.RLock()
	defer fake.tDigestByRevRankMutex.RUnlock()
	fake.tDigestCDFMutex.RLock()
	defer fake.tDigestCDFMutex.RUnlock()
	fake.tDigestCreateMutex.RLock()
	defer fake.tDigestCreateMutex.RUnlock()
	fake.tDigestCreateWithCompressionMutex.RLock()
	defer fake.tDigestCreateWithCompressionMutex.RUnlock()
	fake.tDigestInfoMutex.RLock()
	defer fake.tDigestInfoMutex.RUnlock()
	fake.tDigestMaxMutex.RLock()
	defer fake.tDigestMaxMutex.RUnlock()
	fake.tDigestMergeMutex.RLock()
	defer fake.tDigestMergeMutex.RUnlock()
	fake.tDigestMinMutex.RLock()
	defer fake.tDigestMinMutex.RUnlock()
	fake.tDigestQuantileMutex.RLock()
	defer fake.tDigestQuantileMutex.RUnlock()
	fake.tDigestRankMutex.RLock()
	defer fake.tDigestRankMutex.RUnlock()
	fake.tDigestResetMutex.RLock()
	defer fake.tDigestResetMutex.RUnlock()
	fake.tDigestRevRankMutex.RLock()
	defer fake.tDigestRevRankMutex.RUnlock()
	fake.tDigestTrimmedMeanMutex.RLock()
	defer fake.tDigestTrimmedMeanMutex.RUnlock()
	fake.tFCallMutex.RLock()
	defer fake.tFCallMutex.RUnlock()
	fake.tFCallASYNCMutex.RLock()
	defer fake.tFCallASYNCMutex.RUnlock()
	fake.tFCallASYNCArgsMutex.RLock()
	defer fake.tFCallASYNCArgsMutex.RUnlock()
	fake.tFCallArgsMutex.RLock()
	defer fake.tFCallArgsMutex.RUnlock()
	fake.tFunctionDeleteMutex.RLock()
	defer fake.tFunctionDeleteMutex.RUnlock()
	fake.tFunctionListMutex.RLock()
	defer fake.tFunctionListMutex.RUnlock()
	fake.tFunctionListArgsMutex.RLock()
	defer fake.tFunctionListArgsMutex.RUnlock()
	fake.tFunctionLoadMutex.RLock()
	defer fake.tFunctionLoadMutex.RUnlock()
	fake.tFunctionLoadArgsMutex.RLock()
	defer fake.tFunctionLoadArgsMutex.RUnlock()
	fake.tSAddMutex.RLock()
	defer fake.tSAddMutex.RUnlock()
	fake.tSAddWithArgsMutex.RLock()
	defer fake.tSAddWithArgsMutex.RUnlock()
	fake.tSAlterMutex.RLock()
	defer fake.tSAlterMutex.RUnlock()
	fake.tSCreateMutex.RLock()
	defer fake.tSCreateMutex.RUnlock()
	fake.tSCreateRuleMutex.RLock()
	defer fake.tSCreateRuleMutex.RUnlock()
	fake.tSCreateRuleWithArgsMutex.RLock()
	defer fake.tSCreateRuleWithArgsMutex.RUnlock()
	fake.tSCreateWithArgsMutex.RLock()
	defer fake.tSCreateWithArgsMutex.RUnlock()
	fake.tSDecrByMutex.RLock()
	defer fake.tSDecrByMutex.RUnlock()
	fake.tSDecrByWithArgsMutex.RLock()
	defer fake.tSDecrByWithArgsMutex.RUnlock()
	fake.tSDelMutex.RLock()
	defer fake.tSDelMutex.RUnlock()
	fake.tSDeleteRuleMutex.RLock()
	defer fake.tSDeleteRuleMutex.RUnlock()
	fake.tSGetMutex.RLock()
	defer fake.tSGetMutex.RUnlock()
	fake.tSGetWithArgsMutex.RLock()
	defer fake.tSGetWithArgsMutex.RUnlock()
	fake.tSIncrByMutex.RLock()
	defer fake.tSIncrByMutex.RUnlock()
	fake.tSIncrByWithArgsMutex.RLock()
	defer fake.tSIncrByWithArgsMutex.RUnlock()
	fake.tSInfoMutex.RLock()
	defer fake.tSInfoMutex.RUnlock()
	fake.tSInfoWithArgsMutex.RLock()
	defer fake.tSInfoWithArgsMutex.RUnlock()
	fake.tSMAddMutex.RLock()
	defer fake.tSMAddMutex.RUnlock()
	fake.tSMGetMutex.RLock()
	defer fake.tSMGetMutex.RUnlock()
	fake.tSMGetWithArgsMutex.RLock()
	defer fake.tSMGetWithArgsMutex.RUnlock()
	fake.tSMRangeMutex.RLock()
	defer fake.tSMRangeMutex.RUnlock()
	fake.tSMRangeWithArgsMutex.RLock()
	defer fake.tSMRangeWithArgsMutex.RUnlock()
	fake.tSMRevRangeMutex.RLock()
	defer fake.tSMRevRangeMutex.RUnlock()
	fake.tSMRevRangeWithArgsMutex.RLock()
	defer fake.tSMRevRangeWithArgsMutex.RUnlock()
	fake.tSQueryIndexMutex.RLock()
	defer fake.tSQueryIndexMutex.RUnlock()
	fake.tSRangeMutex.RLock()
	defer fake.tSRangeMutex.RUnlock()
	fake.tSRangeWithArgsMutex.RLock()
	defer fake.tSRangeWithArgsMutex.RUnlock()
	fake.tSRevRangeMutex.RLock()
	defer fake.tSRevRangeMutex.RUnlock()
	fake.tSRevRangeWithArgsMutex.RLock()
	defer fake.tSRevRangeWithArgsMutex.RUnlock()
	fake.tTLMutex.RLock()
	defer fake.tTLMutex.RUnlock()
	fake.timeMutex.RLock()
	defer fake.timeMutex.RUnlock()
	fake.topKAddMutex.RLock()
	defer fake.topKAddMutex.RUnlock()
	fake.topKCountMutex.RLock()
	defer fake.topKCountMutex.RUnlock()
	fake.topKIncrByMutex.RLock()
	defer fake.topKIncrByMutex.RUnlock()
	fake.topKInfoMutex.RLock()
	defer fake.topKInfoMutex.RUnlock()
	fake.topKListMutex.RLock()
	defer fake.topKListMutex.RUnlock()
	fake.topKListWithCountMutex.RLock()
	defer fake.topKListWithCountMutex.RUnlock()
	fake.topKQueryMutex.RLock()
	defer fake.topKQueryMutex.RUnlock()
	fake.topKReserveMutex.RLock()
	defer fake.topKReserveMutex.RUnlock()
	fake.topKReserveWithOptionsMutex.RLock()
	defer fake.topKReserveWithOptionsMutex.RUnlock()
	fake.touchMutex.RLock()
	defer fake.touchMutex.RUnlock()
	fake.txPipelineMutex.RLock()
	defer fake.txPipelineMutex.RUnlock()
	fake.txPipelinedMutex.RLock()
	defer fake.txPipelinedMutex.RUnlock()
	fake.typeMutex.RLock()
	defer fake.typeMutex.RUnlock()
	fake.unlinkMutex.RLock()
	defer fake.unlinkMutex.RUnlock()
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	fake.xAckMutex.RLock()
	defer fake.xAckMutex.RUnlock()
	fake.xAddMutex.RLock()
	defer fake.xAddMutex.RUnlock()
	fake.xAutoClaimMutex.RLock()
	defer fake.xAutoClaimMutex.RUnlock()
	fake.xAutoClaimJustIDMutex.RLock()
	defer fake.xAutoClaimJustIDMutex.RUnlock()
	fake.xClaimMutex.RLock()
	defer fake.xClaimMutex.RUnlock()
	fake.xClaimJustIDMutex.RLock()
	defer fake.xClaimJustIDMutex.RUnlock()
	fake.xDelMutex.RLock()
	defer fake.xDelMutex.RUnlock()
	fake.xGroupCreateMutex.RLock()
	defer fake.xGroupCreateMutex.RUnlock()
	fake.xGroupCreateConsumerMutex.RLock()
	defer fake.xGroupCreateConsumerMutex.RUnlock()
	fake.xGroupCreateMkStreamMutex.RLock()
	defer fake.xGroupCreateMkStreamMutex.RUnlock()
	fake.xGroupDelConsumerMutex.RLock()
	defer fake.xGroupDelConsumerMutex.RUnlock()
	fake.xGroupDestroyMutex.RLock()
	defer fake.xGroupDestroyMutex.RUnlock()
	fake.xGroupSetIDMutex.RLock()
	defer fake.xGroupSetIDMutex.RUnlock()
	fake.xInfoConsumersMutex.RLock()
	defer fake.xInfoConsumersMutex.RUnlock()
	fake.xInfoGroupsMutex.RLock()
	defer fake.xInfoGroupsMutex.RUnlock()
	fake.xInfoStreamMutex.RLock()
	defer fake.xInfoStreamMutex.RUnlock()
	fake.xInfoStreamFullMutex.RLock()
	defer fake.xInfoStreamFullMutex.RUnlock()
	fake.xLenMutex.RLock()
	defer fake.xLenMutex.RUnlock()
	fake.xPendingMutex.RLock()
	defer fake.xPendingMutex.RUnlock()
	fake.xPendingExtMutex.RLock()
	defer fake.xPendingExtMutex.RUnlock()
	fake.xRangeMutex.RLock()
	defer fake.xRangeMutex.RUnlock()
	fake.xRangeNMutex.RLock()
	defer fake.xRangeNMutex.RUnlock()
	fake.xReadMutex.RLock()
	defer fake.xReadMutex.RUnlock()
	fake.xReadGroupMutex.RLock()
	defer fake.xReadGroupMutex.RUnlock()
	fake.xReadStreamsMutex.RLock()
	defer fake.xReadStreamsMutex.RUnlock()
	fake.xRevRangeMutex.RLock()
	defer fake.xRevRangeMutex.RUnlock()
	fake.xRevRangeNMutex.RLock()
	defer fake.xRevRangeNMutex.RUnlock()
	fake.xTrimMaxLenMutex.RLock()
	defer fake.xTrimMaxLenMutex.RUnlock()
	fake.xTrimMaxLenApproxMutex.RLock()
	defer fake.xTrimMaxLenApproxMutex.RUnlock()
	fake.xTrimMinIDMutex.RLock()
	defer fake.xTrimMinIDMutex.RUnlock()
	fake.xTrimMinIDApproxMutex.RLock()
	defer fake.xTrimMinIDApproxMutex.RUnlock()
	fake.zAddMutex.RLock()
	defer fake.zAddMutex.RUnlock()
	fake.zAddArgsMutex.RLock()
	defer fake.zAddArgsMutex.RUnlock()
	fake.zAddArgsIncrMutex.RLock()
	defer fake.zAddArgsIncrMutex.RUnlock()
	fake.zAddGTMutex.RLock()
	defer fake.zAddGTMutex.RUnlock()
	fake.zAddLTMutex.RLock()
	defer fake.zAddLTMutex.RUnlock()
	fake.zAddNXMutex.RLock()
	defer fake.zAddNXMutex.RUnlock()
	fake.zAddXXMutex.RLock()
	defer fake.zAddXXMutex.RUnlock()
	fake.zCardMutex.RLock()
	defer fake.zCardMutex.RUnlock()
	fake.zCountMutex.RLock()
	defer fake.zCountMutex.RUnlock()
	fake.zDiffMutex.RLock()
	defer fake.zDiffMutex.RUnlock()
	fake.zDiffStoreMutex.RLock()
	defer fake.zDiffStoreMutex.RUnlock()
	fake.zDiffWithScoresMutex.RLock()
	defer fake.zDiffWithScoresMutex.RUnlock()
	fake.zIncrByMutex.RLock()
	defer fake.zIncrByMutex.RUnlock()
	fake.zInterMutex.RLock()
	defer fake.zInterMutex.RUnlock()
	fake.zInterCardMutex.RLock()
	defer fake.zInterCardMutex.RUnlock()
	fake.zInterStoreMutex.RLock()
	defer fake.zInterStoreMutex.RUnlock()
	fake.zInterWithScoresMutex.RLock()
	defer fake.zInterWithScoresMutex.RUnlock()
	fake.zLexCountMutex.RLock()
	defer fake.zLexCountMutex.RUnlock()
	fake.zMPopMutex.RLock()
	defer fake.zMPopMutex.RUnlock()
	fake.zMScoreMutex.RLock()
	defer fake.zMScoreMutex.RUnlock()
	fake.zPopMaxMutex.RLock()
	defer fake.zPopMaxMutex.RUnlock()
	fake.zPopMinMutex.RLock()
	defer fake.zPopMinMutex.RUnlock()
	fake.zRandMemberMutex.RLock()
	defer fake.zRandMemberMutex.RUnlock()
	fake.zRandMemberWithScoresMutex.RLock()
	defer fake.zRandMemberWithScoresMutex.RUnlock()
	fake.zRangeMutex.RLock()
	defer fake.zRangeMutex.RUnlock()
	fake.zRangeArgsMutex.RLock()
	defer fake.zRangeArgsMutex.RUnlock()
	fake.zRangeArgsWithScoresMutex.RLock()
	defer fake.zRangeArgsWithScoresMutex.RUnlock()
	fake.zRangeByLexMutex.RLock()
	defer fake.zRangeByLexMutex.RUnlock()
	fake.zRangeByScoreMutex.RLock()
	defer fake.zRangeByScoreMutex.RUnlock()
	fake.zRangeByScoreWithScoresMutex.RLock()
	defer fake.zRangeByScoreWithScoresMutex.RUnlock()
	fake.zRangeStoreMutex.RLock()
	defer fake.zRangeStoreMutex.RUnlock()
	fake.zRangeWithScoresMutex.RLock()
	defer fake.zRangeWithScoresMutex.RUnlock()
	fake.zRankMutex.RLock()
	defer fake.zRankMutex.RUnlock()
	fake.zRankWithScoreMutex.RLock()
	defer fake.zRankWithScoreMutex.RUnlock()
	fake.zRemMutex.RLock()
	defer fake.zRemMutex.RUnlock()
	fake.zRemRangeByLexMutex.RLock()
	defer fake.zRemRangeByLexMutex.RUnlock()
	fake.zRemRangeByRankMutex.RLock()
	defer fake.zRemRangeByRankMutex.RUnlock()
	fake.zRemRangeByScoreMutex.RLock()
	defer fake.zRemRangeByScoreMutex.RUnlock()
	fake.zRevRangeMutex.RLock()
	defer fake.zRevRangeMutex.RUnlock()
	fake.zRevRangeByLexMutex.RLock()
	defer fake.zRevRangeByLexMutex.RUnlock()
	fake.zRevRangeByScoreMutex.RLock()
	defer fake.zRevRangeByScoreMutex.RUnlock()
	fake.zRevRangeByScoreWithScoresMutex.RLock()
	defer fake.zRevRangeByScoreWithScoresMutex.RUnlock()
	fake.zRevRangeWithScoresMutex.RLock()
	defer fake.zRevRangeWithScoresMutex.RUnlock()
	fake.zRevRankMutex.RLock()
	defer fake.zRevRankMutex.RUnlock()
	fake.zRevRankWithScoreMutex.RLock()
	defer fake.zRevRankWithScoreMutex.RUnlock()
	fake.zScanMutex.RLock()
	defer fake.zScanMutex.RUnlock()
	fake.zScoreMutex.RLock()
	defer fake.zScoreMutex.RUnlock()
	fake.zUnionMutex.RLock()
	defer fake.zUnionMutex.RUnlock()
	fake.zUnionStoreMutex.RLock()
	defer fake.zUnionStoreMutex.RUnlock()
	fake.zUnionWithScoresMutex.RLock()
	defer fake.zUnionWithScoresMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ redis.Client = new(FakeClient)
